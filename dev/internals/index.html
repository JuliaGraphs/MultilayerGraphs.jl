<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · MultilayerGraphs.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://InPhyT.github.io/MultilayerGraphs.jl/internals/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MultilayerGraphs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MultilayerGraphs.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/main/docs/src/internals.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h1><ul><li><a href="#MultilayerGraphs.AbstractGraphOfGraphs"><code>MultilayerGraphs.AbstractGraphOfGraphs</code></a></li><li><a href="#MultilayerGraphs.AbstractInterlayer"><code>MultilayerGraphs.AbstractInterlayer</code></a></li><li><a href="#MultilayerGraphs.AbstractLayer"><code>MultilayerGraphs.AbstractLayer</code></a></li><li><a href="#MultilayerGraphs.AbstractMultilayerEdge"><code>MultilayerGraphs.AbstractMultilayerEdge</code></a></li><li><a href="#MultilayerGraphs.AbstractMultilayerGraph"><code>MultilayerGraphs.AbstractMultilayerGraph</code></a></li><li><a href="#MultilayerGraphs.AbstractMultilayerVertex"><code>MultilayerGraphs.AbstractMultilayerVertex</code></a></li><li><a href="#MultilayerGraphs.AbstractVertex"><code>MultilayerGraphs.AbstractVertex</code></a></li><li><a href="#MultilayerGraphs.DiGraphOfGraphs"><code>MultilayerGraphs.DiGraphOfGraphs</code></a></li><li><a href="#MultilayerGraphs.DiGraphOfGraphs-Union{Tuple{T}, Tuple{Vector{T}, Matrix{Float64}}} where T&lt;:Graphs.AbstractGraph"><code>MultilayerGraphs.DiGraphOfGraphs</code></a></li><li><a href="#MultilayerGraphs.GraphOfGraphs"><code>MultilayerGraphs.GraphOfGraphs</code></a></li><li><a href="#MultilayerGraphs.GraphOfGraphs-Union{Tuple{T}, Tuple{Vector{T}, Union{LinearAlgebra.Symmetric{Float64, Matrix{Float64}}, Matrix{Float64}}}} where T&lt;:Graphs.AbstractGraph"><code>MultilayerGraphs.GraphOfGraphs</code></a></li><li><a href="#MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Int64, Symbol, Symbol, Symbol, Type{G}, Tuple{Vararg{MultilayerEdge{MultilayerVertex{T}, U}}}}} where {T&lt;:(Union{AbstractVertex, var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:Integer), U&lt;:Real, G&lt;:Graphs.AbstractGraph{T}}"><code>MultilayerGraphs.Interlayer</code></a></li><li><a href="#MultilayerGraphs.Interlayer"><code>MultilayerGraphs.Interlayer</code></a></li><li><a href="#MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{T}, Tuple{Int64, Symbol, Symbol, Symbol, Type{G}, Int64}} where {T&lt;:(Union{AbstractVertex, var&quot;#s14&quot;} where var&quot;#s14&quot;&lt;:Integer), G&lt;:Graphs.AbstractGraph{T}}"><code>MultilayerGraphs.Interlayer</code></a></li><li><a href="#MultilayerGraphs.IsWeighted"><code>MultilayerGraphs.IsWeighted</code></a></li><li><a href="#MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{T}, Tuple{Int64, Symbol, Type{G}, Int64}} where {T&lt;:(Union{AbstractVertex, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:Integer), G&lt;:Graphs.AbstractGraph{T}}"><code>MultilayerGraphs.Layer</code></a></li><li><a href="#MultilayerGraphs.Layer"><code>MultilayerGraphs.Layer</code></a></li><li><a href="#MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{Symbol, G}} where G&lt;:Graphs.AbstractGraph"><code>MultilayerGraphs.Layer</code></a></li><li><a href="#MultilayerGraphs.MultilayerDiGraph-Tuple{Int64, Int64, Int64, Int64, Vector{DataType}}"><code>MultilayerGraphs.MultilayerDiGraph</code></a></li><li><a href="#MultilayerGraphs.MultilayerDiGraph-Union{Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}}}} where {T, U}"><code>MultilayerGraphs.MultilayerDiGraph</code></a></li><li><a href="#MultilayerGraphs.MultilayerDiGraph"><code>MultilayerGraphs.MultilayerDiGraph</code></a></li><li><a href="#MultilayerGraphs.MultilayerDiGraph-Tuple{Int64, Type{&lt;:Number}, Type{&lt;:Number}}"><code>MultilayerGraphs.MultilayerDiGraph</code></a></li><li><a href="#MultilayerGraphs.MultilayerDiGraph-Union{Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}}}, Tuple{U}, Tuple{T}} where {T, U}"><code>MultilayerGraphs.MultilayerDiGraph</code></a></li><li><a href="#MultilayerGraphs.MultilayerEdge"><code>MultilayerGraphs.MultilayerEdge</code></a></li><li><a href="#MultilayerGraphs.MultilayerGraph-Tuple{Int64, Type{&lt;:Number}, Type{&lt;:Number}}"><code>MultilayerGraphs.MultilayerGraph</code></a></li><li><a href="#MultilayerGraphs.MultilayerGraph-Union{Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}}}, Tuple{U}, Tuple{T}} where {T, U}"><code>MultilayerGraphs.MultilayerGraph</code></a></li><li><a href="#MultilayerGraphs.MultilayerGraph"><code>MultilayerGraphs.MultilayerGraph</code></a></li><li><a href="#MultilayerGraphs.MultilayerGraph-Tuple{Int64, Int64, Int64, Int64, Vector{DataType}}"><code>MultilayerGraphs.MultilayerGraph</code></a></li><li><a href="#MultilayerGraphs.MultilayerGraph-Union{Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}}}} where {T, U}"><code>MultilayerGraphs.MultilayerGraph</code></a></li><li><a href="#MultilayerGraphs.MultilayerVertex"><code>MultilayerGraphs.MultilayerVertex</code></a></li><li><a href="#MultilayerGraphs.δ"><code>MultilayerGraphs.δ</code></a></li><li><a href="#MultilayerGraphs.δ-Tuple{Int64}"><code>MultilayerGraphs.δ</code></a></li><li><a href="#MultilayerGraphs.δ_1"><code>MultilayerGraphs.δ_1</code></a></li><li><a href="#MultilayerGraphs.δ_2"><code>MultilayerGraphs.δ_2</code></a></li><li><a href="#MultilayerGraphs.δ_3"><code>MultilayerGraphs.δ_3</code></a></li><li><a href="#MultilayerGraphs.δ_Ω"><code>MultilayerGraphs.δ_Ω</code></a></li><li><a href="#SimpleWeightedGraphs.SimpleWeightedDiGraph-Tuple{Integer, Integer}"><code>SimpleWeightedGraphs.SimpleWeightedDiGraph</code></a></li><li><a href="#SimpleWeightedGraphs.SimpleWeightedDiGraph-Union{Tuple{T}, Tuple{Integer, Integer}} where T"><code>SimpleWeightedGraphs.SimpleWeightedDiGraph</code></a></li><li><a href="#SimpleWeightedGraphs.SimpleWeightedDiGraph-Union{Tuple{U}, Tuple{T}, Tuple{Integer, Integer}} where {T, U}"><code>SimpleWeightedGraphs.SimpleWeightedDiGraph</code></a></li><li><a href="#SimpleWeightedGraphs.SimpleWeightedGraph-Union{Tuple{T}, Tuple{Integer, Integer}} where T"><code>SimpleWeightedGraphs.SimpleWeightedGraph</code></a></li><li><a href="#SimpleWeightedGraphs.SimpleWeightedGraph-Tuple{Integer, Integer}"><code>SimpleWeightedGraphs.SimpleWeightedGraph</code></a></li><li><a href="#SimpleWeightedGraphs.SimpleWeightedGraph-Union{Tuple{U}, Tuple{T}, Tuple{Integer, Integer}} where {T, U}"><code>SimpleWeightedGraphs.SimpleWeightedGraph</code></a></li><li><a href="#Base.:==-Tuple{Interlayer, Interlayer}"><code>Base.:==</code></a></li><li><a href="#Base.:==-Tuple{Layer, Layer}"><code>Base.:==</code></a></li><li><a href="#Base.:==-Tuple{AbstractMultilayerGraph, AbstractMultilayerGraph}"><code>Base.:==</code></a></li><li><a href="#Base.eltype-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>Base.eltype</code></a></li><li><a href="#Base.eltype-Tuple{In} where In&lt;:Interlayer"><code>Base.eltype</code></a></li><li><a href="#Base.eltype-Tuple{L} where L&lt;:Layer"><code>Base.eltype</code></a></li><li><a href="#Base.getindex-Union{Tuple{T}, Tuple{MultilayerGraphs.δ{T}, Int64}} where T"><code>Base.getindex</code></a></li><li><a href="#Base.getindex-Union{Tuple{O}, Tuple{O, Int64}} where O&lt;:OrderedCollections.OrderedDict"><code>Base.getindex</code></a></li><li><a href="#Base.getproperty-Union{Tuple{M}, Tuple{M, Symbol}} where M&lt;:AbstractMultilayerGraph"><code>Base.getproperty</code></a></li><li><a href="#Base.getproperty-Union{Tuple{In}, Tuple{In, Symbol}} where In&lt;:Interlayer"><code>Base.getproperty</code></a></li><li><a href="#Base.getproperty-Union{Tuple{L}, Tuple{L, Symbol}} where L&lt;:Layer"><code>Base.getproperty</code></a></li><li><a href="#Base.size-Tuple{MultilayerGraphs.δ}"><code>Base.size</code></a></li><li><a href="#Graphs.LinAlg.adjacency_matrix-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}}"><code>Graphs.LinAlg.adjacency_matrix</code></a></li><li><a href="#Graphs.LinAlg.adjacency_matrix-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, In&lt;:Interlayer{T, U, G}}"><code>Graphs.LinAlg.adjacency_matrix</code></a></li><li><a href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V, U}} where {T, U&lt;:Real, M&lt;:MultilayerGraph{T, U}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.add_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, E}} where {T, U&lt;:Real, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}, E&lt;:MultilayerEdge{MultilayerVertex{T}, U}}"><code>Graphs.SimpleGraphs.add_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{IsWeighted{G}}, In, V, V, U}} where {T, U&lt;:Real, G&lt;:Graphs.AbstractGraph{T}, In&lt;:Interlayer{T, U, G}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.add_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U&lt;:Real, M&lt;:MultilayerDiGraph{T, U}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.add_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{SimpleTraits.Not{IsWeighted{G}}}, In, V, V}} where {T, U&lt;:Real, G&lt;:Graphs.AbstractGraph{T}, In&lt;:Interlayer{T, U, G}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.add_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, E}} where {T, U&lt;:Real, G, In&lt;:Interlayer{T, U, G}, E&lt;:MultilayerEdge{MultilayerVertex{T}, U}}"><code>Graphs.SimpleGraphs.add_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U, M&lt;:MultilayerDiGraph{T, U}, E&lt;:MultilayerEdge{MultilayerVertex{T}, Nothing}}"><code>Graphs.SimpleGraphs.add_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, E}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}, E&lt;:MultilayerEdge{MultilayerVertex{T}, Nothing}}"><code>Graphs.SimpleGraphs.add_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{SimpleTraits.Not{IsWeighted{G}}}, L, V, V}} where {T, U&lt;:Real, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.add_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U&lt;:Real, M&lt;:MultilayerGraph{T, U}, E&lt;:MultilayerEdge{MultilayerVertex{T}, U}}"><code>Graphs.SimpleGraphs.add_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{IsWeighted{G}}, L, V, V, U}} where {T, U&lt;:Real, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.add_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U&lt;:Real, M&lt;:MultilayerDiGraph{T, U}, E&lt;:MultilayerEdge{MultilayerVertex{T}, U}}"><code>Graphs.SimpleGraphs.add_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U, M&lt;:MultilayerGraph{T, U}, E&lt;:MultilayerEdge{MultilayerVertex{T}, Nothing}}"><code>Graphs.SimpleGraphs.add_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V, U}} where {T, U&lt;:Real, M&lt;:MultilayerDiGraph{T, U}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.add_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, E}} where {T, U, G, In&lt;:Interlayer{T, U, G}, E&lt;:MultilayerEdge{MultilayerVertex{T}, Nothing}}"><code>Graphs.SimpleGraphs.add_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U&lt;:Real, M&lt;:MultilayerGraph{T, U}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.add_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.rem_edge!-Union{Tuple{V}, Tuple{In}, Tuple{U}, Tuple{T}, Tuple{In, V, V}} where {T, U, In&lt;:(Interlayer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}), V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.rem_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.rem_edge!-Union{Tuple{V}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, V, V}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.rem_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.rem_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U, M&lt;:MultilayerGraph{T, U}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.rem_edge!</code></a></li><li><a href="#Graphs.SimpleGraphs.rem_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U, M&lt;:MultilayerDiGraph{T, U}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.rem_edge!</code></a></li><li><a href="#Graphs.dst-Tuple{AbstractMultilayerEdge}"><code>Graphs.dst</code></a></li><li><a href="#Graphs.edges-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>Graphs.edges</code></a></li><li><a href="#Graphs.edges-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}}"><code>Graphs.edges</code></a></li><li><a href="#Graphs.edges-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, In&lt;:Interlayer{T, U, G}}"><code>Graphs.edges</code></a></li><li><a href="#Graphs.edgetype-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>Graphs.edgetype</code></a></li><li><a href="#Graphs.edgetype-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>Graphs.edgetype</code></a></li><li><a href="#Graphs.edgetype-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, L&lt;:Layer{T, U, G}}"><code>Graphs.edgetype</code></a></li><li><a href="#Graphs.eigenvector_centrality-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>Graphs.eigenvector_centrality</code></a></li><li><a href="#Graphs.has_edge-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, MultilayerVertex{T}, MultilayerVertex{T}}} where {T, U, G, L&lt;:Layer{T, U, G}}"><code>Graphs.has_edge</code></a></li><li><a href="#Graphs.has_edge-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{SimpleTraits.Not{Graphs.IsDirected{G}}}, L, MultilayerVertex{T}, MultilayerVertex{T}, U}} where {T, U, G, L&lt;:Layer{T, U, G}}"><code>Graphs.has_edge</code></a></li><li><a href="#Graphs.has_edge-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{Graphs.IsDirected{G}}, In, MultilayerVertex{T}, MultilayerVertex{T}, U}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>Graphs.has_edge</code></a></li><li><a href="#Graphs.has_edge-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{SimpleTraits.Not{Graphs.IsDirected{G}}}, In, MultilayerVertex{T}, MultilayerVertex{T}, U}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>Graphs.has_edge</code></a></li><li><a href="#Graphs.has_edge-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{Graphs.IsDirected{G}}, L, MultilayerVertex{T}, MultilayerVertex{T}, U}} where {T, U, G, L&lt;:Layer{T, U, G}}"><code>Graphs.has_edge</code></a></li><li><a href="#Graphs.has_edge-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}, V&lt;:MultilayerVertex{T}}"><code>Graphs.has_edge</code></a></li><li><a href="#Graphs.has_edge-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>Graphs.has_edge</code></a></li><li><a href="#Graphs.has_vertex-Union{Tuple{L}, Tuple{L, Integer}} where L&lt;:Layer"><code>Graphs.has_vertex</code></a></li><li><a href="#Graphs.has_vertex-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>Graphs.has_vertex</code></a></li><li><a href="#Graphs.has_vertex-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, V}} where {T, M&lt;:(AbstractMultilayerGraph{T}), V&lt;:MultilayerVertex{T}}"><code>Graphs.has_vertex</code></a></li><li><a href="#Graphs.inneighbors-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>Graphs.inneighbors</code></a></li><li><a href="#Graphs.inneighbors-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, MultilayerVertex{T}}} where {T, U, G, L&lt;:Layer{T, U, G}}"><code>Graphs.inneighbors</code></a></li><li><a href="#Graphs.inneighbors-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, V}} where {T, M&lt;:(AbstractMultilayerGraph{T}), V&lt;:MultilayerVertex{T}}"><code>Graphs.inneighbors</code></a></li><li><a href="#Graphs.is_directed-Tuple{M} where M&lt;:(Type{&lt;:MultilayerDiGraph})"><code>Graphs.is_directed</code></a></li><li><a href="#Graphs.is_directed-Tuple{M} where M&lt;:MultilayerDiGraph"><code>Graphs.is_directed</code></a></li><li><a href="#Graphs.is_directed-Tuple{M} where M&lt;:(Type{&lt;:MultilayerGraph})"><code>Graphs.is_directed</code></a></li><li><a href="#Graphs.is_directed-Tuple{L} where L&lt;:Layer"><code>Graphs.is_directed</code></a></li><li><a href="#Graphs.is_directed-Union{Tuple{Type{L}}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, L&lt;:Layer{T, U, G}}"><code>Graphs.is_directed</code></a></li><li><a href="#Graphs.is_directed-Tuple{M} where M&lt;:MultilayerGraph"><code>Graphs.is_directed</code></a></li><li><a href="#Graphs.is_directed-Union{Tuple{Type{In}}, Tuple{In}} where In&lt;:Interlayer"><code>Graphs.is_directed</code></a></li><li><a href="#Graphs.is_directed-Tuple{In} where In&lt;:Interlayer"><code>Graphs.is_directed</code></a></li><li><a href="#Graphs.modularity-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, Matrix{Int64}}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>Graphs.modularity</code></a></li><li><a href="#Graphs.ne-Tuple{L} where L&lt;:Layer"><code>Graphs.ne</code></a></li><li><a href="#Graphs.ne-Tuple{In} where In&lt;:Interlayer"><code>Graphs.ne</code></a></li><li><a href="#Graphs.ne-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>Graphs.ne</code></a></li><li><a href="#Graphs.nv-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>Graphs.nv</code></a></li><li><a href="#Graphs.nv-Tuple{In} where In&lt;:Interlayer"><code>Graphs.nv</code></a></li><li><a href="#Graphs.nv-Tuple{L} where L&lt;:Layer"><code>Graphs.nv</code></a></li><li><a href="#Graphs.outneighbors-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, V}} where {T, M&lt;:(AbstractMultilayerGraph{T}), V&lt;:MultilayerVertex{T}}"><code>Graphs.outneighbors</code></a></li><li><a href="#Graphs.outneighbors-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, MultilayerVertex{T}}} where {T, U, G, L&lt;:Layer{T, U, G}}"><code>Graphs.outneighbors</code></a></li><li><a href="#Graphs.outneighbors-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>Graphs.outneighbors</code></a></li><li><a href="#Graphs.vertices-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>Graphs.vertices</code></a></li><li><a href="#Graphs.vertices-Tuple{L} where L&lt;:Layer"><code>Graphs.vertices</code></a></li><li><a href="#Graphs.vertices-Tuple{In} where In&lt;:Interlayer"><code>Graphs.vertices</code></a></li><li><a href="#MultilayerGraphs._add_layer!-Union{Tuple{H}, Tuple{L}, Tuple{G}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}, H&lt;:(Type{&lt;:Graphs.AbstractGraph{T}})}"><code>MultilayerGraphs._add_layer!</code></a></li><li><a href="#MultilayerGraphs._specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:AbstractMultilayerGraph{T, U}, In&lt;:Interlayer{T, U, G}}"><code>MultilayerGraphs._specify_interlayer!</code></a></li><li><a href="#MultilayerGraphs.add_layer!-Union{Tuple{L}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerGraph{T, U}, L&lt;:Layer{T, U, G}}"><code>MultilayerGraphs.add_layer!</code></a></li><li><a href="#MultilayerGraphs.add_layer!-Union{Tuple{L}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerDiGraph{T, U}, L&lt;:Layer{T, U, G}}"><code>MultilayerGraphs.add_layer!</code></a></li><li><a href="#MultilayerGraphs.adjm_eltype-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>MultilayerGraphs.adjm_eltype</code></a></li><li><a href="#MultilayerGraphs.check_unique-Tuple{Union{Missing, Tuple, Vector}}"><code>MultilayerGraphs.check_unique</code></a></li><li><a href="#MultilayerGraphs.degree_second_moment-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.degree_second_moment</code></a></li><li><a href="#MultilayerGraphs.degree_variance-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.degree_variance</code></a></li><li><a href="#MultilayerGraphs.find_trunc_dim"><code>MultilayerGraphs.find_trunc_dim</code></a></li><li><a href="#MultilayerGraphs.format_trunc_chis-Tuple{Any, Any, Any}"><code>MultilayerGraphs.format_trunc_chis</code></a></li><li><a href="#MultilayerGraphs.get_common_type-Tuple{Vector{&lt;:DataType}}"><code>MultilayerGraphs.get_common_type</code></a></li><li><a href="#MultilayerGraphs.get_concrete_subtypes-Tuple{Type}"><code>MultilayerGraphs.get_concrete_subtypes</code></a></li><li><a href="#MultilayerGraphs.get_diagonal_adjacency_tensor-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T"><code>MultilayerGraphs.get_diagonal_adjacency_tensor</code></a></li><li><a href="#MultilayerGraphs.get_diagonal_elements-Union{Tuple{Array{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>MultilayerGraphs.get_diagonal_elements</code></a></li><li><a href="#MultilayerGraphs.get_graph_of_layers-Tuple{M} where M&lt;:MultilayerGraph"><code>MultilayerGraphs.get_graph_of_layers</code></a></li><li><a href="#MultilayerGraphs.get_graph_of_layers-Tuple{M} where M&lt;:MultilayerDiGraph"><code>MultilayerGraphs.get_graph_of_layers</code></a></li><li><a href="#MultilayerGraphs.get_interlayer-Union{Tuple{M}, Tuple{M, Symbol, Symbol}} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.get_interlayer</code></a></li><li><a href="#MultilayerGraphs.get_layer-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, Symbol}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>MultilayerGraphs.get_layer</code></a></li><li><a href="#MultilayerGraphs.get_oom-Tuple{Number}"><code>MultilayerGraphs.get_oom</code></a></li><li><a href="#MultilayerGraphs.get_overlay_monoplex_graph-Tuple{M} where M&lt;:MultilayerGraph"><code>MultilayerGraphs.get_overlay_monoplex_graph</code></a></li><li><a href="#MultilayerGraphs.get_overlay_monoplex_graph-Tuple{M} where M&lt;:MultilayerDiGraph"><code>MultilayerGraphs.get_overlay_monoplex_graph</code></a></li><li><a href="#MultilayerGraphs.get_projected_monoplex_graph-Tuple{M} where M&lt;:MultilayerGraph"><code>MultilayerGraphs.get_projected_monoplex_graph</code></a></li><li><a href="#MultilayerGraphs.get_projected_monoplex_graph-Tuple{M} where M&lt;:MultilayerDiGraph"><code>MultilayerGraphs.get_projected_monoplex_graph</code></a></li><li><a href="#MultilayerGraphs.get_subgraph-Union{Tuple{M}, Tuple{M, Vararg{Symbol}}} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.get_subgraph</code></a></li><li><a href="#MultilayerGraphs.get_symmetric_interlayer-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>MultilayerGraphs.get_symmetric_interlayer</code></a></li><li><a href="#MultilayerGraphs.is_weighted-Tuple{G} where G&lt;:Graphs.AbstractGraph"><code>MultilayerGraphs.is_weighted</code></a></li><li><a href="#MultilayerGraphs.isapproxsymmetric-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>MultilayerGraphs.isapproxsymmetric</code></a></li><li><a href="#MultilayerGraphs.isapproxsymmetric-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Integer"><code>MultilayerGraphs.isapproxsymmetric</code></a></li><li><a href="#MultilayerGraphs.iscompletelyinitialized-Tuple{Any}"><code>MultilayerGraphs.iscompletelyinitialized</code></a></li><li><a href="#MultilayerGraphs.mean_degree-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.mean_degree</code></a></li><li><a href="#MultilayerGraphs.multilayer_global_clustering_coefficient-Union{Tuple{M}, Tuple{M, Union{Float64, Symbol}}} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.multilayer_global_clustering_coefficient</code></a></li><li><a href="#MultilayerGraphs.multilayer_kronecker_delta-Tuple{NTuple{4, Int64}}"><code>MultilayerGraphs.multilayer_kronecker_delta</code></a></li><li><a href="#MultilayerGraphs.multilayer_weighted_global_clustering_coefficient-Union{Tuple{M}, Tuple{M, Vector{Float64}}, Tuple{M, Vector{Float64}, Union{Float64, Symbol}}} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.multilayer_weighted_global_clustering_coefficient</code></a></li><li><a href="#MultilayerGraphs.multiplex_interlayer-Union{Tuple{G}, Tuple{T}, Tuple{Int64, Symbol, Symbol, Symbol, Type{G}}} where {T&lt;:(Union{AbstractVertex, var&quot;#s14&quot;} where var&quot;#s14&quot;&lt;:Integer), G&lt;:Graphs.AbstractGraph{T}}"><code>MultilayerGraphs.multiplex_interlayer</code></a></li><li><a href="#MultilayerGraphs.nIn-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.nIn</code></a></li><li><a href="#MultilayerGraphs.nl-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.nl</code></a></li><li><a href="#MultilayerGraphs.nn-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.nn</code></a></li><li><a href="#MultilayerGraphs.nodes-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.nodes</code></a></li><li><a href="#MultilayerGraphs.overlay_clustering_coefficient-Union{Tuple{M}, Tuple{M, Union{Float64, Symbol}}} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.overlay_clustering_coefficient</code></a></li><li><a href="#MultilayerGraphs.specify_interlayer!-Union{Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, Symbol, Symbol, G}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerDiGraph{T, U}}"><code>MultilayerGraphs.specify_interlayer!</code></a></li><li><a href="#MultilayerGraphs.specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerGraph{T, U}, In&lt;:Interlayer{T, U, G}}"><code>MultilayerGraphs.specify_interlayer!</code></a></li><li><a href="#MultilayerGraphs.specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerDiGraph{T, U}, In&lt;:Interlayer{T, U, G}}"><code>MultilayerGraphs.specify_interlayer!</code></a></li><li><a href="#MultilayerGraphs.src-Tuple{AbstractMultilayerEdge}"><code>MultilayerGraphs.src</code></a></li><li><a href="#MultilayerGraphs.tensoreig-Tuple{Any, Any, Any}"><code>MultilayerGraphs.tensoreig</code></a></li><li><a href="#MultilayerGraphs.tensorsplit-Tuple"><code>MultilayerGraphs.tensorsplit</code></a></li><li><a href="#MultilayerGraphs.tensorsvd-Tuple{Any, Any, Any}"><code>MultilayerGraphs.tensorsvd</code></a></li><li><a href="#MultilayerGraphs.to_matrix-Tuple{Any, Any, Any}"><code>MultilayerGraphs.to_matrix</code></a></li><li><a href="#MultilayerGraphs.von_neumann_entropy-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:MultilayerGraph{T, U}}"><code>MultilayerGraphs.von_neumann_entropy</code></a></li><li><a href="#MultilayerGraphs.weight-Tuple{AbstractMultilayerEdge}"><code>MultilayerGraphs.weight</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.AbstractGraphOfGraphs" href="#MultilayerGraphs.AbstractGraphOfGraphs"><code>MultilayerGraphs.AbstractGraphOfGraphs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractGraphOfGraphs{T &lt;: AbstractGraph} &lt;: AbstractGraph{T} end</code></pre><p>An abstract type representing a graph of graphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/graph_of_graphs.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.AbstractInterlayer" href="#MultilayerGraphs.AbstractInterlayer"><code>MultilayerGraphs.AbstractInterlayer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractInterlayer{T,U,G}</code></pre><p>An abstract type representing a generic Interlayer.</p><p><strong>FIELDS</strong></p><ul><li><code>T</code>: the node type;</li><li><code>U</code>: the adjacency matrix/tensor eltype;</li><li><code>G</code>: the underlying graph type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.AbstractLayer" href="#MultilayerGraphs.AbstractLayer"><code>MultilayerGraphs.AbstractLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractLayer{T,U,G}</code></pre><p>An abstract type representing a generic Layer.</p><p><strong>FIELDS</strong></p><ul><li><code>T</code>: the node type;</li><li><code>U</code>: the adjacency matrix/tensor eltype;</li><li><code>G</code>: the underlying graph type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.AbstractMultilayerEdge" href="#MultilayerGraphs.AbstractMultilayerEdge"><code>MultilayerGraphs.AbstractMultilayerEdge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMultilayerEdge{T} &lt;: AbstractEdge{T}</code></pre><p>An abstract type representing a <code>MultilayerGraph</code> edge.</p><p>It must have fields: <code>src</code>, <code>dst</code>, <code>weight</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayeredge.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.AbstractMultilayerGraph" href="#MultilayerGraphs.AbstractMultilayerGraph"><code>MultilayerGraphs.AbstractMultilayerGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMultilayerGraph{T &lt;: Integer, U &lt;: Real} &lt;: AbstractGraph{T}</code></pre><p>An abstract type for multilayer graphs, it must contain the fields: <code>adjacency_tensor</code>, <code>layers</code>, <code>Interlayers</code>. It is a subtype of AbstractGraph and its concrete subtypes may extend Graphs.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.AbstractMultilayerVertex" href="#MultilayerGraphs.AbstractMultilayerVertex"><code>MultilayerGraphs.AbstractMultilayerVertex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMultilayerVertex{T} &lt;: AbstractVertex{T}</code></pre><p>An abstract type representing an abstract MultilayerGraph vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayervertex.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.AbstractVertex" href="#MultilayerGraphs.AbstractVertex"><code>MultilayerGraphs.AbstractVertex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractVertex{T}</code></pre><p>An abstract type representing a graph vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayervertex.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.DiGraphOfGraphs" href="#MultilayerGraphs.DiGraphOfGraphs"><code>MultilayerGraphs.DiGraphOfGraphs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct DiGraphOfGraphs{T} &lt;: AbstractGraphOfGraphs{T}</code></pre><p>Default directed concrete implementation of <code>AbstractGraphOfGraphs</code>.</p><p><strong>FIELDS</strong></p><ul><li><code>nodes::OrderedDict{Int64,T}</code>: An <code>OrderedDict</code> that associates graphs (values) to Int64 nodes (keys).</li><li><code>graph::SimpleWeightedGraph{Int64,Float64}</code>: The weighted directed graph representing the graph of graphs. Its Int64 nodes are associated to graphs via the <code>nodes</code> field.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/graph_of_graphs.jl#L42-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.DiGraphOfGraphs-Union{Tuple{T}, Tuple{Vector{T}, Matrix{Float64}}} where T&lt;:Graphs.AbstractGraph" href="#MultilayerGraphs.DiGraphOfGraphs-Union{Tuple{T}, Tuple{Vector{T}, Matrix{Float64}}} where T&lt;:Graphs.AbstractGraph"><code>MultilayerGraphs.DiGraphOfGraphs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DiGraphOfGraphs(graphs::Vector{T}, adjacency_matrix::Matrix{Float64})</code></pre><p>Outer constructor for DiGraphOfGraphs.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>graphs::Vector{T}</code>: The vector of nodes of the graphs of graphs. Each of them will be assigned to an integer, from 1 to length(graphs), and their order is assumed to be the same as the rows and columns of the <code>adjacency_matrix</code> argument.</li><li><code>adjacency_matrix::Matrix{Float64}</code>: The adjacency matrix of the graph of graphs. Its (i,j)-element is the weight of the link between <code>graphs[i]</code> and <code>graphs[j]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/graph_of_graphs.jl#L57-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.GraphOfGraphs" href="#MultilayerGraphs.GraphOfGraphs"><code>MultilayerGraphs.GraphOfGraphs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct GraphOfGraphs{T} &lt;: AbstractGraphOfGraphs{T}</code></pre><p>Default undirected concrete implementation of <code>AbstractGraphOfGraphs</code>.</p><p><strong>FIELDS</strong></p><ul><li><code>nodes::OrderedDict{Int64,T}</code>: An <code>OrderedDict</code> that associates graphs (values) to Int64 nodes (keys).</li><li><code>graph::SimpleWeightedGraph{Int64,Float64}</code>: The weighted undirected graph representing the graph of graphs. Its Int64 nodes are associated to graphs via the <code>nodes</code> field.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/graph_of_graphs.jl#L11-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.GraphOfGraphs-Union{Tuple{T}, Tuple{Vector{T}, Union{LinearAlgebra.Symmetric{Float64, Matrix{Float64}}, Matrix{Float64}}}} where T&lt;:Graphs.AbstractGraph" href="#MultilayerGraphs.GraphOfGraphs-Union{Tuple{T}, Tuple{Vector{T}, Union{LinearAlgebra.Symmetric{Float64, Matrix{Float64}}, Matrix{Float64}}}} where T&lt;:Graphs.AbstractGraph"><code>MultilayerGraphs.GraphOfGraphs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GraphOfGraphs(graphs::Vector{T}, adjacency_matrix::Matrix{Float64})</code></pre><p>Outer constructor for GraphOfGraphs.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>graphs::Vector{T}</code>: The vector of nodes of the graphs of graphs. Each of them will be assigned to an integer, from 1 to length(graphs), and their order is assumed to be the same as the rows and columns of the <code>adjacency_matrix</code> argument.</li><li><code>adjacency_matrix::Matrix{Float64}</code>: The adjacency matrix of the graph of graphs. Its (i,j)-element is the weight of the link between <code>graphs[i]</code> and <code>graphs[j]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/graph_of_graphs.jl#L26-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Interlayer" href="#MultilayerGraphs.Interlayer"><code>MultilayerGraphs.Interlayer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Interlayer{G &lt;: AbstractGraph}</code></pre><p>Represents an interlayer in a <code>Multilayer(Di)Graph</code>. </p><p><strong>FIELDS</strong></p><ul><li><code>nv</code>::Int64 : the number of nodes;</li><li><code>name</code>`::Symbol : name of the Interlayer;</li><li><code>layer_1</code>::Symbol: name of one of the Layers connected by this Interlayer;</li><li><code>layer_2</code>::Symbol: name of one of the Layers connected by this Interlayer;</li><li><code>graph_type</code>`::Type{G}: type of the graph underlying the Interlayer;</li><li><code>edge_list</code>::Tuple{Vararg{ &lt;: MultilayerEdge{MultilayerVertex{T},U} }}: edge list for the Interlayer;</li><li><code>forbidden_vertices</code>::Vector{MultilayerVertex{T}}: nodes of the MultilayerGraph that are not part of this Interlayer (they will be formally present in the Interlayer but it will be checked that they aren&#39;t adjacacent to any other node);</li><li><code>forbidden_edges</code>::Vector{NTuple{2, MultilayerVertex{T}}}: edges that are required not to exist in this Interlayer.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">Interlayer(name::Symbol,layer_1::Symbol,layer_2::Symbol, graph::G, forbidden_vertices::Vector{MultilayerVertex{T}}, forbidden_edges::Vector{NTuple{2, MultilayerVertex{T}}}; U::Union{Type{ &lt;: Real}, Nothing} = nothing  ) where { T &lt;: Union{ &lt;: Integer, AbstractVertex}, G &lt;: AbstractGraph{T}}</code></pre><p>Overridden inner constructor. Return an <code>Interlayer</code> between <code>layer_1</code> and <code>layer_2</code>, whose underlying graph is <code>graph</code>. All <code>Layer</code>s and <code>Interlayer</code>s of a <code>Multilayer(Di)Graph</code> need to formally have the same vertices, but in real applications it may be that some vertices are excluded from som layers. Such vertices should be specified in <code>forbiddes_vertices</code>. Similarly for <code>forbiddes_edges</code>. This constructor (to which all the other eventually fall back to) will check that <code>forbidden_vertices</code> have no neighbors in <code>graph</code>, and that <code>forbidden_edges</code> actually correspond to zero entries in the adjacency matrix of <code>graph</code>. Also check that it is a proper bipartite graph.</p><pre><code class="language-julia-repl hljs">julia&gt; Interlayer(:interlayer, Set((:layer_1,:layer_2)), SimpleGraph(50,50))
Interlayer{SimpleGraph{Int64}}(:interlayer, Set([:layer_2, :layer_1]), {50, 50} undirected simple Int64 graph)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L17-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{T}, Tuple{Int64, Symbol, Symbol, Symbol, Type{G}, Int64}} where {T&lt;:(Union{AbstractVertex, var&quot;#s14&quot;} where var&quot;#s14&quot;&lt;:Integer), G&lt;:Graphs.AbstractGraph{T}}" href="#MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{T}, Tuple{Int64, Symbol, Symbol, Symbol, Type{G}, Int64}} where {T&lt;:(Union{AbstractVertex, var&quot;#s14&quot;} where var&quot;#s14&quot;&lt;:Integer), G&lt;:Graphs.AbstractGraph{T}}"><code>MultilayerGraphs.Interlayer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Interlayer(nv::Int64, name::Symbol,layer_1::Symbol, layer_2::Symbol, graph_type::Type{G}, ne::Int64, forbidden_vertices::Vector{MultilayerVertex{T}}, forbidden_edges::Vector{NTuple{2, MultilayerVertex{T}}}) where {T &lt;: Union{ &lt;: Integer, AbstractVertex}, G &lt;: AbstractGraph{T}; !IsDirected{G}, IsWeighted{G}}</code></pre><p>Random <code>Interlayer</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>nv::Int64</code>: number of vertices;</li><li><code>name::Symbol</code>: name of the Interlayer;</li><li><code>layer_1::Symbol</code>: The first Layer it connects;</li><li><code>layer_2::Symbol</code>: The second Layer it connects;</li><li><code>graph_type::Type{G}</code>: the underlying graph type;</li><li><code>ne::Int64</code>: the number of edges;</li><li><code>forbidden_vertices::Vector{MultilayerVertex{T}}</code>: list of vertices that are not considered present in the Interlayer;</li><li><code>forbidden_edges::Vector{NTuple{2, MultilayerVertex{T}}}</code>: list of edges whose existence is a priori excluded from the Interlayer.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L144-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Int64, Symbol, Symbol, Symbol, Type{G}, Tuple{Vararg{MultilayerEdge{MultilayerVertex{T}, U}}}}} where {T&lt;:(Union{AbstractVertex, var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:Integer), U&lt;:Real, G&lt;:Graphs.AbstractGraph{T}}" href="#MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Int64, Symbol, Symbol, Symbol, Type{G}, Tuple{Vararg{MultilayerEdge{MultilayerVertex{T}, U}}}}} where {T&lt;:(Union{AbstractVertex, var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:Integer), U&lt;:Real, G&lt;:Graphs.AbstractGraph{T}}"><code>MultilayerGraphs.Interlayer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Interlayer(nv::Int64, name::Symbol,layer_1::Symbol, layer_2::Symbol, graph_type::Type{G}, edge_list::Tuple{Vararg{ &lt;: MultilayerEdge{MultilayerVertex{T},U} }}, forbidden_vertices::Vector{MultilayerVertex{T}}, forbidden_edges::Vector{NTuple{2, MultilayerVertex{T}}}) where {T &lt;: Union{ &lt;: Integer, AbstractVertex}, U &lt;: Real, G &lt;: AbstractGraph{T}; IsWeighted{G}}</code></pre><p>Outer constructor for <code>Interlayer</code>.  Return an <code>Interlayer</code> between <code>layer_1</code> and <code>layer_2</code>, whose underlying graph type is <code>graph_type</code>. Edges are given via an edge list <code>edge_list</code>. All <code>Layer</code>s and <code>Interlayer</code>s of a <code>Multilayer(Di)Graph</code> need to formally have the same vertices, but in real applications it may be that some vertices are excluded from som layers. Such vertices should be specified in <code>forbiddes_vertices</code>. Similarly for <code>forbiddes_edges</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>nv</code>::Int64 : the number of nodes;</li><li><code>name</code>`::Symbol : name of the Interlayer;</li><li><code>layer_1</code>::Symbol: name of one of the Layers connected by this Interlayer;</li><li><code>layer_2</code>::Symbol: name of one of the Layers connected by this Interlayer;</li><li><code>graph_type</code>`::Type{G}: type of the graph underlying the Interlayer;</li><li><code>edge_list</code>::Tuple{Vararg{ &lt;: MultilayerEdge{MultilayerVertex{T},U} }}: edge list for the Interlayer;</li><li><code>forbidden_vertices</code>::Vector{MultilayerVertex{T}}: nodes of the MultilayerGraph that are not part of this Interlayer (they will be formally present in the Interlayer but it will be checked that they aren&#39;t adjacent to any other node);</li><li><code>forbidden_edges</code>::Vector{NTuple{2, MultilayerVertex{T}}}: edges that are required not to exist in this Interlayer.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L98-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.IsWeighted" href="#MultilayerGraphs.IsWeighted"><code>MultilayerGraphs.IsWeighted</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsWeighted{X}</code></pre><p>Trait that discerns between weighted and unweighted graphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/traits.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Layer" href="#MultilayerGraphs.Layer"><code>MultilayerGraphs.Layer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Layer{T &lt;: Integer, U &lt;: Real, G &lt;: AbstractGraph{T}} &lt;: AbstractLayer{T,U,G}</code></pre><p>Represents a layer in a <code>Multilayer(Di)Graph</code>. </p><p><strong>FIELDS</strong></p><ul><li><code>name::Symbol</code>: the name of the layer;</li><li><code>graph::G</code>: underlying graph of the layer;</li><li><code>forbidden_vertices::Vector{MultilayerVertex{T}}</code>: nodes of the MultilayerGraph that are not part of this Layer (they will be formally present in the Layer but it will be checked that they aren&#39;t adjacent to any other node);</li><li><code>forbidden_edges</code>::Vector{NTuple{2, MultilayerVertex{T}}}: edges that are required not to exist in this Layer.</li></ul><p><strong>CONSTRUCTORS</strong></p><pre><code class="nohighlight hljs">Layer(name::Symbol, graph::G, forbidden_vertices::Tuple{Vararg{T}}, forbidden_edges::Tuple{Vararg{NTuple{2, T}}};  U::Union{Type{ &lt;: Real}, Nothing}  = nothing ) where {T,G &lt;: AbstractGraph{T}}</code></pre><p>Overridden inner constructor. Return an <code>Layer</code> whose underlying graph is <code>graph</code>. All <code>Layer</code>s and <code>Layer</code>s of a <code>Multilayer(Di)Graph</code> need to formally have the same nodes, but in real applications it may be that some vertices are excluded from some layers. Such vertices should be specified in <code>forbiddes_vertices</code>. Similarly for <code>forbiddes_edges</code>. This constructor (to which all the other eventually fall back to) will check that <code>forbidden_vertices</code> have no neighbors in <code>graph</code>, and that <code>forbidden_edges</code> actually correspond to zero entries in the adjacency matrix of <code>graph</code>. </p><pre><code class="nohighlight hljs">Layer{T &lt;: Integer, U &lt;: Real, G &lt;: AbstractGraph{T}} &lt;: AbstractLayer{T,U,G}</code></pre><p>Incomplete initialization, used to write type-stable functions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L17-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{Symbol, G}} where G&lt;:Graphs.AbstractGraph" href="#MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{Symbol, G}} where G&lt;:Graphs.AbstractGraph"><code>MultilayerGraphs.Layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Layer(name::Symbol, graph::G; U::Union{Type{ &lt;: Real}, Nothing} = nothing) where {G &lt;: AbstractGraph}</code></pre><p>Return a Layer with name <code>name</code> and graph <code>graph</code> with no forbidden nodes or edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{T}, Tuple{Int64, Symbol, Type{G}, Int64}} where {T&lt;:(Union{AbstractVertex, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:Integer), G&lt;:Graphs.AbstractGraph{T}}" href="#MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{T}, Tuple{Int64, Symbol, Type{G}, Int64}} where {T&lt;:(Union{AbstractVertex, var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:Integer), G&lt;:Graphs.AbstractGraph{T}}"><code>MultilayerGraphs.Layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Layer(nv::Int64, name::Symbol, graph_type::Type{G}, ne::Int64; U::Union{Type{ &lt;: Real},Nothing} = nothing)  where {T &lt;: Union{ &lt;: Integer, AbstractVertex}, G &lt;: AbstractGraph{T}}</code></pre><p>Random <code>Layer</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>nv::Int64</code>: number of vertices;</li><li><code>name::Symbol</code>: name of the layer;</li><li><code>graph_type::Type{G}</code>: the underlying graph type;</li><li><code>ne::Int64</code>: the number of edges;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L115-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerDiGraph" href="#MultilayerGraphs.MultilayerDiGraph"><code>MultilayerGraphs.MultilayerDiGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultilayerDiGraph{T, U} &lt;: AbstractMultilayerDiGraph{T,U}</code></pre><p>A concrete type that can represent a general directed multilayer graph.</p><p><strong>FIELDS</strong></p><ul><li><code>adjacency_tensor::Array{U, 4}</code>: the 4-dimensional tensor that encodes all (weighted) connections within the graph. adjacency_tensor[1,2,3,4] encodes the strength of the (directed or undirected) link between node 1 in layer 3 and node 2 in layer 4.</li><li><code>layers::OrderedDict{ Tuple{Int64,Int64}, Layer{T,U,G}}</code>: the ordered dictionary containing all the layers of the multilayer graph. Their underlying graphs must be all directed.</li><li><code>interlayers::OrderedDict{ Tuple{Int64,Int64}, Interlayer{T,U}}</code>: the ordered dictionary containing all the interlayers of the multilayer graph. Their underlying graphs must be all directed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayerdigraph.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerDiGraph-Tuple{Int64, Int64, Int64, Int64, Vector{DataType}}" href="#MultilayerGraphs.MultilayerDiGraph-Tuple{Int64, Int64, Int64, Int64, Vector{DataType}}"><code>MultilayerGraphs.MultilayerDiGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerDiGraph(num_layers::Int64, n_nodes::Int64, min_edges::Int64, max_edges::Int64, graph_type::Type{&lt;: AbstractGraph})</code></pre><p>Return a random <code>MultilayerDiGraph</code> with <code>num_layers</code> layers, <code>n_nodes</code> nodes and each <code>Layer</code> and <code>Interlayer</code> has a random number of edges between <code>min_edges</code> and <code>max_edges</code>. <code>Layers</code> and <code>Interlayers</code> have parametric type <code>graph_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayerdigraph.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerDiGraph-Tuple{Int64, Type{&lt;:Number}, Type{&lt;:Number}}" href="#MultilayerGraphs.MultilayerDiGraph-Tuple{Int64, Type{&lt;:Number}, Type{&lt;:Number}}"><code>MultilayerGraphs.MultilayerDiGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerDiGraph(n_nodes::Int64, T::Type{ &lt;: Number}, U::Type{ &lt;: Number} )</code></pre><p>Return a MultilayerDiGraph with <code>n_nodes</code> of type <code>T</code> nodes and an adjacency tensor eltype <code>U</code>. Use this constructor and then add Layers and Interlayers via the <code>add_layer!</code> and <code>add_interlayer!</code> methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayerdigraph.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerDiGraph-Union{Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}}}} where {T, U}" href="#MultilayerGraphs.MultilayerDiGraph-Union{Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}}}} where {T, U}"><code>MultilayerGraphs.MultilayerDiGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerDiGraph(layers::Vector{ &lt;: Layer{T,U }}, specified_interlayers::Vector{ &lt;: Interlayer{T,U}};  default_interlayer::String  = &quot;multiplex&quot;) where {T, U}</code></pre><p>Construct a MultilayerDiGraph with layers given by <code>layers</code>. The interlayers will be constructed by default according to <code>default_interlayer</code> (only <code>&quot;multiplex&quot;</code> is allowed), except for those specified in <code>specified_interlayers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayerdigraph.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerDiGraph-Union{Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}}}, Tuple{U}, Tuple{T}} where {T, U}" href="#MultilayerGraphs.MultilayerDiGraph-Union{Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}}}, Tuple{U}, Tuple{T}} where {T, U}"><code>MultilayerGraphs.MultilayerDiGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerDiGraph(layers::Vector{ &lt;: Layer{T,U}};  default_interlayer::String  = &quot;multiplex&quot;) where {T,U}</code></pre><p>Construct a MultilayerDiGraph with layers <code>layers</code> and all interlayers of type <code>default_interlayer</code> (only &quot;multiplex&quot; is allowed).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayerdigraph.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerEdge" href="#MultilayerGraphs.MultilayerEdge"><code>MultilayerGraphs.MultilayerEdge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MultilayerEdge{ T &lt;: MultilayerVertex, U &lt;: Union{ &lt;: Real, Nothing}} &lt;: AbstractMultilayerEdge{T}</code></pre><p>Default concrete subtype of AbstractMultilayerEdge.</p><p><strong>FIELDS</strong></p><ul><li><code>src::T</code>: the source vertex of the edge ;</li><li><code>dst::T</code>: the destination vertex of the edge;</li><li><code>weight::U</code>: the edge weight.</li></ul><p><strong>CONSTRUCTORS</strong></p><pre><code class="nohighlight hljs">MultilayerEdge(src::T, dst::T, weight::U) where { T &lt;: MultilayerVertex, U &lt;: Union{ &lt;: Real, Nothing}}</code></pre><p>Default constructor.</p><pre><code class="nohighlight hljs">MultilayerEdge(src::T, dst::T) where {T &lt;: MultilayerVertex}</code></pre><p>Unweighted edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayeredge.jl#L10-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerGraph" href="#MultilayerGraphs.MultilayerGraph"><code>MultilayerGraphs.MultilayerGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultilayerGraph{T, U, G &lt;: AbstractGraph{T}} &lt;: AbstractMultilayerGraph{T,U}</code></pre><p>A concrete type that can represent a general multilayer graph.</p><p><strong>FIELDS</strong></p><ul><li><code>adjacency_tensor::Array{U, 4}</code>: the 4-dimensional tensor that encodes all (weighted) connections within the graph. adjacency_tensor[1,2,3,4] encodes the strength of the (directed or undirected) link between node 1 in layer 3 and node 2 in layer 4.</li><li><code>layers::OrderedDict{ Tuple{Int64,Int64}, Layer{T,U,G}}</code>: the ordered dictionary containing all the layers of the multilayer graph. Their underlying graphs must be all undirected.</li><li><code>interlayers::OrderedDict{ Tuple{Int64,Int64}, Interlayer{T,U}}</code>: the ordered dictionary containing all the interlayers of the multilayer graph. Their underlying graphs must be all undirected.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayergraph.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerGraph-Tuple{Int64, Int64, Int64, Int64, Vector{DataType}}" href="#MultilayerGraphs.MultilayerGraph-Tuple{Int64, Int64, Int64, Int64, Vector{DataType}}"><code>MultilayerGraphs.MultilayerGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerGraph(num_layers::Int64, n_nodes::Int64, min_edges::Int64, max_edges::Int64, graph_type::Type{&lt;: AbstractGraph})</code></pre><p>Return a random <code>MultilayerGraph</code> with <code>num_layers</code> layers, <code>n_nodes</code> nodes and each <code>Layer</code> and <code>Interlayer</code> has a random number of edges between <code>min_edges</code> and <code>max_edges</code>. <code>Layers</code> and <code>Interlayers</code> have parametric type <code>graph_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayergraph.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerGraph-Tuple{Int64, Type{&lt;:Number}, Type{&lt;:Number}}" href="#MultilayerGraphs.MultilayerGraph-Tuple{Int64, Type{&lt;:Number}, Type{&lt;:Number}}"><code>MultilayerGraphs.MultilayerGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerGraph(n_nodes::Int64, T::Type{ &lt;: Number}, U::Type{ &lt;: Number} )</code></pre><p>Return a MultilayerGraph with <code>n_nodes</code> of type <code>T</code> nodes and an adjacency tensor eltype <code>U</code>. Use this constructor and then add Layers and Interlayers via the <code>add_layer!</code> and <code>add_interlayer!</code> methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayergraph.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerGraph-Union{Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}}}} where {T, U}" href="#MultilayerGraphs.MultilayerGraph-Union{Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}}}} where {T, U}"><code>MultilayerGraphs.MultilayerGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerGraph(layers::Vector{ &lt;: Layer{T,U }}, specified_interlayers::Vector{ &lt;: Interlayer{T,U}};  default_interlayer::String  = &quot;multiplex&quot;) where {T, U}</code></pre><p>Construct a MultilayerDiGraph with layers given by <code>layers</code>. The interlayers will be constructed by default according to <code>default_interlayer</code> (only <code>&quot;multiplex&quot;</code> is allowed), except for those specified in <code>specified_interlayers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayergraph.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerGraph-Union{Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}}}, Tuple{U}, Tuple{T}} where {T, U}" href="#MultilayerGraphs.MultilayerGraph-Union{Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}}}, Tuple{U}, Tuple{T}} where {T, U}"><code>MultilayerGraphs.MultilayerGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerGraph(layers::Vector{ &lt;: Layer{T,U}};  default_interlayer::String  = &quot;multiplex&quot;) where {T,U}</code></pre><p>Construct a MultilayerDiGraph with layers <code>layers</code> and all interlayers of type <code>default_interlayer</code> (only &quot;multiplex&quot; is allowed).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayergraph.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerVertex" href="#MultilayerGraphs.MultilayerVertex"><code>MultilayerGraphs.MultilayerVertex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultilayerVertex{T &lt;: Integer} &lt;: AbstractMultilayerVertex{T}</code></pre><p>A struct representing a vertex of a MultilayerGraph.</p><p><strong>FIELDS</strong></p><ul><li><code>vertex::T</code> : the node that the MultilayerVertex represents;</li><li><code>layer::Symbol</code>:  the layer the MultilayerVertex belongs to.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayervertex.jl#L15-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.δ" href="#MultilayerGraphs.δ"><code>MultilayerGraphs.δ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct δ{T} &lt;: AbstractVector{T}</code></pre><p>The kronecker delta.</p><p><strong>FIELDS</strong></p><ul><li><code>N::Int64</code>: the number of dimensions;</li><li><code>representation::Matrix{Int64}</code>: the matrix representing the kronecker delta;</li><li><code>T</code>: the return type when called ad δ[i,j].</li></ul><p><strong>CONSTRUCTORS</strong></p><pre><code class="nohighlight hljs">δ{T}(N::Int64) where {T &lt;: Number}</code></pre><p>Inner constructor that only requires N and the eltype.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L90-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.δ-Tuple{Int64}" href="#MultilayerGraphs.δ-Tuple{Int64}"><code>MultilayerGraphs.δ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">δ(N::Int64)</code></pre><p>Outer constructor that only requires N</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L121-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.δ_1" href="#MultilayerGraphs.δ_1"><code>MultilayerGraphs.δ_1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct δ_1{T&lt;: Number}</code></pre><p>The δ_1 from <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>. Evaluate it via the notation [i,j].</p><p><strong>FIELDS</strong></p><ul><li><code>N:Int64</code>: the dimensionality of δ_1;</li><li><code>T</code>: the return type.</li></ul><p><strong>CONSTRUCTORS</strong></p><pre><code class="nohighlight hljs">δ_1{T&lt;: Number}(N::Int64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L150-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.δ_2" href="#MultilayerGraphs.δ_2"><code>MultilayerGraphs.δ_2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct δ_2{T&lt;: Number}</code></pre><p>The δ_2 from <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>. Evaluate it via the notation [i,j].</p><p><strong>FIELDS</strong></p><ul><li><code>N:Int64</code>: the dimensionality of δ_2;</li><li><code>T</code>: the return type.</li></ul><p><strong>CONSTRUCTORS</strong></p><pre><code class="nohighlight hljs">δ_2{T&lt;: Number}(N::Int64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L170-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.δ_3" href="#MultilayerGraphs.δ_3"><code>MultilayerGraphs.δ_3</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct δ_3{T&lt;: Number}</code></pre><p>The δ_3 from <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>. Evaluate it via the notation [i,j].</p><p><strong>FIELDS</strong></p><ul><li><code>N:Int64</code>: the dimensionality of δ_3;</li><li><code>T</code>: the return type.</li></ul><p><strong>CONSTRUCTORS</strong></p><pre><code class="nohighlight hljs">δ_3{T&lt;: Number}(N::Int64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L190-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.δ_Ω" href="#MultilayerGraphs.δ_Ω"><code>MultilayerGraphs.δ_Ω</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">δ_Ω{T} &lt;: AbstractVector{T}</code></pre><p>Struct that represents the δ_Ω defined in <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>.</p><p><strong>FIELDS</strong></p><ul><li><code>δ_1::δ_1{T}</code>: Instance of δ_1;</li><li><code>δ_2::δ_2{T}</code>: Instance of δ_2;</li><li><code>δ_3::δ_3{T}</code>: Instance of δ_3;</li><li><code>N::Int64</code>  : Maximum index (number of layers);</li><li><code>representation::Array{Int64,4}</code>: Multidimensional-array representation of δ_Ω.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L210-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimpleWeightedGraphs.SimpleWeightedDiGraph-Tuple{Integer, Integer}" href="#SimpleWeightedGraphs.SimpleWeightedDiGraph-Tuple{Integer, Integer}"><code>SimpleWeightedGraphs.SimpleWeightedDiGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SimpleWeightedDiGraph(n_vertices::Integer, n_edges::Integer; T::Type = Int64, U::Type = Float64)</code></pre><p>Random  SimpleWeightedDiGraph with <code>n_vertices</code> vertices and <code>n_edges</code> edges, vertex type <code>T</code> and adjacency matrix eltype <code>U</code>. Edge weights are uniformly extracted between 0 and 1. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/graphs_extensions.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimpleWeightedGraphs.SimpleWeightedDiGraph-Union{Tuple{T}, Tuple{Integer, Integer}} where T" href="#SimpleWeightedGraphs.SimpleWeightedDiGraph-Union{Tuple{T}, Tuple{Integer, Integer}} where T"><code>SimpleWeightedGraphs.SimpleWeightedDiGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SimpleWeightedGraphs.SimpleWeightedDiGraph{T}(n_vertices::Integer, n_edges::Integer; U::Type = Float64) where {T}</code></pre><p>Random  SimpleWeightedDiGraph with <code>n_vertices</code> vertices and <code>n_edges</code> edges, vertex type <code>T</code> and adjacency matrix eltype <code>U</code>. Edge weights are uniformly extracted between 0 and 1. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/graphs_extensions.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimpleWeightedGraphs.SimpleWeightedDiGraph-Union{Tuple{U}, Tuple{T}, Tuple{Integer, Integer}} where {T, U}" href="#SimpleWeightedGraphs.SimpleWeightedDiGraph-Union{Tuple{U}, Tuple{T}, Tuple{Integer, Integer}} where {T, U}"><code>SimpleWeightedGraphs.SimpleWeightedDiGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SimpleWeightedDiGraph{T,U}(n_vertices::Integer, n_edges::Integer)</code></pre><p>Random  SimpleWeightedDiGraph with <code>n_vertices</code> vertices and <code>n_edges</code> edges, vertex type <code>T</code> and adjacency matrix eltype <code>U</code>. Edge weights are uniformly extracted between 0 and 1. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/graphs_extensions.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimpleWeightedGraphs.SimpleWeightedGraph-Tuple{Integer, Integer}" href="#SimpleWeightedGraphs.SimpleWeightedGraph-Tuple{Integer, Integer}"><code>SimpleWeightedGraphs.SimpleWeightedGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SimpleWeightedGraph(n_vertices::Integer, n_edges::Integer; T::Type = Int64, U::Type = Float64)</code></pre><p>Random  SimpleWeightedGraph with <code>n_vertices</code> vertices and <code>n_edges</code> edges, vertex type <code>T</code> and adjacency matrix eltype <code>U</code>. Edge weights are uniformly extracted between 0 and 1. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/graphs_extensions.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimpleWeightedGraphs.SimpleWeightedGraph-Union{Tuple{T}, Tuple{Integer, Integer}} where T" href="#SimpleWeightedGraphs.SimpleWeightedGraph-Union{Tuple{T}, Tuple{Integer, Integer}} where T"><code>SimpleWeightedGraphs.SimpleWeightedGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SimpleWeightedGraph{T}(n_vertices::Integer, n_edges::Integer; U::Type = Float64) where { T }</code></pre><p>Random  SimpleWeightedGraph with <code>n_vertices</code> vertices and <code>n_edges</code> edges, vertex type <code>T</code> and adjacency matrix eltype <code>U</code>. Edge weights are uniformly extracted between 0 and 1. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/graphs_extensions.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimpleWeightedGraphs.SimpleWeightedGraph-Union{Tuple{U}, Tuple{T}, Tuple{Integer, Integer}} where {T, U}" href="#SimpleWeightedGraphs.SimpleWeightedGraph-Union{Tuple{U}, Tuple{T}, Tuple{Integer, Integer}} where {T, U}"><code>SimpleWeightedGraphs.SimpleWeightedGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SimpleWeightedGraph{T,U}(n_vertices::Integer, n_edges::Integer) where { T, U }</code></pre><p>Random  SimpleWeightedGraph with <code>n_vertices</code> vertices and <code>n_edges</code> edges, vertex type <code>T</code> and adjacency matrix eltype <code>U</code>. Edge weights are uniformly extracted between 0 and 1. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/graphs_extensions.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{AbstractMultilayerGraph, AbstractMultilayerGraph}" href="#Base.:==-Tuple{AbstractMultilayerGraph, AbstractMultilayerGraph}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.(==)(x::AbstractMultilayerGraph, y::AbstractMultilayerGraph)</code></pre><p>Overload equality for <code>AbstractMultilayerGraph</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{Interlayer, Interlayer}" href="#Base.:==-Tuple{Interlayer, Interlayer}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.(==)(x::Interlayer, y::Interlayer)</code></pre><p>Overload equality for <code>Interlayer</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L384-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{Layer, Layer}" href="#Base.:==-Tuple{Layer, Layer}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.(==)(x::Layer, y::Layer)</code></pre><p>Overload equality for <code>Layer</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L319-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Tuple{In} where In&lt;:Interlayer" href="#Base.eltype-Tuple{In} where In&lt;:Interlayer"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.eltype(interlayer::In) where { In &lt;: Interlayer}</code></pre><p>Return the vertex type of <code>interlayer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L219-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Tuple{L} where L&lt;:Layer" href="#Base.eltype-Tuple{L} where L&lt;:Layer"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.eltype(layer::L) where { L &lt;: Layer}</code></pre><p>Return the vertex type of <code>layer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}" href="#Base.eltype-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.eltype(mg::M) where {M &lt;: AbstractMultilayerGraph}</code></pre><p>Return the vertex type of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L199-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Union{Tuple{O}, Tuple{O, Int64}} where O&lt;:OrderedCollections.OrderedDict" href="#Base.getindex-Union{Tuple{O}, Tuple{O, Int64}} where O&lt;:OrderedCollections.OrderedDict"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(od::O, key::Int64) where {O &lt;: OrderedDict}</code></pre><p>Return the <code>key</code>th pair of <code>od</code>, following <code>od</code>&#39;s order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Union{Tuple{T}, Tuple{MultilayerGraphs.δ{T}, Int64}} where T" href="#Base.getindex-Union{Tuple{T}, Tuple{MultilayerGraphs.δ{T}, Int64}} where T"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(d::δ{T}, i::Int) where T</code></pre><p>The getindex called by OMEinsum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L135-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getproperty-Union{Tuple{In}, Tuple{In, Symbol}} where In&lt;:Interlayer" href="#Base.getproperty-Union{Tuple{In}, Tuple{In, Symbol}} where In&lt;:Interlayer"><code>Base.getproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.getproperty(interlayer::In, f::Symbol) where { In &lt;: Interlayer}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L399-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getproperty-Union{Tuple{L}, Tuple{L, Symbol}} where L&lt;:Layer" href="#Base.getproperty-Union{Tuple{L}, Tuple{L, Symbol}} where L&lt;:Layer"><code>Base.getproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.getproperty(layer::L, f::Symbol) where { L &lt;: layer}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L333-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getproperty-Union{Tuple{M}, Tuple{M, Symbol}} where M&lt;:AbstractMultilayerGraph" href="#Base.getproperty-Union{Tuple{M}, Tuple{M, Symbol}} where M&lt;:AbstractMultilayerGraph"><code>Base.getproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.getproperty(mg::M, f::Symbol) where { M &lt;: AbstractMultilayerGraph }</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L8-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{MultilayerGraphs.δ}" href="#Base.size-Tuple{MultilayerGraphs.δ}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size(d::δ)</code></pre><p>Override required by OMEinsum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.LinAlg.adjacency_matrix-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, In&lt;:Interlayer{T, U, G}}" href="#Graphs.LinAlg.adjacency_matrix-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, In&lt;:Interlayer{T, U, G}}"><code>Graphs.LinAlg.adjacency_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adjacency_matrix(interlayer::In) where { T,U, G &lt;: AbstractGraph{T}, In &lt;:Interlayer{T,U,G}}</code></pre><p>Return the adjacency matrix of <code>interlayer.graph</code>, with the eltype converted to <code>U</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L311-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.LinAlg.adjacency_matrix-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}}" href="#Graphs.LinAlg.adjacency_matrix-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}}"><code>Graphs.LinAlg.adjacency_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adjacency_matrix(layer::L) where { T,U, G &lt;: AbstractGraph{T}, L &lt;:Layer{T,U,G}}</code></pre><p>Return the adjacency matrix of <code>layer.graph</code>, with the eltype converted to <code>U</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L311-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, E}} where {T, U, G, In&lt;:Interlayer{T, U, G}, E&lt;:MultilayerEdge{MultilayerVertex{T}, Nothing}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, E}} where {T, U, G, In&lt;:Interlayer{T, U, G}, E&lt;:MultilayerEdge{MultilayerVertex{T}, Nothing}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(interlayer::In, me::E) where {T,U,G, In &lt;: Interlayer{T,U,G}, E &lt;: MultilayerEdge{MultilayerVertex{T},Nothing}}</code></pre><p>Add unweighted edge <code>me</code> to <code>interlayer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L358-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, E}} where {T, U&lt;:Real, G, In&lt;:Interlayer{T, U, G}, E&lt;:MultilayerEdge{MultilayerVertex{T}, U}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, E}} where {T, U&lt;:Real, G, In&lt;:Interlayer{T, U, G}, E&lt;:MultilayerEdge{MultilayerVertex{T}, U}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(interlayer::In, me::E) where {T,U &lt;: Real,G, In &lt;: Interlayer{T,U,G}, E &lt;: MultilayerEdge{MultilayerVertex{T},U}}</code></pre><p>Add unweighted edge <code>me</code> to <code>interlayer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L351-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, E}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}, E&lt;:MultilayerEdge{MultilayerVertex{T}, Nothing}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, E}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}, E&lt;:MultilayerEdge{MultilayerVertex{T}, Nothing}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(layer::L, me::E) where {T,U,G&lt;: AbstractGraph{T}, L &lt;: Layer{T,U,G}, E &lt;: MultilayerEdge{MultilayerVertex{T},Nothing}; !IsWeighted{G}}</code></pre><p>Add unweighted edge <code>me</code> to <code>layer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L288-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, E}} where {T, U&lt;:Real, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}, E&lt;:MultilayerEdge{MultilayerVertex{T}, U}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, E}} where {T, U&lt;:Real, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}, E&lt;:MultilayerEdge{MultilayerVertex{T}, U}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(layer::L, me::E) where {T,U &lt;: Real,G &lt;: AbstractGraph{T} , L &lt;: Layer{T,U,G}, E &lt;: MultilayerEdge{MultilayerVertex{T},U}; IsWeighted{G}}</code></pre><p>Add unweighted edge <code>me</code> to <code>layer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L281-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U, M&lt;:MultilayerDiGraph{T, U}, E&lt;:MultilayerEdge{MultilayerVertex{T}, Nothing}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U, M&lt;:MultilayerDiGraph{T, U}, E&lt;:MultilayerEdge{MultilayerVertex{T}, Nothing}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(mg::M, me::E) where { T, U, M &lt;: MultilayerDiGraph{T,U}, E &lt;: MultilayerEdge{MultilayerVertex{T},Nothing}}</code></pre><p>Add unweighted edge <code>me</code> to <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayerdigraph.jl#L242-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U, M&lt;:MultilayerGraph{T, U}, E&lt;:MultilayerEdge{MultilayerVertex{T}, Nothing}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U, M&lt;:MultilayerGraph{T, U}, E&lt;:MultilayerEdge{MultilayerVertex{T}, Nothing}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(mg::M, me::E) where { T, U, M &lt;: MultilayerGraph{T,U}, E &lt;: MultilayerEdge{MultilayerVertex{T},Nothing}}</code></pre><p>Add unweighted edge <code>me</code> to <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayergraph.jl#L240-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U&lt;:Real, M&lt;:MultilayerDiGraph{T, U}, E&lt;:MultilayerEdge{MultilayerVertex{T}, U}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U&lt;:Real, M&lt;:MultilayerDiGraph{T, U}, E&lt;:MultilayerEdge{MultilayerVertex{T}, U}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(mg::M, me::E) where { T, U &lt;: Real, M &lt;: MultilayerDiGraph{T,U}, E &lt;: MultilayerEdge{MultilayerVertex{T},U}}</code></pre><p>Add weighted edge <code>me</code> to <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayerdigraph.jl#L235-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U&lt;:Real, M&lt;:MultilayerGraph{T, U}, E&lt;:MultilayerEdge{MultilayerVertex{T}, U}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U&lt;:Real, M&lt;:MultilayerGraph{T, U}, E&lt;:MultilayerEdge{MultilayerVertex{T}, U}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(mg::M, me::E) where { T, U &lt;: Real, M &lt;: MultilayerGraph{T,U}, E &lt;: MultilayerEdge{MultilayerVertex{T},U}}</code></pre><p>Add weighted edge <code>me</code> to <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayergraph.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{IsWeighted{G}}, In, V, V, U}} where {T, U&lt;:Real, G&lt;:Graphs.AbstractGraph{T}, In&lt;:Interlayer{T, U, G}, V&lt;:MultilayerVertex{T}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{IsWeighted{G}}, In, V, V, U}} where {T, U&lt;:Real, G&lt;:Graphs.AbstractGraph{T}, In&lt;:Interlayer{T, U, G}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(interlayer::In,src::V, dst::V, weight::U) where { T, U &lt;: Real, G &lt;: AbstractGraph{T}, In &lt;: Interlayer{T,U,G}, V &lt;: MultilayerVertex{T}; IsWeighted{G}}</code></pre><p>Add edge from <code>src</code> to <code>dst</code> with weight <code>weight</code> to <code>interlayer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L318-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{SimpleTraits.Not{IsWeighted{G}}}, In, V, V}} where {T, U&lt;:Real, G&lt;:Graphs.AbstractGraph{T}, In&lt;:Interlayer{T, U, G}, V&lt;:MultilayerVertex{T}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{SimpleTraits.Not{IsWeighted{G}}}, In, V, V}} where {T, U&lt;:Real, G&lt;:Graphs.AbstractGraph{T}, In&lt;:Interlayer{T, U, G}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(interlayer::In,src::V, dst::V) where { T, U &lt;: Real, G &lt;: AbstractGraph{T}, In &lt;: Interlayer{T,U,G}, V &lt;: MultilayerVertex{T}; !IsWeighted{G}}</code></pre><p>Add edge from <code>src</code> to <code>dst</code> with weight <code>weight</code> to <code>interlayer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L333-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{IsWeighted{G}}, L, V, V, U}} where {T, U&lt;:Real, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}, V&lt;:MultilayerVertex{T}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{IsWeighted{G}}, L, V, V, U}} where {T, U&lt;:Real, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(layer::L,src::V, dst::V, weight::U) where { T, U &lt;: Real, G &lt;: AbstractGraph{T}, L &lt;: Layer{T,U,G}, V &lt;: MultilayerVertex{T}; IsWeighted{G}}</code></pre><p>Add edge from <code>src</code> to <code>dst</code> with weight <code>weight</code> to <code>layer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L249-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{SimpleTraits.Not{IsWeighted{G}}}, L, V, V}} where {T, U&lt;:Real, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}, V&lt;:MultilayerVertex{T}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{SimpleTraits.Not{IsWeighted{G}}}, L, V, V}} where {T, U&lt;:Real, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(layer::L, src::V, dst::V) where { T, U &lt;: Real, G &lt;: AbstractGraph{T}, L &lt;: Layer{T,U,G}, V &lt;: MultilayerVertex{T}; !IsWeighted{G}}</code></pre><p>Add edge from <code>src</code> to <code>dst</code> with weight <code>weight</code> to <code>layer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L266-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V, U}} where {T, U&lt;:Real, M&lt;:MultilayerDiGraph{T, U}, V&lt;:MultilayerVertex{T}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V, U}} where {T, U&lt;:Real, M&lt;:MultilayerDiGraph{T, U}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(mg::M, src::V, dst::V, weight::U) where { T, U &lt;: Real, M &lt;: MultilayerDiGraph{T,U}, V &lt;: MultilayerVertex{T}}</code></pre><p>Add edge from <code>src</code> to <code>dst</code> with weight <code>weight</code> to <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayerdigraph.jl#L144-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V, U}} where {T, U&lt;:Real, M&lt;:MultilayerGraph{T, U}, V&lt;:MultilayerVertex{T}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V, U}} where {T, U&lt;:Real, M&lt;:MultilayerGraph{T, U}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(mg::M, src::V, dst::V, weight::U) where { T, U &lt;: Real, M &lt;: MultilayerGraph{T,U}, V &lt;: MultilayerVertex{T}}</code></pre><p>Add edge from <code>src</code> to <code>dst</code> with weight <code>weight</code> to <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayergraph.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U&lt;:Real, M&lt;:MultilayerDiGraph{T, U}, V&lt;:MultilayerVertex{T}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U&lt;:Real, M&lt;:MultilayerDiGraph{T, U}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(mg::M, src::V, dst::V, weight::U) where { T, U &lt;: Real, M &lt;: MultilayerDiGraph{T,U}, V &lt;: MultilayerVertex{T}}</code></pre><p>Add edge from <code>src</code> to <code>dst</code> with weight <code>one(T)</code> to <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayerdigraph.jl#L190-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U&lt;:Real, M&lt;:MultilayerGraph{T, U}, V&lt;:MultilayerVertex{T}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U&lt;:Real, M&lt;:MultilayerGraph{T, U}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(mg::M, src::V, dst::V, weight::U) where { T, U &lt;: Real, M &lt;: MultilayerGraph{T,U}, V &lt;: MultilayerVertex{T}}</code></pre><p>Add edge from <code>src</code> to <code>dst</code> with weight <code>one(U)</code> to <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayergraph.jl#L188-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.rem_edge!-Union{Tuple{V}, Tuple{In}, Tuple{U}, Tuple{T}, Tuple{In, V, V}} where {T, U, In&lt;:(Interlayer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}), V&lt;:MultilayerVertex{T}}" href="#Graphs.SimpleGraphs.rem_edge!-Union{Tuple{V}, Tuple{In}, Tuple{U}, Tuple{T}, Tuple{In, V, V}} where {T, U, In&lt;:(Interlayer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}), V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.rem_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_edge!(interlayer::In, src::V, dst::V) where { T, U, In &lt;: Interlayer{T,U}, V &lt;: MultilayerVertex{T}}</code></pre><p>Remove edge from <code>src</code> to <code>dst</code> in <code>interlayer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L365-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.rem_edge!-Union{Tuple{V}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, V, V}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}, V&lt;:MultilayerVertex{T}}" href="#Graphs.SimpleGraphs.rem_edge!-Union{Tuple{V}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, V, V}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.rem_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_edge!(layer::L, src::V, dst::V) where { T, U, G&lt;: AbstractGraph{T}, L &lt;:Layer{T,U,G}, V &lt;: MultilayerVertex{T}}</code></pre><p>Remove edge from <code>src</code> to <code>dst</code> in <code>layer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L295-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.rem_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U, M&lt;:MultilayerDiGraph{T, U}, V&lt;:MultilayerVertex{T}}" href="#Graphs.SimpleGraphs.rem_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U, M&lt;:MultilayerDiGraph{T, U}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.rem_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_edge!(mg::M, src::V, dst::V) where { T, U, M &lt;: MultilayerDiGraph{T,U}, V &lt;: MultilayerVertex{T}}</code></pre><p>Remove edge from <code>src</code> to <code>dst</code> in <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayerdigraph.jl#L249-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.rem_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U, M&lt;:MultilayerGraph{T, U}, V&lt;:MultilayerVertex{T}}" href="#Graphs.SimpleGraphs.rem_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U, M&lt;:MultilayerGraph{T, U}, V&lt;:MultilayerVertex{T}}"><code>Graphs.SimpleGraphs.rem_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_edge!(mg::M, V1::V, V2::V) where { T, U, M &lt;: MultilayerGraph{T,U}, V &lt;: MultilayerVertex{T}}</code></pre><p>Remove edge from <code>src</code> to <code>dst</code> in <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayergraph.jl#L248-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.dst-Tuple{AbstractMultilayerEdge}" href="#Graphs.dst-Tuple{AbstractMultilayerEdge}"><code>Graphs.dst</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dst(e::AbstractMultilayerEdge)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayeredge.jl#L45-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.edges-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, In&lt;:Interlayer{T, U, G}}" href="#Graphs.edges-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, In&lt;:Interlayer{T, U, G}}"><code>Graphs.edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Graphs.edges(interlayer::In) where {T,U,G &lt;: AbstractGraph{T}, In &lt;: Interlayer{T,U,G}}</code></pre><p>Return an iterator over all the edges of <code>interlayer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.edges-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}}" href="#Graphs.edges-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}}"><code>Graphs.edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Graphs.edges(layer::L) where {T,U,G &lt;: AbstractGraph{T}, L &lt;: Layer{T,U,G}}</code></pre><p>Return an iterator over all the edges of <code>layer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.edges-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}" href="#Graphs.edges-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>Graphs.edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edges(mg::M) where {M &lt;: AbstractMultilayerDiGraph}</code></pre><p>Return an iterator over all the edges of <code>mg</code>. The iterators first loops over all layers&#39; edges (in the order they are given in <code>mg.layers</code>), then over all interlayers&#39; edges (in the order they are given in <code>mg.interlayers</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L180-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.edgetype-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, In&lt;:Interlayer{T, U, G}}" href="#Graphs.edgetype-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>Graphs.edgetype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edgetype(interlayer::In) where {T,U,G,In &lt;: Interlayer{T,U,G} }</code></pre><p>Return the edge type for <code>interlayer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L226-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.edgetype-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, L&lt;:Layer{T, U, G}}" href="#Graphs.edgetype-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, L&lt;:Layer{T, U, G}}"><code>Graphs.edgetype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edgetype(layer::L) where {T,U,G,L &lt;: Layer{T,U,G} }</code></pre><p>Return the edge type for <code>layer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.edgetype-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}" href="#Graphs.edgetype-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>Graphs.edgetype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edgetype(mg::M) where {M &lt;: AbstractMultilayerGraph}</code></pre><p>Return the edge type for <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L213-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.eigenvector_centrality-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}" href="#Graphs.eigenvector_centrality-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>Graphs.eigenvector_centrality</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eigenvector_centrality(mg::M; norm::String = &quot;1&quot;, tol::Float64 = 1e-6, maxiter::Int64 = 2000) where {T, U, M &lt;: AbstractMultilayerGraph{T, U}}</code></pre><p>Calculate the eigenvector centrality of <code>mg</code> via an iterative algorithm. The <code>norm</code> parameter may be <code>&quot;1&quot;</code> or <code>&quot;n&quot;</code>,  and respectively the eigenvector centrality will be normalized to 1 or further divided by the number of nodes of <code>mg</code>. The <code>tol</code> parameter terminates the approximation when two consecutive iteration differ by no more than  <code>tol</code>. The <code>maxiters</code> parameter terminates the algorithm when it goes beyond <code>maxiters</code> iterations.</p><p>The returned values are: the eigenvector centrality and the relative error at each algorithm iteration, that is, the summed absolute values of the componentwise differences between the centrality computed at the current iteration minus the centrality computed at the previous iteration.</p><p>Note: in the limit case of a monoplex graph, this function outputs a eigenvector centrality vector that is a multiple of the one outputted by Graphs.jl&#39;s <code>eigenvector_centrality</code>. It is currently under investigation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L489-L498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_edge-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}" href="#Graphs.has_edge-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_edge(interlayer::In, s::MultilayerVertex{T}, d::MultilayerVertex{T}) where { T,U,G, In &lt;: Interlayer{T,U,G}}</code></pre><p>Return <code>true</code> if there is an edge between <code>s</code> and <code>d</code>, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_edge-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{Graphs.IsDirected{G}}, In, MultilayerVertex{T}, MultilayerVertex{T}, U}} where {T, U, G, In&lt;:Interlayer{T, U, G}}" href="#Graphs.has_edge-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{Graphs.IsDirected{G}}, In, MultilayerVertex{T}, MultilayerVertex{T}, U}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_edge(interlayer::In,  s::MultilayerVertex{T}, d::MultilayerVertex{T}, weight::U) where { T,U,G, In &lt;: Interlayer{T,U,G}; IsDirected{G}</code></pre><p>Return <code>true</code> if there is an edge between <code>s</code> and <code>d</code> with weight <code>weight</code>, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L240-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_edge-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{SimpleTraits.Not{Graphs.IsDirected{G}}}, In, MultilayerVertex{T}, MultilayerVertex{T}, U}} where {T, U, G, In&lt;:Interlayer{T, U, G}}" href="#Graphs.has_edge-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{SimpleTraits.Not{Graphs.IsDirected{G}}}, In, MultilayerVertex{T}, MultilayerVertex{T}, U}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_edge(interlayer::In,  s::MultilayerVertex{T}, d::MultilayerVertex{T}, weight::U) where { T,U,G, In &lt;: Interlayer{T,U,G}; !IsDirected{G}}

Return `true` if there is an edge between `s` and `d` with weight `weight`, `false` otherwise.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L247-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_edge-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, MultilayerVertex{T}, MultilayerVertex{T}}} where {T, U, G, L&lt;:Layer{T, U, G}}" href="#Graphs.has_edge-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, MultilayerVertex{T}, MultilayerVertex{T}}} where {T, U, G, L&lt;:Layer{T, U, G}}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_edge(layer::L, s::MultilayerVertex{T}, d::MultilayerVertex{T}) where { T,U,G, L &lt;: Layer{T,U,G}}</code></pre><p>Return <code>true</code> if there is an edge between <code>s</code> and <code>d</code>, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_edge-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{Graphs.IsDirected{G}}, L, MultilayerVertex{T}, MultilayerVertex{T}, U}} where {T, U, G, L&lt;:Layer{T, U, G}}" href="#Graphs.has_edge-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{Graphs.IsDirected{G}}, L, MultilayerVertex{T}, MultilayerVertex{T}, U}} where {T, U, G, L&lt;:Layer{T, U, G}}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_edge(layer::L,  s::MultilayerVertex{T}, d::MultilayerVertex{T}, weight::U) where { T,U,G, L &lt;: Layer{T,U,G}; IsDirected{G}}</code></pre><p>Return <code>true</code> if there is an edge between <code>s</code> and <code>d</code> with weight <code>weight</code>, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_edge-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{SimpleTraits.Not{Graphs.IsDirected{G}}}, L, MultilayerVertex{T}, MultilayerVertex{T}, U}} where {T, U, G, L&lt;:Layer{T, U, G}}" href="#Graphs.has_edge-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{SimpleTraits.Not{Graphs.IsDirected{G}}}, L, MultilayerVertex{T}, MultilayerVertex{T}, U}} where {T, U, G, L&lt;:Layer{T, U, G}}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_edge(layer::L,  s::MultilayerVertex{T}, d::MultilayerVertex{T}, weight::U) where { T,U,G, L &lt;: Layer{T,U,G}; IsDirected{G}}</code></pre><p>Return <code>true</code> if there is an edge between <code>s</code> and <code>d</code> with weight <code>weight</code>, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L185-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_edge-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}, V&lt;:MultilayerVertex{T}}" href="#Graphs.has_edge-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}, V&lt;:MultilayerVertex{T}}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_edge(mg::M,s::T,d::T) where {M &lt;: AbstractMultilayerGraph{T} } where { T &lt;: Integer}</code></pre><p>Return <code>true</code> if there is an edge between <code>s</code> and <code>d</code>, <code>false</code> otherwise. In case <code>s</code> and <code>d</code> belong to two different layers, but the link is found only in one of the two corresponding interlayers between them, throws an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L220-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_vertex-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}" href="#Graphs.has_vertex-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>Graphs.has_vertex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_vertex(interlayer::In, v::MultilayerVertex{T}) where { T,U,G, In &lt;: Interlayer{T,U,G}}</code></pre><p>Return <code>true</code> if <code>v</code> is a vertex of <code>interlayer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L255-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_vertex-Union{Tuple{L}, Tuple{L, Integer}} where L&lt;:Layer" href="#Graphs.has_vertex-Union{Tuple{L}, Tuple{L, Integer}} where L&lt;:Layer"><code>Graphs.has_vertex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_vertex(layer::L, v::Integer) where { L &lt;: Layer}</code></pre><p>Return <code>true</code> if <code>v</code> is a vertex of <code>layer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L192-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_vertex-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, V}} where {T, M&lt;:(AbstractMultilayerGraph{T}), V&lt;:MultilayerVertex{T}}" href="#Graphs.has_vertex-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, V}} where {T, M&lt;:(AbstractMultilayerGraph{T}), V&lt;:MultilayerVertex{T}}"><code>Graphs.has_vertex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_vertex(mg::M, v::T) where {M &lt;: AbstractMultilayerGraph{T} } where { T &lt;: Integer}</code></pre><p>Return <code>true</code> if <code>v</code> is a vertex of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L243-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.inneighbors-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}" href="#Graphs.inneighbors-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>Graphs.inneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inneighbors(interlayer::In, mv::MultilayerVertex{T}) where {T,U,G, In &lt;: Interlayer{T,U,G}}</code></pre><p>Return the list of inneighbors of <code>v</code> within <code>interlayer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L262-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.inneighbors-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, MultilayerVertex{T}}} where {T, U, G, L&lt;:Layer{T, U, G}}" href="#Graphs.inneighbors-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, MultilayerVertex{T}}} where {T, U, G, L&lt;:Layer{T, U, G}}"><code>Graphs.inneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inneighbors(layer::L, mv::MultilayerVertex{T}) where {T,U,G, L &lt;: Layer{T,U,G}}</code></pre><p>Return the list of inneighbors of <code>v</code> within <code>layer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L199-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.inneighbors-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, V}} where {T, M&lt;:(AbstractMultilayerGraph{T}), V&lt;:MultilayerVertex{T}}" href="#Graphs.inneighbors-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, V}} where {T, M&lt;:(AbstractMultilayerGraph{T}), V&lt;:MultilayerVertex{T}}"><code>Graphs.inneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inneighbors(mg::M, v::T) where {M &lt;: AbstractMultilayerGraph{T} } where { T &lt;: Integer}</code></pre><p>Return the list of inneighbors of <code>v</code> within <code>mg</code>, looping first over all layers (in the order they are given in <code>mg.layers</code>), then over all interlayers (in the order they are given in <code>mg.interlayers</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L254-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_directed-Tuple{In} where In&lt;:Interlayer" href="#Graphs.is_directed-Tuple{In} where In&lt;:Interlayer"><code>Graphs.is_directed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_directed(interlayer::In) where { In &lt;: Interlayer}</code></pre><p>Returns <code>true</code> if <code>interlayer</code> is directed, <code>false</code> otherwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L297-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_directed-Tuple{L} where L&lt;:Layer" href="#Graphs.is_directed-Tuple{L} where L&lt;:Layer"><code>Graphs.is_directed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_directed(layer::L) where { L &lt;: Layer}</code></pre><p>Returns <code>true</code> if <code>layer</code> is directed, <code>false</code> otherwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L235-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_directed-Tuple{M} where M&lt;:(Type{&lt;:MultilayerDiGraph})" href="#Graphs.is_directed-Tuple{M} where M&lt;:(Type{&lt;:MultilayerDiGraph})"><code>Graphs.is_directed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_directed(mg::M) where { M &lt;: Type{ &lt;: MultilayerDiGraph}}</code></pre><p>Returns <code>true</code> if <code>mg</code> is directed, <code>false</code> otherwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayerdigraph.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_directed-Tuple{M} where M&lt;:(Type{&lt;:MultilayerGraph})" href="#Graphs.is_directed-Tuple{M} where M&lt;:(Type{&lt;:MultilayerGraph})"><code>Graphs.is_directed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_directed(m::M) where { M &lt;: Type{ &lt;: MultilayerGraph}}</code></pre><p>Returns <code>true</code> if <code>m</code> is directed, <code>false</code> otherwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayergraph.jl#L303-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_directed-Tuple{M} where M&lt;:MultilayerDiGraph" href="#Graphs.is_directed-Tuple{M} where M&lt;:MultilayerDiGraph"><code>Graphs.is_directed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_directed(mg::M) where { M &lt;: MultilayerDiGraph}</code></pre><p>Returns <code>true</code> if <code>mg</code> is directed, <code>false</code> otherwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayerdigraph.jl#L294-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_directed-Tuple{M} where M&lt;:MultilayerGraph" href="#Graphs.is_directed-Tuple{M} where M&lt;:MultilayerGraph"><code>Graphs.is_directed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_directed(m::M) where { M &lt;: MultilayerGraph}</code></pre><p>Returns <code>true</code> if <code>m</code> is directed, <code>false</code> otherwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayergraph.jl#L296-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_directed-Union{Tuple{Type{In}}, Tuple{In}} where In&lt;:Interlayer" href="#Graphs.is_directed-Union{Tuple{Type{In}}, Tuple{In}} where In&lt;:Interlayer"><code>Graphs.is_directed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_directed(interlayer_type::Type{In}) where {In &lt;: Interlayer}</code></pre><p>Returns <code>true</code> if <code>interlayer_type</code> is directed, <code>false</code> otherwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L304-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_directed-Union{Tuple{Type{L}}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, L&lt;:Layer{T, U, G}}" href="#Graphs.is_directed-Union{Tuple{Type{L}}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, L&lt;:Layer{T, U, G}}"><code>Graphs.is_directed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_directed(::Type{L}) where {T,U,G,L &lt;: Layer{T,U,G}}</code></pre><p>Returns <code>true</code> if <code>layer_type</code> is directed, <code>false</code> otherwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L242-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.modularity-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, Matrix{Int64}}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}" href="#Graphs.modularity-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, Matrix{Int64}}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>Graphs.modularity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modularity(mg::M, c::Matrix{Int64}; null_model::Union{String,Array{U,4}} = &quot;degree&quot;) where {T, U, M &lt;: AbstractMultilayerGraph{T,U}}</code></pre><p>Calculate the modularity of <code>mg</code>, as shown in <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L541-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.ne-Tuple{In} where In&lt;:Interlayer" href="#Graphs.ne-Tuple{In} where In&lt;:Interlayer"><code>Graphs.ne</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ne(interlayer::In) where { In &lt;: Interlayer}</code></pre><p>Return the number of edges in <code>interlayer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L269-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.ne-Tuple{L} where L&lt;:Layer" href="#Graphs.ne-Tuple{L} where L&lt;:Layer"><code>Graphs.ne</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ne(layer::L) where { L &lt;: Layer}</code></pre><p>Return the number of edges in <code>layer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L206-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.ne-Tuple{M} where M&lt;:AbstractMultilayerGraph" href="#Graphs.ne-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>Graphs.ne</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ne(mg::M) where {M &lt;: AbstractMultilayerGraph }</code></pre><p>Return the number of edges in <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L274-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.nv-Tuple{In} where In&lt;:Interlayer" href="#Graphs.nv-Tuple{In} where In&lt;:Interlayer"><code>Graphs.nv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nv(interlayer::In) where { In &lt;: Interlayer}</code></pre><p>Return the number of vertices in <code>interlayer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L276-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.nv-Tuple{L} where L&lt;:Layer" href="#Graphs.nv-Tuple{L} where L&lt;:Layer"><code>Graphs.nv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nv(layer::L) where { L &lt;: Layer}</code></pre><p>Return the number of vertices in <code>layer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L213-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.nv-Tuple{M} where M&lt;:AbstractMultilayerGraph" href="#Graphs.nv-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>Graphs.nv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nv(mg::M) where {M &lt;: AbstractMultilayerGraph }</code></pre><p>Return the number of vertices in <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L299-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.outneighbors-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}" href="#Graphs.outneighbors-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>Graphs.outneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outneighbors(interlayer::In, v::T) where {In &lt;: Interlayer{T} } where { T &lt;: Integer}</code></pre><p>Return the list of outneighbors of <code>v</code> within <code>interlayer</code>, looping first over all layers (in the order they are given in <code>interlayer.layers</code>), then over all interlayers (in the order they are given in <code>interlayer.interlayers</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L283-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.outneighbors-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, MultilayerVertex{T}}} where {T, U, G, L&lt;:Layer{T, U, G}}" href="#Graphs.outneighbors-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, MultilayerVertex{T}}} where {T, U, G, L&lt;:Layer{T, U, G}}"><code>Graphs.outneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outneighbors(layer::L, mv::MultilayerVertex{T}) where {T,U,G, L &lt;: Layer{T,U,G}} =</code></pre><p>Return the list of outneighbors of <code>v</code> within <code>layer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L221-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.outneighbors-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, V}} where {T, M&lt;:(AbstractMultilayerGraph{T}), V&lt;:MultilayerVertex{T}}" href="#Graphs.outneighbors-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, V}} where {T, M&lt;:(AbstractMultilayerGraph{T}), V&lt;:MultilayerVertex{T}}"><code>Graphs.outneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outneighbors(mg::M, v::T) where {M &lt;: AbstractMultilayerGraph{T} } where { T &lt;: Integer}</code></pre><p>Return the list of outneighbors of <code>v</code> within <code>mg</code>, looping first over all layers (in the order they are given in <code>mg.layers</code>), then over all interlayers (in the order they are given in <code>mg.interlayers</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L334-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.vertices-Tuple{In} where In&lt;:Interlayer" href="#Graphs.vertices-Tuple{In} where In&lt;:Interlayer"><code>Graphs.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertices(interlayer::In) where {In &lt;: Interlayer{ &lt;: Integer, &lt;: AbstractSimpleGraph}}</code></pre><p>Return the collection of the vertices of <code>interlayer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L290-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.vertices-Tuple{L} where L&lt;:Layer" href="#Graphs.vertices-Tuple{L} where L&lt;:Layer"><code>Graphs.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertices(layer::L) where { L &lt;: Layer}</code></pre><p>Return the collection of the vertices of <code>layer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/layer.jl#L228-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.vertices-Tuple{M} where M&lt;:AbstractMultilayerGraph" href="#Graphs.vertices-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>Graphs.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertices(mg::M) where {M &lt;: AbstractMultilayerGraph{ &lt;: Integer, &lt;: AbstractSimpleGraph}}</code></pre><p>Return the collection of the vertices of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L356-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs._add_layer!-Union{Tuple{H}, Tuple{L}, Tuple{G}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}, H&lt;:(Type{&lt;:Graphs.AbstractGraph{T}})}" href="#MultilayerGraphs._add_layer!-Union{Tuple{H}, Tuple{L}, Tuple{G}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}, G&lt;:Graphs.AbstractGraph{T}, L&lt;:Layer{T, U, G}, H&lt;:(Type{&lt;:Graphs.AbstractGraph{T}})}"><code>MultilayerGraphs._add_layer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_add_layer!(mg::M,new_layer::L; new_default_interlayers_type::H) where { T, U, G &lt;: AbstractGraph{T}, H &lt;: AbstractGraph{T}, M &lt;: AbstractMultilayerGraph{T, U}, L &lt;: Layer{T,U,G}</code></pre><p>Internal function. It is called by the <code>add_layer!</code> API functions, which needs to specify the default interlayer graph type (SimpleGraph for undirected multilayer graphs, SimpleDiGraph for directed multilayer graphs).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs._specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:AbstractMultilayerGraph{T, U}, In&lt;:Interlayer{T, U, G}}" href="#MultilayerGraphs._specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:AbstractMultilayerGraph{T, U}, In&lt;:Interlayer{T, U, G}}"><code>MultilayerGraphs._specify_interlayer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_specify_interlayer!(mg::M, new_interlayer::In; symmetric_interlayer_name::String) where { T, U, G &lt;: AbstractGraph{T}, M &lt;: AbstractMultilayerGraph{T, U}, In &lt;: Interlayer{T,U,G}}</code></pre><p>Internal function. It is called by the <code>specify_interlayer!</code> API functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.add_layer!-Union{Tuple{L}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerDiGraph{T, U}, L&lt;:Layer{T, U, G}}" href="#MultilayerGraphs.add_layer!-Union{Tuple{L}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerDiGraph{T, U}, L&lt;:Layer{T, U, G}}"><code>MultilayerGraphs.add_layer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_layer!(mg::M,layer::L; interlayers_type = &quot;multiplex&quot;) where { T, undef, M &lt;: MultilayerDiGraph{T, G, U}, L &lt;: Layer{T,U,G}}</code></pre><p>Add layer <code>layer</code> to <code>mg</code>. Also add <code>Interlayer</code>s of type <code>interlayers_type</code> (can only be <code>&quot;multiplex&quot;</code>) between the new layer and all the other ones. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayerdigraph.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.add_layer!-Union{Tuple{L}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerGraph{T, U}, L&lt;:Layer{T, U, G}}" href="#MultilayerGraphs.add_layer!-Union{Tuple{L}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerGraph{T, U}, L&lt;:Layer{T, U, G}}"><code>MultilayerGraphs.add_layer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_layer!(mg::M,layer::L; interlayers_type = &quot;multiplex&quot;) where { T, U, G&lt;: AbstractGraph{T}, M &lt;: MultilayerGraph{T, U}, L &lt;: Layer{T,U,G}}</code></pre><p>Add layer <code>layer</code> to <code>mg</code>. Also add <code>Interlayer</code>s of type <code>interlayers_type</code> (can only be <code>&quot;multiplex&quot;</code>) between the new layer and all the other ones. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayergraph.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.adjm_eltype-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}" href="#MultilayerGraphs.adjm_eltype-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>MultilayerGraphs.adjm_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adjm_eltype(mg::M) where {M &lt;: AbstractMultilayerGraph}</code></pre><p>Return the vertex type of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L206-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.check_unique-Tuple{Union{Missing, Tuple, Vector}}" href="#MultilayerGraphs.check_unique-Tuple{Union{Missing, Tuple, Vector}}"><code>MultilayerGraphs.check_unique</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_unique(vec::Union{Missing, &lt;: Vector, &lt;: Tuple})</code></pre><p>Return <code>true</code> if all elements in <code>vec</code> are unique or if <code>ismissing(vec)</code>, else return <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.degree_second_moment-Tuple{M} where M&lt;:AbstractMultilayerGraph" href="#MultilayerGraphs.degree_second_moment-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.degree_second_moment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degree_second_moment(mg::M) where { M &lt;: AbstractMultilayerGraph}</code></pre><p>Calculate the second moment of the degree sequence of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L395-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.degree_variance-Tuple{M} where M&lt;:AbstractMultilayerGraph" href="#MultilayerGraphs.degree_variance-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.degree_variance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degree_variance(mg::M) where { M &lt;: AbstractMultilayerGraph}</code></pre><p>Return the variance of the degree sequence of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L402-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.find_trunc_dim" href="#MultilayerGraphs.find_trunc_dim"><code>MultilayerGraphs.find_trunc_dim</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Finds the dimension to which v should be truncated, and the error caused in this truncation. See documentation for tensorsvd for the meaning of the different arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/tensorsfactorizations.jl#L277-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.format_trunc_chis-Tuple{Any, Any, Any}" href="#MultilayerGraphs.format_trunc_chis-Tuple{Any, Any, Any}"><code>MultilayerGraphs.format_trunc_chis</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Format the bond dimensions listed in chis to a standard format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/tensorsfactorizations.jl#L191-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_common_type-Tuple{Vector{&lt;:DataType}}" href="#MultilayerGraphs.get_common_type-Tuple{Vector{&lt;:DataType}}"><code>MultilayerGraphs.get_common_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_common_type(types::Vector{&lt;: DataType})</code></pre><p>Returns the minimum common supertype of <code>types</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_concrete_subtypes-Tuple{Type}" href="#MultilayerGraphs.get_concrete_subtypes-Tuple{Type}"><code>MultilayerGraphs.get_concrete_subtypes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_concrete_subtypes(type::Type)</code></pre><p>Return an array of all concrete subtypes of <code>type</code> (which should be abstract).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L285-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_diagonal_adjacency_tensor-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T" href="#MultilayerGraphs.get_diagonal_adjacency_tensor-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T"><code>MultilayerGraphs.get_diagonal_adjacency_tensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_diagonal_adjacency_tensor(arr,dims)</code></pre><p>Returns a tensor whose size is <code>dims</code> and has <code>arr</code> on the diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_diagonal_elements-Union{Tuple{Array{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#MultilayerGraphs.get_diagonal_elements-Union{Tuple{Array{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>MultilayerGraphs.get_diagonal_elements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_diagonal_elements(arr::Array{T,N}) where {T,N}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L261-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_graph_of_layers-Tuple{M} where M&lt;:MultilayerDiGraph" href="#MultilayerGraphs.get_graph_of_layers-Tuple{M} where M&lt;:MultilayerDiGraph"><code>MultilayerGraphs.get_graph_of_layers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_graph_of_layers(mg::M) where {M &lt;: MultilayerDiGraph}</code></pre><p>Get a <a href="@ref"><code>DiGraphOfGraph</code></a> of the layers of <code>mg</code>. the weight of each edge between layers are obtained by summing all edge weights in the corresponding interlayer. See <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayerdigraph.jl#L333-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_graph_of_layers-Tuple{M} where M&lt;:MultilayerGraph" href="#MultilayerGraphs.get_graph_of_layers-Tuple{M} where M&lt;:MultilayerGraph"><code>MultilayerGraphs.get_graph_of_layers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_graph_of_layers(mg::M) where {M &lt;: MultilayerGraph}</code></pre><p>Get a <a href="@ref"><code>DiGraphOfGraph</code></a> of the layers of <code>mg</code>. the weight of each edge between layers are obtained by summing all edge weights in the corresponding interlayer. See <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayergraph.jl#L348-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_interlayer-Union{Tuple{M}, Tuple{M, Symbol, Symbol}} where M&lt;:AbstractMultilayerGraph" href="#MultilayerGraphs.get_interlayer-Union{Tuple{M}, Tuple{M, Symbol, Symbol}} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.get_interlayer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_interlayer(mg::M, layer_1::Symbol, layer_2::Symbol) where {M &lt;: AbstractMultilayerGraph}</code></pre><p>Return <code>(idxs_cart,interlayer)</code> where <code>interlayer</code> is the <code>Interlayer</code> between <code>layer_1</code> and <code>layer_2</code> and <code>idxs_cart</code> is the <code>CartesianIndex</code> such that <code>mg.adjacency_tensor[:,:,idxs_cart]</code> is the adjacency matrix of <code>interlayer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_layer-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, Symbol}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}" href="#MultilayerGraphs.get_layer-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, Symbol}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>MultilayerGraphs.get_layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_layer(mg::M, layer_name::Symbol) where {T, U, M &lt;: AbstractMultilayerGraph{T, U}}</code></pre><p>Return <code>(idxs_cart,layer)</code> where <code>layer_name</code> is the name of the <code>Layer</code> being queried and <code>idxs_cart</code> is the <code>CartesianIndex</code> such that <code>mg.adjacency_tensor[:,:,idxs_cart]</code> is the adjacency matrix of such layer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_oom-Tuple{Number}" href="#MultilayerGraphs.get_oom-Tuple{Number}"><code>MultilayerGraphs.get_oom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_oom(x::Number)</code></pre><p>Get the order of magnitude of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L323-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_overlay_monoplex_graph-Tuple{M} where M&lt;:MultilayerDiGraph" href="#MultilayerGraphs.get_overlay_monoplex_graph-Tuple{M} where M&lt;:MultilayerDiGraph"><code>MultilayerGraphs.get_overlay_monoplex_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_overlay_monoplex_graph(mg::M) where {M&lt;: MultilayerDiGraph}</code></pre><p>Get overlay monoplex graph (i.e. the graph that has the same nodes as <code>mg</code> but the link between node <code>i</code> and <code>j</code> has weight equal to the sum of all edges weights between the various vertices representing <code>i</code> and <code>j</code> in <code>mg</code>, accounting for both layers and interlayers). See <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayerdigraph.jl#L322-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_overlay_monoplex_graph-Tuple{M} where M&lt;:MultilayerGraph" href="#MultilayerGraphs.get_overlay_monoplex_graph-Tuple{M} where M&lt;:MultilayerGraph"><code>MultilayerGraphs.get_overlay_monoplex_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_overlay_monoplex_graph(mg::M) where {M&lt;: MultilayerGraph}</code></pre><p>Get overlay monoplex graph (i.e. the graph that has the same nodes as <code>mg</code> but the link between node <code>i</code> and <code>j</code> has weight equal to the sum of all edges weights between the various vertices representing <code>i</code> and <code>j</code> in <code>mg</code>, accounting for both layers and interlayers). See <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayergraph.jl#L333-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_projected_monoplex_graph-Tuple{M} where M&lt;:MultilayerDiGraph" href="#MultilayerGraphs.get_projected_monoplex_graph-Tuple{M} where M&lt;:MultilayerDiGraph"><code>MultilayerGraphs.get_projected_monoplex_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_projected_monoplex_graph(mg::M) where {M&lt;: MultilayerDiGraph}</code></pre><p>Get projected monoplex graph (i.e. the graph that as the same nodes as <code>mg</code> but the link between node <code>i</code> and <code>j</code> has weight equal to the sum of all edges weights between the various vertices representing <code>i</code> and <code>j</code> in <code>mg</code>, accounting for both layers and interlayers). See <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayerdigraph.jl#L311-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_projected_monoplex_graph-Tuple{M} where M&lt;:MultilayerGraph" href="#MultilayerGraphs.get_projected_monoplex_graph-Tuple{M} where M&lt;:MultilayerGraph"><code>MultilayerGraphs.get_projected_monoplex_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_projected_monoplex_graph(mg::M) where {M&lt;: MultilayerGraph}</code></pre><p>Get projected monoplex graph (i.e. that graph that as the same nodes as <code>mg</code> but the link between node <code>i</code> and <code>j</code> has weight equal to the sum of all edges weights between the various vertices representing <code>i</code> and <code>j</code> in <code>mg</code>, accounting for both layers and interlayers). See <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayergraph.jl#L314-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_subgraph-Union{Tuple{M}, Tuple{M, Vararg{Symbol}}} where M&lt;:AbstractMultilayerGraph" href="#MultilayerGraphs.get_subgraph-Union{Tuple{M}, Tuple{M, Vararg{Symbol}}} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.get_subgraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_subgraph(mg::M, names...) where {M &lt;: AbstractMultilayerGraph}</code></pre><p>If <code>length(names) == 1</code>, then this is equivalent to calling <code>get_layer(mg,names[1])</code> else if <code>length(names) == 2</code>, this is equivalent to calling <code>get_interlayer(mg,names[1],names[2])</code>. Throws an <code>ErrorException</code> in all other cases. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_symmetric_interlayer-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, In&lt;:Interlayer{T, U, G}}" href="#MultilayerGraphs.get_symmetric_interlayer-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>MultilayerGraphs.get_symmetric_interlayer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_symmetric_interlayer(interlayer::In; symmetric_interlayer_name::String) where{T,U,G, In &lt;: Interlayer{T,U,G}}</code></pre><p>Return the <code>Interlayer</code> corresponding to <code>interlayer</code> where <code>layer_1</code> and <code>layer_2</code> are swapped. Its name will be <code>symmetric_interlayer_name</code> (defaults to <code>interlayer_(interlayer.layer_2)_(interlayer.layer_1)</code> ).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L420-L424">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.is_weighted-Tuple{G} where G&lt;:Graphs.AbstractGraph" href="#MultilayerGraphs.is_weighted-Tuple{G} where G&lt;:Graphs.AbstractGraph"><code>MultilayerGraphs.is_weighted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_weighted(g::G) where { G &lt;: AbstractGraph}</code></pre><p>Check whether g is weighted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.isapproxsymmetric-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Integer" href="#MultilayerGraphs.isapproxsymmetric-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Integer"><code>MultilayerGraphs.isapproxsymmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isapproxsymmetric(A::Matrix{T}) where {T &lt;: Real }</code></pre><p>Check whether <code>A</code> is symmetric (within <code>zero(T)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L347-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.isapproxsymmetric-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real" href="#MultilayerGraphs.isapproxsymmetric-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>MultilayerGraphs.isapproxsymmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isapproxsymmetric(A::Matrix{T}) where {T &lt;: Real }</code></pre><p>&quot;Check whether <code>A</code> is approximately symmetric (within <code>eps(T)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L339-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.iscompletelyinitialized-Tuple{Any}" href="#MultilayerGraphs.iscompletelyinitialized-Tuple{Any}"><code>MultilayerGraphs.iscompletelyinitialized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iscompletelyinitialized(obj::Any)</code></pre><p>Check whether <code>obj</code> is completely initialized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L305-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.mean_degree-Tuple{M} where M&lt;:AbstractMultilayerGraph" href="#MultilayerGraphs.mean_degree-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.mean_degree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean_degree(mg::M) where { M &lt;: AbstractMultilayerGraph}</code></pre><p>Return the mean of the degree sequence of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L388-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.multilayer_global_clustering_coefficient-Union{Tuple{M}, Tuple{M, Union{Float64, Symbol}}} where M&lt;:AbstractMultilayerGraph" href="#MultilayerGraphs.multilayer_global_clustering_coefficient-Union{Tuple{M}, Tuple{M, Union{Float64, Symbol}}} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.multilayer_global_clustering_coefficient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multilayer_clustering_coefficient(mg::M, norm_factor::Union{Float64, Symbol} = :max) where {M &lt;: AbstractMultilayerGraph}</code></pre><p>Return the complete multilayer global clustering coefficient, equal to the ratio of realized triplets over all possible triplets, including those whose every or some edges belong to interlayers, normalized by <code>norm_factor</code>. If <code>norm_factor == :max</code>, then the ratio is normalized by <code>maximum(mg.adjacency_tensor)</code>. This function overrides Graphs.jl&#39;s <code>global_clustering_coefficient</code>, since the latter does not consider cliques where two nodes are the same node but in different layers/interlayers. See <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L409-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.multilayer_kronecker_delta-Tuple{NTuple{4, Int64}}" href="#MultilayerGraphs.multilayer_kronecker_delta-Tuple{NTuple{4, Int64}}"><code>MultilayerGraphs.multilayer_kronecker_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multilayer_kronecker_delta(dims...)</code></pre><p>Returns a 4 dimensional kronecker delta with size equal to <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/utilities.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.multilayer_weighted_global_clustering_coefficient-Union{Tuple{M}, Tuple{M, Vector{Float64}}, Tuple{M, Vector{Float64}, Union{Float64, Symbol}}} where M&lt;:AbstractMultilayerGraph" href="#MultilayerGraphs.multilayer_weighted_global_clustering_coefficient-Union{Tuple{M}, Tuple{M, Vector{Float64}}, Tuple{M, Vector{Float64}, Union{Float64, Symbol}}} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.multilayer_weighted_global_clustering_coefficient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multilayer_weighted_global_clustering_coefficient(mg::M, norm_factor::Union{Float64, Symbol} = :max) where {M &lt;: AbstractMultilayerGraph}</code></pre><p>Return the complete multilayer global clustering coefficient, equal to the ratio of realized triplets over all possible triplets, including those whose every or some edges belong to interlayers, normalized by <code>norm_factor</code>. Each triplets contributes for <code>w[1]</code> if all of its vertices are in one layer, <code>w[2]</code> if its vertices span two layers, and <code>w[3]</code> if they span 3 layers. If <code>norm_factor == :max</code>, then the ratio is normalized by <code>maximum(mg.adjacency_tensor)</code>. This function overrides Graphs.jl&#39;s <code>global_clustering_coefficient</code>, since the latter does not consider cliques where two nodes are the same node but in different layers/interlayers. See <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L440-L444">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.multiplex_interlayer-Union{Tuple{G}, Tuple{T}, Tuple{Int64, Symbol, Symbol, Symbol, Type{G}}} where {T&lt;:(Union{AbstractVertex, var&quot;#s14&quot;} where var&quot;#s14&quot;&lt;:Integer), G&lt;:Graphs.AbstractGraph{T}}" href="#MultilayerGraphs.multiplex_interlayer-Union{Tuple{G}, Tuple{T}, Tuple{Int64, Symbol, Symbol, Symbol, Type{G}}} where {T&lt;:(Union{AbstractVertex, var&quot;#s14&quot;} where var&quot;#s14&quot;&lt;:Integer), G&lt;:Graphs.AbstractGraph{T}}"><code>MultilayerGraphs.multiplex_interlayer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multiplex_interlayer(nv::Int64, name::Symbol,layer_1::Symbol, layer_2::Symbol, graph_type::Type{G}; forbidden_vertices::Vector{MultilayerVertex{T}}, forbidden_edges::Vector{NTuple{2, MultilayerVertex{T}}}) where {T &lt;: Union{ &lt;: Integer, AbstractVertex}, G &lt;: AbstractGraph{T};  IsWeighted{G}}</code></pre><p>Return an <code>Interlayer{T,U,G}</code> that has edges only between vertices that represent the same node.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>nv::Int64</code>: number of vertices;</li><li><code>name::Symbol</code>: name of the Interlayer;</li><li><code>layer_1::Symbol</code>: The first Layer it connects;</li><li><code>layer_2::Symbol</code>: The second Layer it connects;</li><li><code>graph_type::Type{G}</code>: the underlying graph type;</li><li><code>U::Type = Float64</code>: the eltype of the adjacency matrix of the Interlayer. Note: it doesn&#39;t have to coincide with the underlying graph&#39;s adjacency matrix eltype, since right now there is no guarantee that all Graphs.jl&#39;s extension will allow the user to set such eltype on new graph types.</li><li><code>forbidden_vertices::Vector{MultilayerVertex{T}}</code>: list of vertices that are not considered present in the Interlayer;</li><li><code>forbidden_edges::Vector{NTuple{2, MultilayerVertex{T}}}</code>: list of edges whose existence is a priori excluded from the Interlayer.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/interlayer.jl#L176-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.nIn-Tuple{M} where M&lt;:AbstractMultilayerGraph" href="#MultilayerGraphs.nIn-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.nIn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nIn(mg::M) where {M &lt;: AbstractMultilayerGraph }</code></pre><p>Return the number of interlayers in <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L327-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.nl-Tuple{M} where M&lt;:AbstractMultilayerGraph" href="#MultilayerGraphs.nl-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.nl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nl(mg::M) where {M &lt;: AbstractMultilayerGraph }</code></pre><p>Return the number of layers in <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L320-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.nn-Tuple{M} where M&lt;:AbstractMultilayerGraph" href="#MultilayerGraphs.nn-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.nn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nn(mg::M) where {M &lt;: AbstractMultilayerGraph }</code></pre><p>Return the number of nodes in <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L313-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.nodes-Tuple{M} where M&lt;:AbstractMultilayerGraph" href="#MultilayerGraphs.nodes-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nodes(mg::M) where {M &lt;: AbstractMultilayerGraph}</code></pre><p>Return the nodes of the AbstractMultilayerGraph <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L370-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.overlay_clustering_coefficient-Union{Tuple{M}, Tuple{M, Union{Float64, Symbol}}} where M&lt;:AbstractMultilayerGraph" href="#MultilayerGraphs.overlay_clustering_coefficient-Union{Tuple{M}, Tuple{M, Union{Float64, Symbol}}} where M&lt;:AbstractMultilayerGraph"><code>MultilayerGraphs.overlay_clustering_coefficient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlay_clustering_coefficient(mg::M, norm_factor::Union{Float64, Symbol} = :max) where {M &lt;: AbstractMultilayerGraph}</code></pre><p>Return the overlay clustering coefficient as calculated in <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/abstractmultilayergraph.jl#L466-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerDiGraph{T, U}, In&lt;:Interlayer{T, U, G}}" href="#MultilayerGraphs.specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerDiGraph{T, U}, In&lt;:Interlayer{T, U, G}}"><code>MultilayerGraphs.specify_interlayer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">specify_interlayer!(mg::M, new_interlayer::In; symmetric_interlayer_name::Symbol) where { T, U, G&lt;: AbstractGraph{T}, M &lt;: MultilayerDiGraph{T, U}, In &lt;: Interlayer{T,G}; IsDirected{M}}</code></pre><p>Specify the interlayer <code>new_interlayer</code> as part of <code>mg</code>. The underlying graph of <code>new_interlayer</code> must be directed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayerdigraph.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerGraph{T, U}, In&lt;:Interlayer{T, U, G}}" href="#MultilayerGraphs.specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerGraph{T, U}, In&lt;:Interlayer{T, U, G}}"><code>MultilayerGraphs.specify_interlayer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">specify_interlayer!(mg::M, new_interlayer::In; symmetric_interlayer_name::String) where { T, U, G&lt;: AbstractGraph{T}, M &lt;: MultilayerGraph{T, U}, In &lt;: Interlayer{T,U,G}}</code></pre><p>Specify the interlayer <code>new_interlayer</code> as part of <code>mg</code>. The underlying graph of <code>new_interlayer</code> must be undirected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayergraph.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.specify_interlayer!-Union{Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, Symbol, Symbol, G}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerDiGraph{T, U}}" href="#MultilayerGraphs.specify_interlayer!-Union{Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, Symbol, Symbol, G}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerDiGraph{T, U}}"><code>MultilayerGraphs.specify_interlayer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">specify_interlayer!(mg::M, layer_1::Symbol, layer_2::Symbol, graph::G; new_interlayer_name::Symbol, symmetric_interlayer_name::Symbol ,  forbidden_vertices::Tuple{Vararg{MultilayerVertex{T}}}, forbidden_edges::Tuple{Vararg{NTuple{2, MultilayerVertex{T}}}} ) where { T, U, G&lt;: AbstractGraph{T}, M &lt;: MultilayerDiGraph{T,U}}</code></pre><p>Specify an interlayer which is represented by <code>graph</code> between <code>layer_1</code> and <code>layer_2</code>. The Interlayer&#39;s name can be specified via <code>new_interlayer_name</code>, as the name of its corresponding Interlayer between <code>layer_2</code> and <code>layer_1</code> (via the <code>symmetric_interlayer_name</code>) which is the same graph just with the adjacency matrix reordered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayerdigraph.jl#L128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.src-Tuple{AbstractMultilayerEdge}" href="#MultilayerGraphs.src-Tuple{AbstractMultilayerEdge}"><code>MultilayerGraphs.src</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">src(e::AbstractMultilayerEdge)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayeredge.jl#L40-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.tensoreig-Tuple{Any, Any, Any}" href="#MultilayerGraphs.tensoreig-Tuple{Any, Any, Any}"><code>MultilayerGraphs.tensoreig</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tensoreig(A, a, b; chis=nothing, eps=0,
          return_error=false, print_error=false,
          break_degenerate=false, degeneracy_eps=1e-6,
          norm_type=:frobenius, hermitian=false)</code></pre><p>Finds the &quot;right&quot; eigenvectors and eigenvalues of A. The indices of A are permuted so that the indices listed in the Array/Tuple a are on the &quot;left&quot; side and indices listed in b are on the &quot;right&quot;.  The resulting tensor is then reshaped to a matrix, and eig is called on this matrix to get the vector of eigenvalues E and matrix of eigenvectors U. Finally, U is reshaped to a tensor that has as its last index the one that enumerates the eigenvectors and the indices in a as its first indices.</p><p>Truncation and error printing work as with tensorsvd.</p><p>Note that no iterative techniques are used, which means that choosing to truncate provides no performance benefits: All the eigenvalues are computed in any case.</p><p>The keyword argument hermitian (false by default) tells the algorithm whether the reshaped matrix is Hermitian or not. If hermitian=true, then A = U<em>diagm(E)</em>U&#39; up to the truncation error.</p><p>Output is E, U, and possibly error, if return_error=true. Here E is a vector of eigenvalues values and U[:,...,:,k] is the kth eigenvector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/tensorsfactorizations.jl#L47-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.tensorsplit-Tuple" href="#MultilayerGraphs.tensorsplit-Tuple"><code>MultilayerGraphs.tensorsplit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tensorsplit(A, a, b; kwargs...)</code></pre><p>Calls tensorsvd with the arguments given to it to decompose the given tensor A with indices a on one side and indices b on the other.  It then splits the diagonal matrix of singular values into two with a square root and multiplies these weights into the isometric tensors.  Thus tensorsplit ends up splitting A into two parts, which are then returned, possibly together with auxiliary data such as a truncation error. If the keyword argument hermitian=true, an eigenvalue decomposition is used in stead of an SVD. All the keyword arguments are passed to either tensorsvd or tensoreig.</p><p>See tensorsvd and tensoreig for further documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/tensorsfactorizations.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.tensorsvd-Tuple{Any, Any, Any}" href="#MultilayerGraphs.tensorsvd-Tuple{Any, Any, Any}"><code>MultilayerGraphs.tensorsvd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tensorsvd(A, a, b;
          chis=nothing, eps=0,
          return_error=false, print_error=false,
          break_degenerate=false, degeneracy_eps=1e-6,
          norm_type=:frobenius)</code></pre><p>Singular valued decomposes a tensor A. The indices of A are permuted so that the indices listed in the Array/Tuple a are on the &quot;left&quot; side and indices listed in b are on the &quot;right&quot;.  The resulting tensor is then reshaped to a matrix, and this matrix is SVDed into U<em>diagm(S)</em>Vt. Finally, the unitary matrices U and Vt are reshaped to tensors so that they have a new index coming from the SVD, for U as the last index and for Vt as the first, and U has indices a as its first indices and V has indices b as its last indices.</p><p>If eps&gt;0 then the SVD may be truncated if the relative error can be kept below eps. For this purpose different dimensions to truncate to can be tried, and these dimensions should be listed in chis. If chis is nothing (the default) then the full range of possible dimensions is tried. If break<em>degenerate=false (the default) then the truncation never cuts between degenerate singular values. degeneracy</em>eps controls how close the values need to be to be considered degenerate.</p><p>norm_type specifies the norm used to measure the error. This defaults to :frobenius, which means that the error measured is the Frobenius norm of the difference between A and the decomposition, divided by the Frobenius norm of A.  This is the same thing as the 2-norm of the singular values that are truncated out, divided by the 2-norm of all the singular values. The other option is :trace, in which case a 1-norm is used instead.</p><p>If print_error=true the truncation error is printed. The default is false.</p><p>If return_error=true then the truncation error is also returned. The default is false.</p><p>Note that no iterative techniques are used, which means choosing to truncate provides no performance benefits: The full SVD is computed in any case.</p><p>Output is U, S, Vt, and possibly error. Here S is a vector of singular values and U and Vt are isometric tensors (unitary if the matrix that is SVDed is square and there is no truncation) such that  U<em>diag(S)</em>Vt = A, up to truncation errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/tensorsfactorizations.jl#L115-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.to_matrix-Tuple{Any, Any, Any}" href="#MultilayerGraphs.to_matrix-Tuple{Any, Any, Any}"><code>MultilayerGraphs.to_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transpose A so that the indices listed in a are on the left and the indices listed in b on the right, and reshape A into a matrix.</p><p>a and b should be arrays of Integers that together include the numbers from 1 to ndims(A). Alternatively they can be just individual Integers, if only one index is left on one side.</p><p>If return<em>tensor</em>shape is true (by default it&#39;s not) return, in addition to the matrix, the shape of the tensor after the transpose but before the reshape.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/tensorsfactorizations.jl#L230-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.von_neumann_entropy-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:MultilayerGraph{T, U}}" href="#MultilayerGraphs.von_neumann_entropy-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:MultilayerGraph{T, U}}"><code>MultilayerGraphs.von_neumann_entropy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">von_neumann_entropy(mg::M) where {T,U,  M &lt;: MultilayerGraph{T, U}}</code></pre><p>Compute the Von Neumann entropy of <code>mg</code>, according to <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>. Only for undirected multilayer graphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayergraph.jl#L372-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.weight-Tuple{AbstractMultilayerEdge}" href="#MultilayerGraphs.weight-Tuple{AbstractMultilayerEdge}"><code>MultilayerGraphs.weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weight(e::AbstractMultilayerEdge)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/b97275d0bb4b12e11789dc1f974694657f94bb50/src/multilayeredge.jl#L50-L52">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Monday 15 August 2022 22:48">Monday 15 August 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
