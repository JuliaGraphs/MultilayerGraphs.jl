<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MultilayerGraphs.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://InPhyT.github.io/MultilayerGraphs.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="MultilayerGraphs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>MultilayerGraphs.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Tutorial"><span>Tutorial</span></a></li><li><a class="tocitem" href="#How-to-Contribute"><span>How to Contribute</span></a></li><li><a class="tocitem" href="#How-to-Cite"><span>How to Cite</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><div style="width:100%; height:150px;border-width:4px;border-style:solid;padding-top:25px;
        border-color:#000;border-radius:10px;text-align:center;background-color:#B3D8FF;
        color:#000">
    <h3 style="color: black;">Star us on GitHub!</h3>
    <a class="github-button" href="https://github.com/InPhyT/MultilayerGraphs.jl" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star InPhyT/MultilayerGraphs.jl on GitHub" style="margin:auto">Star</a>
    <script async defer src="https://buttons.github.io/buttons.js"></script>
</div><h1 id="MultilayerGraphs.jl"><a class="docs-heading-anchor" href="#MultilayerGraphs.jl">MultilayerGraphs.jl</a><a id="MultilayerGraphs.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MultilayerGraphs.jl" title="Permalink"></a></h1><p><strong>MultilayerGraphs.jl</strong> is a Julia package for the construction, manipulation and analysis of multilayer graphs <a href="https://juliagraphs.org/Graphs.jl/dev/ecosystem/interface/">extending Graphs.jl</a>.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p><strong>MultilayerGraphs.jl</strong> implements the mathematical formulation of multilayer graphs proposed by <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>. It mainly revolves around two custom types, <a href="internals/#MultilayerGraphs.MultilayerGraph"><code>MultilayerGraph</code></a> and <a href="internals/#MultilayerGraphs.MultilayerDiGraph"><code>MultilayerDiGraph</code></a>, encoding undirected and directed multilayer graphs respectively. </p><p>Roughly speaking, a multilayer graph is a collection of graphs, called <em>layers</em>, whose vertices are representations of the same set of nodes endowed with a relational structure provided by the <em>interlayer</em>: the <a href="https://en.wikipedia.org/wiki/Bipartite_graph">bipartite graph</a> whose vertices are those of any two consecutive layers and whose edges are those between nodes of the two consecutive layers. See below for the distinction between <em>node</em> and <em>vertex</em>.</p><p><a href="internals/#MultilayerGraphs.MultilayerGraph"><code>MultilayerGraph</code></a> and <a href="internals/#MultilayerGraphs.MultilayerDiGraph"><code>MultilayerDiGraph</code></a> are fully-fledged <a href="https://github.com/JuliaGraphs/Graphs.jl">Graphs.jl</a> extensions. Both structs are designed so that their layers and interlayers can be of any type (as long as they are Graphs.jl extensions themselves) and they need not be all of the same type. It is anyway required that all layers and interlayers of <a href="internals/#MultilayerGraphs.MultilayerGraph"><code>MultilayerGraph</code></a> and <a href="internals/#MultilayerGraphs.MultilayerDiGraph"><code>MultilayerDiGraph</code></a> are respectively undirected and directed. Directedness is checked via the <code>IsDirected</code> trait defined in Graphs.jl adopting <a href="https://github.com/mauro3/SimpleTraits.jl">SimpleTraits.jl</a>. Since the layers&#39; and interlayers&#39; graph types don&#39;t need to be the same, multilayer graph types are considered weighted graphs by default, and thus are assigned the trait <code>IsWeighted</code>.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>Press <code>]</code> in the Julia REPL and then</p><pre><code class="language-julia hljs">pkg&gt; add https://github.com/InPhyT/MultilayerGraphs.jl</code></pre><h2 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h2><p>Here we illustrate how to define, handle and analyse a <a href="internals/#MultilayerGraphs.MultilayerGraph"><code>MultilayerGraph</code></a> (the directed version is completely analogous).</p><h3 id="Layers-and-Interlayers"><a class="docs-heading-anchor" href="#Layers-and-Interlayers">Layers and Interlayers</a><a id="Layers-and-Interlayers-1"></a><a class="docs-heading-anchor-permalink" href="#Layers-and-Interlayers" title="Permalink"></a></h3><p>Let&#39;s import some necessary packages</p><pre><code class="language-julia hljs"># Import necessary dependencies
using Graphs, SimpleWeightedGraphs, MultilayerGraphs</code></pre><p>We define some methods and constants that will prove useful later in the tutorial (you may come back to these later when they get used)</p><pre><code class="language-julia hljs"># Set the number of nodes, minimum and maximum number of edges for random graphs
const n_nodes   = 5
const min_edges = n_nodes
const max_edges = 10

# Define methods generating random graphs
get_SimpleGraph()   = SimpleGraph(n_nodes, rand(min_edges:max_edges))   # Undirected graph
get_SimpleDiGraph() = SimpleDiGraph(n_nodes, rand(min_edges:max_edges)) # Directed graph

# Define variables for random weighted graphs
const simpleweightedgraph_sources      = 1:n_nodes
const simpleweightedgraph_destinations = rand(1:n_nodes, n_nodes)
const simpleweightedgraph_weights      = rand(n_nodes)

# Define methods generating random weighted graphs
get_SimpleWeightedGraph()   = SimpleWeightedGraph(simpleweightedgraph_sources, rand(1:n_nodes, n_nodes), rand(n_nodes))    # Undirected graph
get_SimpleWeightedDiGraph() = SimpleWeightedDiGraph(simpleweightedgraph_sources, rand(1:n_nodes, n_nodes), rand(n_nodes))  # Directed graph</code></pre><p>We proceed by constructing a layer (see <a href="internals/#MultilayerGraphs.Layer"><code>Layer</code></a>)</p><pre><code class="language-julia hljs"># Construct a layer 
layer = Layer(:layer_1, SimpleGraph(n_nodes, rand(min_edges:max_edges)); U = Float64)</code></pre><p>A <code>Layer</code> has a name (here <code>:layer_1</code>), an underlying graph (<code>SimpleGraph(n_nodes, rand(min_edges:max_edges))</code>) and an adjacency matrix <code>eltype</code> <code>U</code>. To correctly specify a multilayer graph all layers and interlayers must have the same <code>U</code>, otherwise the adjacency tensor would be poorly specified. Notice that <code>U</code> does not need to coincide with the <code>eltype</code> of the adjacency matrix of the underlying graph. </p><p>As far as we know, there is no way to set it explicitly for all Graphs.jl extensions, nor it is required for extensions to implement such feature, so our package converts to <code>U</code> the <code>eltype</code> of <code>Layer</code>s and <code>Interlayer</code>s adjacency matrices every time they are invoked</p><pre><code class="language-julia hljs">adjacency_matrix(layers[1])</code></pre><pre><code class="language-nothing hljs">5×5 SparseMatrixCSC{Float64, Int64} with 16 stored entries:
  ⋅   1.0   ⋅   1.0  1.0
 1.0   ⋅   1.0  1.0   ⋅
  ⋅   1.0   ⋅   1.0  1.0
 1.0  1.0  1.0   ⋅   1.0
 1.0   ⋅   1.0  1.0   ⋅</code></pre><p>We may define more <code>Layer</code>s for future use</p><pre><code class="language-julia hljs">layers = [
            Layer(:layer_1, get_SimpleGraph(); U = Float64),
            Layer(:layer_2, get_SimpleWeightedGraph(); U = Float64),
            Layer(:layer_3, get_SimpleWeightedGraph(); U = Float64),
         ]</code></pre><p>There are other constructors for the <code>Layer</code> struct you may want to consult via <code>?Layer</code>.</p><p>We similarly define an interlayer (see <a href="internals/#MultilayerGraphs.Interlayer"><code>Interlayer</code></a>)</p><pre><code class="language-julia hljs">interlayer = Interlayer(n_nodes, :interlayer_layer_1_layer_2 , :layer_1, :layer_2, SimpleGraph{Int64}, rand(min_edges:max_edges); U = Float64)</code></pre><p>Here we used a constructor that returns a random <code>Interlayer</code>. Its arguments are the number of nodes <code>n_nodes</code>, the name of the <code>Interlayer</code> <code>interlayer_layer_1_layer_2</code>, the name of the <code>Layers</code> that it connects (<code>:layer_1</code> and <code>:layer_2</code>), the underlying graph type <code>SimpleGraph{Int64}</code>, and the number of edges <code>rand(min_edges:max_edges)</code> and the adjacency matrix <code>eltype</code> again need to be specified (although it may be left blank and the constructor will default to <code>eltype(adjacency_matrix(SimpleGraph{Int64}))</code>).</p><p>The adjacency matrix of an <code>Interlayer</code> is that of a bipartite graph</p><pre><code class="language-julia hljs">adjacency_matrix(interlayer)</code></pre><pre><code class="language-nothing hljs">10×10 SparseMatrixCSC{Float64, Int64} with 18 stored entries:
  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0
  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅   1.0  1.0   ⋅ 
  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅ 
  ⋅    ⋅    ⋅    ⋅    ⋅   1.0  1.0   ⋅    ⋅   1.0
  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅ 
  ⋅   1.0  1.0  1.0  1.0   ⋅    ⋅    ⋅    ⋅    ⋅ 
  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ 
  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ 
  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ 
 1.0   ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ </code></pre><p>It is a 4 block matrix where the first <code>n_nodes</code> rows and columns refer to <code>:layer_1</code>&#39;s vertices, while the last <code>n_nodes</code> rows and columns refer to <code>:layer_2</code>&#39;s vertices.</p><p>We may define more <code>Interlayer</code>s for future use:</p><pre><code class="language-julia hljs">interlayers = [ 
                Interlayer(n_nodes, :interlayer_layer_1_layer_2, :layer_1, :layer_2, SimpleGraph{Int64}, rand(min_edges:max_edges); U = Float64), 
                Interlayer(n_nodes, :interlayer_layer_1_layer_3, :layer_1, :layer_3, SimpleWeightedGraph{Int64,Float64}, rand(min_edges:max_edges)) 
              ]</code></pre><p>There are other constructors for the <code>Interlayer</code> struct you may want to consult via <code>?Interlayer</code>.</p><p><code>Layer</code>s and <code>Interlayer</code>s and complete extensions of Graphs.jl, so all methods in Graphs.jl should just work. The explicitly extended methods are <a href="internals/#Graphs.edges-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, In&lt;:Interlayer{T, U, G}}"><code>edges</code></a>, <a href="internals/#Base.eltype-Tuple{In} where In&lt;:Interlayer"><code>eltype</code></a>, <a href="internals/#Graphs.edgetype-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>edgetype</code></a>, <a href="internals/#Graphs.has_edge-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>has_edge</code></a>, <a href="internals/#Graphs.has_vertex-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>has_vertex</code></a>, <a href="internals/#Graphs.inneighbors-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>inneighbors</code></a>, <a href="internals/#Graphs.ne-Tuple{In} where In&lt;:Interlayer"><code>ne</code></a>, <a href="internals/#Graphs.nv-Tuple{In} where In&lt;:Interlayer"><code>nv</code></a>, <a href="internals/#Graphs.outneighbors-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>outneighbors</code></a>, <a href="internals/#Graphs.vertices-Tuple{In} where In&lt;:Interlayer"><code>vertices</code></a>, <a href="internals/#Graphs.is_directed-Tuple{In} where In&lt;:Interlayer"><code>is_directed</code></a>, <a href="internals/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, E}} where {T, U, G, In&lt;:Interlayer{T, U, G}, E&lt;:MultilayerEdge{MultilayerVertex{T}, Nothing}}"><code>add_edge!</code></a>, <a href="internals/#Graphs.SimpleGraphs.rem_edge!-Union{Tuple{V}, Tuple{In}, Tuple{U}, Tuple{T}, Tuple{In, V, V}} where {T, U, In&lt;:(Interlayer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}), V&lt;:MultilayerVertex{T}}"><code>rem_edge!</code></a>.</p><h3 id="Instantiation-and-Handling-of-MultilayerGraph"><a class="docs-heading-anchor" href="#Instantiation-and-Handling-of-MultilayerGraph">Instantiation and Handling of <code>MultilayerGraph</code></a><a id="Instantiation-and-Handling-of-MultilayerGraph-1"></a><a class="docs-heading-anchor-permalink" href="#Instantiation-and-Handling-of-MultilayerGraph" title="Permalink"></a></h3><p>We can define a <code>MultilayerGraph</code> by specifying its layers and interlayers:</p><pre><code class="language-julia hljs">multilayergraph = MultilayerGraph(layers, interlayers; default_interlayer = &quot;multiplex&quot;)</code></pre><pre><code class="language-nothing hljs">MultilayerGraph{Int64, Float64}([0.0 1.0 … 1.0 1.0; 1.0 0.0 … 0.0 1.0; … ; 1.0 0.0 … 0.0 0.0; 1.0 1.0 … 0.0 0.0;;; 0.0 0.0 … 0.0 0.0; 0.0 1.0 …],...)</code></pre><p>It is not important that the <code>interlayers</code> array does not contain all the interlayers needed to specify the multilayer graph: the unspecified interlayers are automatically generated according to the <code>default_interlayer</code> argument. Right now only the <code>&quot;multiplex&quot;</code> value is supported, and will generate interlayers that have edges between pair of vertices of the two layers that represent the same node.</p><p>Notice that in the output the signature of <code>MultilayerGraph</code> has two parametric types, namely <code>MultilayerGraph{Int64, Float64}</code>. The first is referred to the node type, that just as in every <code>Graphs.jl</code> extension it is a subtype of <code>Integer</code>. The second parameter is instead the <code>eltype</code> of the equivalent of the adjacency matrix for multilayer graphs: the adjacency tensor (see below for more).</p><p>You may also specify random <code>MultilayerGraph</code></p><pre><code class="language-julia hljs">random_multilayergraph = MultilayerGraph( 3,         # Number of layers
                                          n_nodes,   # Number of nodes
                                          min_edges, # Minimum number of edges in each layer/interlayer
                                          max_edges, # Maximum number of edges in each layer/interlayer
                                          [
                                             SimpleGraph{Int64},
                                             SimpleWeightedGraph{Int64, Float64},
                                          ]          # The set of graph types to random draw from when constructing layers and interlayers
                                        )</code></pre><p>Alternatively, one may add layers and interlayers calling the <a href="internals/#MultilayerGraphs.add_layer!-Union{Tuple{L}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerDiGraph{T, U}, L&lt;:Layer{T, U, G}}"><code>add_layer!</code></a> and <a href="internals/#MultilayerGraphs.specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerDiGraph{T, U}, In&lt;:Interlayer{T, U, G}}"><code>specify_interlayer!</code></a> functions respectively, perhaps starting with an empty multilayer graph created with the constructor:</p><pre><code class="language-julia hljs">empty_multilayergraph  = MultilayerGraph( n_nodes, # Number of nodes
                                          Int64,   # Node type
                                          Float64  # Adjacency tensor&#39;s eltype, see below
                                        )</code></pre><p>Let&#39;s explore some properties of the <code>MultilayerGraph</code> struct. </p><h4 id="Layers"><a class="docs-heading-anchor" href="#Layers">Layers</a><a id="Layers-1"></a><a class="docs-heading-anchor-permalink" href="#Layers" title="Permalink"></a></h4><p>It is an <code>OrderedDict</code> where the keys are the layers&#39; indexes within the multilayer graph and the values are the actual <code>Layer</code>s</p><pre><code class="language-julia hljs">multilayergraph.layers</code></pre><pre><code class="language-nothing hljs">OrderedDict{Tuple{Int64, Int64}, Layer{Int64, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{Int64}}} with 3 entries:
  (1, 1) =&gt; Layer{Int64, Float64, SimpleGraph{Int64}}(:layer_1, SimpleGraph{Int64}(5, [[2, 4], [1, 3, 4], [2], [1, 2, 5], [4]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}}[])
  (2, 2) =&gt; Layer{Int64, Float64, SimpleWeightedGraph{Int64, Float64}}(:layer_2, {5, 4} undirected simple Int64 graph with Float64 weights, MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}}[])
  (3, 3) =&gt; Layer{Int64, Float64, SimpleWeightedGraph{Int64, Float64}}(:layer_3, {5, 4} undirected simple Int64 graph with Float64 weights, MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}}[])</code></pre><h4 id="Interlayers"><a class="docs-heading-anchor" href="#Interlayers">Interlayers</a><a id="Interlayers-1"></a><a class="docs-heading-anchor-permalink" href="#Interlayers" title="Permalink"></a></h4><p>It is an <code>OrderedDict</code> where each key is the pair of indexes of the layers that the corresponding value, i.e. the interlayer, connects within the multilayer graph</p><pre><code class="language-julia hljs">multilayergraph.interlayers</code></pre><pre><code class="language-nothing hljs">OrderedDict{Tuple{Int64, Int64}, Interlayer{Int64, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{Int64}}} with 6 entries:
  (2, 1) =&gt; Interlayer{Int64, Float64, SimpleGraph{Int64}}(:interlayer_layer_2_layer_1, :layer_2, :layer_1, SimpleGraph{Int64}(9, [[7, 8, 9, 10], [9], [7], [7], [6, 9], [5], [1, 3, 4], [1], [1, 2, 5], [1]]), MultilayerVertex{Int64}[], Tuple{MultilayerVerte…  
  (1, 2) =&gt; Interlayer{Int64, Float64, SimpleGraph{Int64}}(:interlayer_layer_1_layer_2, :layer_1, :layer_2, SimpleGraph{Int64}(9, [[10], [6, 8, 9], [6], [6, 7, 10], [6], [2, 3, 4, 5], [4], [2], [2], [1, 4]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64},…  
  (3, 1) =&gt; Interlayer{Int64, Float64, SimpleWeightedGraph{Int64, Float64}}(:interlayer_layer_3_layer_1, :layer_3, :layer_1, {10, 7} undirected simple Int64 graph with Float64 weights, MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVer…  
  (1, 3) =&gt; Interlayer{Int64, Float64, SimpleWeightedGraph{Int64, Float64}}(:interlayer_layer_1_layer_3, :layer_1, :layer_3, {10, 4} undirected simple Int64 graph with Float64 weights, MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}…  
  (3, 2) =&gt; Interlayer{Int64, Float64, SimpleGraph{Int64}}(:interlayer_layer_3_layer_2, :layer_3, :layer_2, SimpleGraph{Int64}(5, [[6], [7], [8], [9], [10], [1], [2], [3], [4], [5]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVert…  
  (2, 3) =&gt; Interlayer{Int64, Float64, SimpleGraph{Int64}}(:interlayer_layer_2_layer_3, :layer_2, :layer_3, SimpleGraph{Int64}(5, [[6], [7], [8], [9], [10], [1], [2], [3], [4], [5]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVert…</code></pre><p>Note that the (1,2) interlayer (i.e. the interlayer between layer (1,1) and layer (2,2)) is very similar to interlayer (2,1), but not identical: its adjacency matrix rows and columns are reordered. One may get interlayer (2,1) from interlayer (1,2) (i.e. one may get the <em>symmetric</em> interlayer of (1,2)) as follows</p><pre><code class="language-julia hljs">symmetric_interlayer = get_symmetric_interlayer(multilayergraph.interlayers[(1,2)])
symmetric_interlayer == multilayergraph.interlayers[(2,1)] </code></pre><pre><code class="language-nothing hljs">true</code></pre><p>You may access individual layers and interlayers with the &quot;dot&quot; notation:</p><pre><code class="language-julia hljs">multilayergraph.layer_1</code></pre><pre><code class="language-nothing hljs">Layer{Int64, Float64, SimpleGraph{Int64}}(:layer_1, SimpleGraph{Int64}(7, [[2, 3, 4, 5], [1, 4], [1, 5], [1, 2, 5], [1, 3, 4]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}}[])</code></pre><h4 id="Adjacency-Tensor"><a class="docs-heading-anchor" href="#Adjacency-Tensor">Adjacency Tensor</a><a id="Adjacency-Tensor-1"></a><a class="docs-heading-anchor-permalink" href="#Adjacency-Tensor" title="Permalink"></a></h4><p>The adjacency tensor is a 4-dimensional array</p><pre><code class="language-julia hljs">multilayergraph.adjacency_tensor</code></pre><pre><code class="language-nothing hljs">5×5×3×3 Array{Float64, 4}:
...</code></pre><p>The adjacency tensor is a 4-dimensional array. To understand its indexing, consider the following example</p><pre><code class="language-julia hljs">multilayergraph.adjacency_tensor[1,5,2,3]</code></pre><pre><code class="language-nothing hljs">0.0</code></pre><p>This means that there is an edge of zero weight between the vertex representing node 1 in layer 5 and the vertex representing node 2 in layer 3. It is a good time to note the difference between <em>nodes</em> and <em>vertices</em>. In the context of multilayer graphs, the vertices of every layer and interlayer represent the same set of nodes. That is, vertex 1 in layer (1,1) represents the same node as vertex 1 in layer (2,2) and so on. To make this distinction clearer the package implements the <code>MultilayerVertex</code> type, that represents vertices within the multilayer graph. The implementation of <code>MultilayerVertex</code> is</p><pre><code class="language-julia hljs">struct MultilayerVertex{T &lt;: Integer} &lt;: AbstractMultilayerVertex{T}
    node::T        # The node  the vertex represents
    layer::Symbol  # The layer the vertex belongs to
end</code></pre><p>To get the vertices of a <code>Layer</code> or an <code>Interlayer</code>, one may use Graphs.jl APIs</p><pre><code class="language-julia hljs">vertices(multilayergraph.layers[(1,1)])</code></pre><pre><code class="language-nothing hljs">5-element Vector{MultilayerVertex{Int64}}:
 MultilayerVertex{Int64}(1, :layer_1)
 MultilayerVertex{Int64}(2, :layer_1)
 MultilayerVertex{Int64}(3, :layer_1)
 MultilayerVertex{Int64}(4, :layer_1)
 MultilayerVertex{Int64}(5, :layer_1)</code></pre><pre><code class="language-julia hljs">vertices(multilayergraph.interlayers[(1,2)])</code></pre><pre><code class="language-nothing hljs">10-element Vector{Any}:
 MultilayerVertex{Int64}(1, :layer_1)
 MultilayerVertex{Int64}(2, :layer_1)
 MultilayerVertex{Int64}(3, :layer_1)
 MultilayerVertex{Int64}(4, :layer_1)
 MultilayerVertex{Int64}(5, :layer_1)
 MultilayerVertex{Int64}(1, :layer_2)
 MultilayerVertex{Int64}(2, :layer_2)
 MultilayerVertex{Int64}(3, :layer_2)
 MultilayerVertex{Int64}(4, :layer_2)
 MultilayerVertex{Int64}(5, :layer_2)</code></pre><p>To get a specific layer of a multilayer graph from its name, one may also write</p><pre><code class="language-julia hljs">layer_1 = get_layer(multilayergraph, :layer_1)</code></pre><p>Same for interlayers</p><pre><code class="language-julia hljs">interlayer_2_1 = get_layer(multilayergraph, :interlayer_layer_2_layer_1)</code></pre><p>Both <code>MultilayerGraph</code> and <code>MultilayerDiGraph</code> fully extend <code>Graphs.jl</code>, so they have access to Graphs.jl API as one would expect, just keeping in mind that vertices are <code>MultilayerVertex</code>s and not subtypes of <code>Integer</code> (<code>MultilayerVertex</code> is actually a subtype of <code>AbstractVertex</code> that this package defines, see <a href="#Future-Developments">Future Developments</a>), and that edges are <code>MultilayerEdge</code>s, which actually subtypes <code>AbstractEdge</code>.</p><p>Some notable examples are</p><pre><code class="language-julia hljs">edges(multilayergraph)</code></pre><pre><code class="language-nothing hljs">34-element Vector{MultilayerEdge}:
 MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(1, :layer_1), MultilayerVertex{Int64}(2, :layer_1), 1)
 MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(1, :layer_1), MultilayerVertex{Int64}(3, :layer_1), 1)
 MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(1, :layer_1), MultilayerVertex{Int64}(4, :layer_1), 1)
 MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(1, :layer_1), MultilayerVertex{Int64}(5, :layer_1), 1)
 MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(2, :layer_1), MultilayerVertex{Int64}(3, :layer_1), 1)
 MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(2, :layer_1), MultilayerVertex{Int64}(5, :layer_1), 1)
 MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(3, :layer_1), MultilayerVertex{Int64}(5, :layer_1), 1)
 MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(1, :layer_2), MultilayerVertex{Int64}(1, :layer_2), 0.7188425521261754)
 MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(2, :layer_2), MultilayerVertex{Int64}(3, :layer_2), 0.9012061650463197) 
 MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(2, :layer_2), MultilayerVertex{Int64}(4, :layer_2), 0.6163304419976594) 
 MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(3, :layer_2), MultilayerVertex{Int64}(5, :layer_2), 1.0046265072746847) 
 MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(1, :layer_3), MultilayerVertex{Int64}(2, :layer_3), 0.2819477742859873) 
 MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(2, :layer_3), MultilayerVertex{Int64}(4, :layer_3), 0.40111133874926597)
 MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(3, :layer_3), MultilayerVertex{Int64}(4, :layer_3), 0.9498077050078636) 
 MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(1, :layer_3), MultilayerVertex{Int64}(5, :layer_3), 0.9618455695308973) 
 ⋮</code></pre><p>The implementation of <code>MultilayerEdge</code> is</p><pre><code class="language-julia hljs">struct MultilayerEdge{ T &lt;: MultilayerVertex, U &lt;: Union{ &lt;: Real, Nothing}} &lt;: AbstractMultilayerEdge{T} # AbstractMultilayerEdge{T} subtypes AbstractEdge 
    src::T    # The source vertex
    dst::T    # The destination vertex
    weight::U # The edge weight. Can be `nothing` to signify an unweighted edge, or a Real
end</code></pre><h4 id="Other-Example-APIs"><a class="docs-heading-anchor" href="#Other-Example-APIs">Other Example APIs</a><a id="Other-Example-APIs-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Example-APIs" title="Permalink"></a></h4><p>Let&#39;s showcase some other key functionalities. </p><h5 id="Get-the-node-type"><a class="docs-heading-anchor" href="#Get-the-node-type">Get the node type</a><a id="Get-the-node-type-1"></a><a class="docs-heading-anchor-permalink" href="#Get-the-node-type" title="Permalink"></a></h5><pre><code class="language-julia hljs">eltype(multilayergraph)</code></pre><pre><code class="language-nothing hljs">Int64</code></pre><h5 id="Get-the-edge-type"><a class="docs-heading-anchor" href="#Get-the-edge-type">Get the edge type</a><a id="Get-the-edge-type-1"></a><a class="docs-heading-anchor-permalink" href="#Get-the-edge-type" title="Permalink"></a></h5><pre><code class="language-julia hljs">edgetype(multilayergraph)</code></pre><pre><code class="language-nothing hljs">MultilayerEdge{MultilayerVertex{Int64}, Float64}</code></pre><h5 id="Check-whether-an-edge-exists"><a class="docs-heading-anchor" href="#Check-whether-an-edge-exists">Check whether an edge exists</a><a id="Check-whether-an-edge-exists-1"></a><a class="docs-heading-anchor-permalink" href="#Check-whether-an-edge-exists" title="Permalink"></a></h5><pre><code class="language-julia hljs">has_edge(multilayergraph, MultilayerVertex(1, :layer_1), MultilayerVertex(4, :layer_2))</code></pre><pre><code class="language-nothing hljs">false</code></pre><h5 id="Remove-an-edge"><a class="docs-heading-anchor" href="#Remove-an-edge">Remove an edge</a><a id="Remove-an-edge-1"></a><a class="docs-heading-anchor-permalink" href="#Remove-an-edge" title="Permalink"></a></h5><p><code>rem_edge!</code> mimics the behaviour of the analogous function in Graphs.jl</p><pre><code class="language-julia hljs">rem_edge!(multilayergraph, MultilayerVertex(1, :layer_1), MultilayerVertex(2, :layer_2))</code></pre><pre><code class="language-nothing hljs">The multilayer doesn&#39;t have any edge between MultilayerVertex{Int64}(1, :layer_1) and MultilayerVertex{Int64}(2, :layer_2)
false</code></pre><p>The message tells us that the edge was already non existent. In fact, if we check the <code>adjacency_tensor</code> in the corresponding entry, we see that</p><pre><code class="language-julia hljs">multilayergraph.adjacency_tensor[1,2,1,2]</code></pre><pre><code class="language-nothing hljs">0.0</code></pre><h5 id="Add-an-edge"><a class="docs-heading-anchor" href="#Add-an-edge">Add an edge</a><a id="Add-an-edge-1"></a><a class="docs-heading-anchor-permalink" href="#Add-an-edge" title="Permalink"></a></h5><p>We may add an edge using the <code>add_edge!</code> function. Since the interlayer we are adding the edge has an unweighted underlying graph (we will say that the interlayer is unweighted), we have to add an unweighted edge, so we don&#39;t specify many weights after the vertices. The adjacency tensor will be updated with a <code>one(U)</code> in the correct position. <code>add_edge!</code> mimics the behaviour of the analogous function in Graphs.jl</p><pre><code class="language-julia hljs">add_edge!(multilayergraph, MultilayerVertex(1, :layer_1), MultilayerVertex(2, :layer_2))</code></pre><pre><code class="language-nothing hljs">true</code></pre><p>To add a weighted edge we just need to write</p><pre><code class="language-julia hljs">add_edge!(multilayergraph,  MultilayerEdge(MultilayerVertex(1, :layer_1), MultilayerVertex(2, :layer_3), 3.14))</code></pre><pre><code class="language-nothing hljs">true</code></pre><h5 id="Get-the-inneighbors"><a class="docs-heading-anchor" href="#Get-the-inneighbors">Get the inneighbors</a><a id="Get-the-inneighbors-1"></a><a class="docs-heading-anchor-permalink" href="#Get-the-inneighbors" title="Permalink"></a></h5><p>To get all the inneighbors of a vertex we just need to write </p><pre><code class="language-julia hljs">inneighbors(multilayergraph, MultilayerVertex(1, :layer_1))</code></pre><pre><code class="language-nothing hljs">8-element Vector{MultilayerVertex{Int64}}:
 MultilayerVertex{Int64}(2, :layer_1)
 MultilayerVertex{Int64}(3, :layer_1)
 MultilayerVertex{Int64}(4, :layer_1)
 MultilayerVertex{Int64}(5, :layer_1)
 MultilayerVertex{Int64}(1, :layer_3)
 MultilayerVertex{Int64}(2, :layer_3)
 MultilayerVertex{Int64}(4, :layer_3)
 MultilayerVertex{Int64}(5, :layer_3)</code></pre><p><a href="internals/#Graphs.outneighbors-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>outneighbors</code></a> would be analogous.</p><h5 id="Get-the-global-clustering-coefficient"><a class="docs-heading-anchor" href="#Get-the-global-clustering-coefficient">Get the global clustering coefficient</a><a id="Get-the-global-clustering-coefficient-1"></a><a class="docs-heading-anchor-permalink" href="#Get-the-global-clustering-coefficient" title="Permalink"></a></h5><pre><code class="language-julia hljs">multilayer_global_clustering_coefficient(multilayergraph)</code></pre><pre><code class="language-nothing hljs">0.12667622867320932</code></pre><p>Since our implementation of the global clustering coefficient follows <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a> rather than <code>Graphs.jl</code>&#39;s implementation, we did not override <code>Graphs.jl</code>&#39;s <code>global_clustering_coefficient</code>, which works on <code>MultilayerGraph</code> and <code>MultilayerDiGraph</code> but yields different results. For details, consult <code>?multilayer_global_clustering_coefficient</code> or read the comments in the source code.</p><h3 id="Multilayer-Specific-Functions-and-Analysis"><a class="docs-heading-anchor" href="#Multilayer-Specific-Functions-and-Analysis">Multilayer-Specific Functions and Analysis</a><a id="Multilayer-Specific-Functions-and-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Multilayer-Specific-Functions-and-Analysis" title="Permalink"></a></h3><p>The following functions are specific to multilayer graphs or their implementations radically differ from their monoplex counterparts. For more information on every function, please refer to <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a> or consult the associated docstrings.</p><h4 id="Overlay-Monoplex-Graph"><a class="docs-heading-anchor" href="#Overlay-Monoplex-Graph">Overlay Monoplex Graph</a><a id="Overlay-Monoplex-Graph-1"></a><a class="docs-heading-anchor-permalink" href="#Overlay-Monoplex-Graph" title="Permalink"></a></h4><p>Get the overlay monoplex graph: the monoplex graph whose nodes are the nodes of the multilayer graph and the edge between node <span>$i$</span> and node <span>$j$</span> has weight equal to the sum of all the weights of the edges between all vertex representations of <span>$i$</span> and <span>$j$</span> that belong to the same layer, for all the layers in the multilayer</p><pre><code class="language-julia hljs">get_overlay_monoplex_graph(multilayergraph)</code></pre><pre><code class="language-nothing hljs">{5, 8} undirected simple Int64 graph with Float64 weights</code></pre><h4 id="Depth-Weighted-Clustering-Coefficient"><a class="docs-heading-anchor" href="#Depth-Weighted-Clustering-Coefficient">Depth-Weighted Clustering Coefficient</a><a id="Depth-Weighted-Clustering-Coefficient-1"></a><a class="docs-heading-anchor-permalink" href="#Depth-Weighted-Clustering-Coefficient" title="Permalink"></a></h4><p>Get the global clustering coefficient where triplets are weighted by how many layers they span</p><pre><code class="language-julia hljs">w =  [1/3, 1/3, 1/3] 
multilayer_weighted_global_clustering_coefficient(multilayergraph,w)</code></pre><pre><code class="language-nothing hljs">0.12667622867320916</code></pre><p>The first component of <code>w</code> is the weight associated to triplets that are contained in one layer, the second component to triplets whose vertices are spread across exactly two layers, the third to triplets whose vertices are spread across exactly three layers. Weights must sum to `1.0 . When they are all equal (like in this example), the weighted global clustering coefficient coincides with the global clustering coefficient. </p><h4 id="Eigenvector-Centrality"><a class="docs-heading-anchor" href="#Eigenvector-Centrality">Eigenvector Centrality</a><a id="Eigenvector-Centrality-1"></a><a class="docs-heading-anchor-permalink" href="#Eigenvector-Centrality" title="Permalink"></a></h4><p>Calculated via an iterative algorithm, its normalization is different from the Graphs.jl implementation. See <code>?eigenvector_centrality</code> for further details and context.</p><pre><code class="language-julia hljs"># The returned values are: the eigenvector centrality and the relative error at each iteration, that is, the summed absolute values of the componentwise differences between the centrality computed at the current iteration minus the centrality computed at the previous iteration.
eig_centrality, errs = eigenvector_centrality(multilayergraph; norm = &quot;n&quot;, tol = 1e-3)</code></pre><pre><code class="language-nothing hljs">([0.260450377858897 0.02358226618172732 0.08408641909534659; 0.6517125919818912 0.646849109975291 0.25212976452498587; … ; 0.21160486454350666 0.24850764907380082 0.2809259415084613; 0.5089709123112656 0.27775286552140954 0.22663014660085468], [10.000000000000004, 0.7095737447337795, 0.329314405320397, 0.16256401870083886, 0.07860800793625616, 0.04125218689190476, 0.021191358681432643, 0.011056758224944913, 0.006831972142635288, 0.0035133270128280235, 0.0024675719418019056, 0.0013403531942171656, 0.0009739276503972424])</code></pre><h4 id="Modularity"><a class="docs-heading-anchor" href="#Modularity">Modularity</a><a id="Modularity-1"></a><a class="docs-heading-anchor-permalink" href="#Modularity" title="Permalink"></a></h4><p>Compute the modularity of the multilayer graph. The signature mimics the Graphs.jl <code>modularity</code> implementation</p><pre><code class="language-julia hljs">modularity(multilayergraph,
          rand([1, 2, 3, 4], length(nodes(multilayergraph)),length(multilayergraph.layers)) # communities
          )</code></pre><pre><code class="language-nothing hljs">-0.039890139283044884</code></pre><h4 id="Von-Neumann-Entropy"><a class="docs-heading-anchor" href="#Von-Neumann-Entropy">Von Neumann Entropy</a><a id="Von-Neumann-Entropy-1"></a><a class="docs-heading-anchor-permalink" href="#Von-Neumann-Entropy" title="Permalink"></a></h4><p>Compute the Von Neumann entropy as presented in <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>.</p><pre><code class="language-julia hljs">von_neumann_entropy(multilayergraph)</code></pre><pre><code class="language-nothing hljs">3.3980014398404834</code></pre><p>The Von Neumann entropy is currently available only for undirected multilayer graphs.</p><p>Other extended functions are: <a href="internals/#Graphs.is_directed-Tuple{In} where In&lt;:Interlayer"><code>is_directed</code></a>, <a href="internals/#Graphs.has_vertex-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>has_vertex</code></a>, <a href="internals/#Graphs.ne-Tuple{In} where In&lt;:Interlayer"><code>ne</code></a>, <a href="internals/#Graphs.nv-Tuple{In} where In&lt;:Interlayer"><code>nv</code></a>, <a href="internals/#Graphs.outneighbors-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>outneighbors</code></a>, <a href="@ref"><code>indegree</code></a>, <a href="@ref"><code>outdegree</code></a>, <a href="@ref"><code>degree</code></a>, <a href="internals/#MultilayerGraphs.mean_degree-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>mean_degree</code></a>, <a href="internals/#MultilayerGraphs.degree_second_moment-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>degree_second_moment</code></a>, <a href="internals/#MultilayerGraphs.degree_variance-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>degree_variance</code></a>, <a href="internals/#MultilayerGraphs.nn-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>nn</code></a>, <a href="internals/#MultilayerGraphs.nodes-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>nodes</code></a>.</p><h2 id="How-to-Contribute"><a class="docs-heading-anchor" href="#How-to-Contribute">How to Contribute</a><a id="How-to-Contribute-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-Contribute" title="Permalink"></a></h2><p>If you wish to change or add some functionality, please file an <a href="https://github.com/InPhyT/MultilayerGraphs.jl/issues">issue</a>. </p><h2 id="How-to-Cite"><a class="docs-heading-anchor" href="#How-to-Cite">How to Cite</a><a id="How-to-Cite-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-Cite" title="Permalink"></a></h2><p>If you use this package in your work, please cite this repository using the metadata in <a href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/main/CITATION.bib"><code>CITATION.bib</code></a>.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>De Domenico et al. (2013) <a href="https://doi.org/10.1103/PhysRevX.3.041022">Mathematical Formulation of Multilayer Networks</a>. <em>Physical Review X</em></p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Monday 15 August 2022 23:13">Monday 15 August 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
