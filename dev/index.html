<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MultilayerGraphs.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://InPhyT.github.io/MultilayerGraphs.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="MultilayerGraphs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>MultilayerGraphs.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Tutorial"><span>Tutorial</span></a></li><li><a class="tocitem" href="#How-to-Contribute"><span>How to Contribute</span></a></li><li><a class="tocitem" href="#How-to-Cite"><span>How to Cite</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><div style="width:100%; height:150px;border-width:4px;border-style:solid;padding-top:25px;
        border-color:#000;border-radius:10px;text-align:center;background-color:#B3D8FF;
        color:#000">
    <h3 style="color: black;">Star us on GitHub!</h3>
    <a class="github-button" href="https://github.com/InPhyT/MultilayerGraphs.jl" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star InPhyT/MultilayerGraphs.jl on GitHub" style="margin:auto">Star</a>
    <script async defer src="https://buttons.github.io/buttons.js"></script>
</div><h1 id="MultilayerGraphs.jl"><a class="docs-heading-anchor" href="#MultilayerGraphs.jl">MultilayerGraphs.jl</a><a id="MultilayerGraphs.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MultilayerGraphs.jl" title="Permalink"></a></h1><p><strong>MultilayerGraphs.jl</strong> is a Julia package for the construction, manipulation and analysis of multilayer graphs <a href="https://juliagraphs.org/Graphs.jl/dev/ecosystem/interface/">extending Graphs.jl</a>.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p><strong>MultilayerGraphs.jl</strong> implements the mathematical formulation of multilayer graphs proposed by <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>. It mainly revolves around two custom types, <a href="internals/#MultilayerGraphs.MultilayerGraph"><code>MultilayerGraph</code></a> and <a href="internals/#MultilayerGraphs.MultilayerDiGraph"><code>MultilayerDiGraph</code></a>, encoding undirected and directed multilayer graphs respectively.</p><p>Roughly speaking, a multilayer graph is a collection of <em>layers</em>, i.e. graphs whose vertices are representations of the same set of nodes, and <em>interlayers</em>, i.e the <a href="https://en.wikipedia.org/wiki/Bipartite_graph">bipartite graphs</a> whose vertices are those of any two layers and whose edges are those between vertices of the same two layers. See below for the distinction between ***nodes*** and ***vertices***.</p><p><a href="internals/#MultilayerGraphs.MultilayerGraph"><code>MultilayerGraph</code></a> and <a href="internals/#MultilayerGraphs.MultilayerDiGraph"><code>MultilayerDiGraph</code></a> are fully-fledged <a href="https://github.com/JuliaGraphs/Graphs.jl">Graphs.jl</a> extensions. Both structs are designed so that their layers and interlayers can be of any type (as long as they are Graphs.jl extensions themselves) and they need not be all of the same type. It is anyway required that all layers and interlayers of <a href="internals/#MultilayerGraphs.MultilayerGraph"><code>MultilayerGraph</code></a> and <a href="internals/#MultilayerGraphs.MultilayerDiGraph"><code>MultilayerDiGraph</code></a> are respectively undirected and directed. Directedness is checked via the <code>IsDirected</code> trait defined in Graphs.jl adopting <a href="https://github.com/mauro3/SimpleTraits.jl">SimpleTraits.jl</a>. Since the layers&#39; and interlayers&#39; graph types don&#39;t need to be the same, multilayer graph types are considered weighted graphs by default, and thus are assigned the trait <code>IsWeighted</code>.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>Press <code>]</code> in the Julia REPL and then</p><pre><code class="language-julia hljs">pkg&gt; add MultilayerGraphs</code></pre><h2 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h2><p>Here we illustrate how to define, handle and analyse a <a href="internals/#MultilayerGraphs.MultilayerGraph"><code>MultilayerGraph</code></a> (the directed version is completely analogous).</p><h3 id="Layers-and-Interlayers"><a class="docs-heading-anchor" href="#Layers-and-Interlayers">Layers and Interlayers</a><a id="Layers-and-Interlayers-1"></a><a class="docs-heading-anchor-permalink" href="#Layers-and-Interlayers" title="Permalink"></a></h3><p>Let&#39;s import some necessary packages</p><pre><code class="language-julia hljs"># Import necessary dependencies
using Graphs, SimpleWeightedGraphs, MultilayerGraphs</code></pre><p>We define some methods and constants that will prove useful later in the tutorial</p><pre><code class="language-julia hljs"># Set the number of nodes, minimum and maximum number of edges for random graphs
const n_nodes   = 5
const min_edges = n_nodes
const max_edges = 10

# Define methods generating random graphs
get_SimpleGraph()   = SimpleGraph(n_nodes, rand(min_edges:max_edges))   # Undirected graph
get_SimpleDiGraph() = SimpleDiGraph(n_nodes, rand(min_edges:max_edges)) # Directed graph

# Define variables for random weighted graphs
const simpleweightedgraph_sources      = 1:n_nodes
const simpleweightedgraph_destinations = rand(1:n_nodes, n_nodes)
const simpleweightedgraph_weights      = rand(n_nodes)

# Define methods generating random weighted graphs
get_SimpleWeightedGraph()   = SimpleWeightedGraph(simpleweightedgraph_sources, rand(1:n_nodes, n_nodes), rand(n_nodes))    # Undirected graph
get_SimpleWeightedDiGraph() = SimpleWeightedDiGraph(simpleweightedgraph_sources, rand(1:n_nodes, n_nodes), rand(n_nodes))  # Directed graph</code></pre><p>As said before, to define a multilayer graph we need to specify its layers and interlayers. We proceed by constructing a layer (see <a href="internals/#MultilayerGraphs.Layer"><code>Layer</code></a>)</p><pre><code class="language-julia hljs"># Construct a layer
layer = Layer(:layer_1, SimpleGraph(n_nodes, rand(min_edges:max_edges)); U = Float64)</code></pre><p>A <code>Layer</code> has a name (here <code>:layer_1</code>), an underlying graph (<code>SimpleGraph(n_nodes, rand(min_edges:max_edges))</code>) and a weight matrix <code>eltype</code> <code>U</code> (it defaults to the adjacency matrix&#39;s <code>eltype</code> if the graph is unweighted). To correctly specify a multilayer graph all layers and interlayers must have the same <code>U</code>, otherwise the multilayers&#39;s adjacency tensor would be poorly specified.</p><p>Notice that <code>U</code> does not need to coincide with the <code>eltype</code> of the adjacency matrix of the underlying graph: as far as we know, there is no way to set it explicitly for all Graphs.jl extensions, nor it is required for extensions to implement such feature, so our package converts to <code>U</code> the <code>eltype</code> of <code>Layer</code>s and <code>Interlayer</code>s weight (/adjacency) matrices every time they are invoked</p><pre><code class="language-julia hljs">adjacency_matrix(layers[1])</code></pre><pre><code class="language-nothing hljs">5×5 SparseMatrixCSC{Float64, Int64} with 16 stored entries:
  ⋅   1.0   ⋅   1.0  1.0
 1.0   ⋅   1.0  1.0   ⋅
  ⋅   1.0   ⋅   1.0  1.0
 1.0  1.0  1.0   ⋅   1.0
 1.0   ⋅   1.0  1.0   ⋅</code></pre><p>We may define more <code>Layer</code>s for future use</p><pre><code class="language-julia hljs">layers = [
            Layer(:layer_1, get_SimpleGraph(); U = Float64),
            Layer(:layer_2, get_SimpleWeightedGraph(); U = Float64),
            Layer(:layer_3, get_SimpleWeightedGraph(); U = Float64),
         ]</code></pre><p>There are other constructors for the <code>Layer</code> struct you may want to consult via <code>?Layer</code>.</p><p>We similarly define an interlayer (see <a href="internals/#MultilayerGraphs.Interlayer"><code>Interlayer</code></a>)</p><pre><code class="language-julia hljs">interlayer = Interlayer(n_nodes, :interlayer_layer_1_layer_2 , :layer_1, :layer_2, SimpleGraph{Int64}, rand(min_edges:max_edges); U = Float64)</code></pre><p>Here we used a constructor that returns a random <code>Interlayer</code>. Its arguments are the number of nodes <code>n_nodes</code>, the name of the <code>Interlayer</code> <code>interlayer_layer_1_layer_2</code>, the name of the <code>Layers</code> that it connects (<code>:layer_1</code> and <code>:layer_2</code>), the underlying graph type <code>SimpleGraph{Int64}</code>, and the number of edges <code>rand(min_edges:max_edges)</code> and the weight/adjacency matrix <code>eltype</code> again needs to be specified (although it may be left blank and the constructor will default to <code>eltype(adjacency_matrix(SimpleGraph{Int64}))</code>).</p><p>The adjacency matrix of an <code>Interlayer</code> is that of a bipartite graph</p><pre><code class="language-julia hljs">adjacency_matrix(interlayer)</code></pre><pre><code class="language-nothing hljs">10×10 SparseMatrixCSC{Float64, Int64} with 18 stored entries:
  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0
  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅   1.0  1.0   ⋅
  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅
  ⋅    ⋅    ⋅    ⋅    ⋅   1.0  1.0   ⋅    ⋅   1.0
  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅
  ⋅   1.0  1.0  1.0  1.0   ⋅    ⋅    ⋅    ⋅    ⋅
  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅
  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅
  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅
 1.0   ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅</code></pre><p>It is a 4 block matrix where the first <code>n_nodes</code> rows and columns refer to <code>:layer_1</code>&#39;s vertices, while the last <code>n_nodes</code> rows and columns refer to <code>:layer_2</code>&#39;s vertices.</p><p>We may define more <code>Interlayer</code>s for future use:</p><pre><code class="language-julia hljs">interlayers = [
                Interlayer(n_nodes, :interlayer_layer_1_layer_2, :layer_1, :layer_2, SimpleGraph{Int64}, rand(min_edges:max_edges); U = Float64),
                Interlayer(n_nodes, :interlayer_layer_1_layer_3, :layer_1, :layer_3, SimpleWeightedGraph{Int64,Float64}, rand(min_edges:max_edges))
              ]</code></pre><p>There are other constructors for the <code>Interlayer</code> struct you may want to consult via <code>?Interlayer</code>.</p><p><code>Layer</code>s and <code>Interlayer</code>s and complete extensions of Graphs.jl, so all methods in Graphs.jl should just work. The explicitly extended methods are <a href="internals/#Graphs.edges-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, In&lt;:Interlayer{T, U, G}}"><code>edges</code></a>, <a href="internals/#Base.eltype-Tuple{In} where In&lt;:Interlayer"><code>eltype</code></a>, <a href="internals/#Graphs.edgetype-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>edgetype</code></a>, <a href="internals/#Graphs.has_edge-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>has_edge</code></a>, <a href="internals/#Graphs.has_vertex-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>has_vertex</code></a>, <a href="internals/#Graphs.inneighbors-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>inneighbors</code></a>, <a href="internals/#Graphs.ne-Tuple{In} where In&lt;:Interlayer"><code>ne</code></a>, <a href="internals/#Graphs.nv-Tuple{In} where In&lt;:Interlayer"><code>nv</code></a>, <a href="internals/#Graphs.outneighbors-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>outneighbors</code></a>, <a href="internals/#Graphs.vertices-Tuple{In} where In&lt;:Interlayer"><code>vertices</code></a>, <a href="internals/#Graphs.is_directed-Tuple{In} where In&lt;:Interlayer"><code>is_directed</code></a>, <a href="internals/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, E}} where {T, U, G, In&lt;:Interlayer{T, U, G}, E&lt;:MultilayerEdge{MultilayerVertex{T}, Nothing}}"><code>add_edge!</code></a>, <a href="internals/#Graphs.SimpleGraphs.rem_edge!-Union{Tuple{V}, Tuple{In}, Tuple{U}, Tuple{T}, Tuple{In, V, V}} where {T, U, In&lt;:(Interlayer{T, U, G} where G&lt;:Graphs.AbstractGraph{T}), V&lt;:MultilayerVertex{T}}"><code>rem_edge!</code></a>.</p><h3 id="Instantiation-and-Handling-of-MultilayerGraph"><a class="docs-heading-anchor" href="#Instantiation-and-Handling-of-MultilayerGraph">Instantiation and Handling of <code>MultilayerGraph</code></a><a id="Instantiation-and-Handling-of-MultilayerGraph-1"></a><a class="docs-heading-anchor-permalink" href="#Instantiation-and-Handling-of-MultilayerGraph" title="Permalink"></a></h3><p>We can define a <code>MultilayerGraph</code> by specifying its layers and interlayers:</p><pre><code class="language-julia hljs">multilayergraph = MultilayerGraph(layers, interlayers; default_interlayer = &quot;multiplex&quot;)</code></pre><pre><code class="language-nothing hljs">MultilayerGraph{Int64, Float64}([0.0 1.0 … 1.0 1.0; 1.0 0.0 … 0.0 1.0; … ; 1.0 0.0 … 0.0 0.0; 1.0 1.0 … 0.0 0.0;;; 0.0 0.0 … 0.0 0.0; 0.0 1.0 …],...)</code></pre><p>It is not important that the <code>interlayers</code> array contains all the interlayers needed to specify the multilayer graph: the unspecified interlayers are automatically generated according to the <code>default_interlayer</code> argument. Right now only the <code>&quot;multiplex&quot;</code> value is supported, and will generate interlayers that have edges between pair of vertices of the two layers that represent the same node.</p><p>Notice that in the output the signature of <code>MultilayerGraph</code> has two parametric types, namely <code>MultilayerGraph{Int64, Float64}</code>. The first is referred to the node type, that just as in every <code>Graphs.jl</code> extension it is a subtype of <code>Integer</code>. The second parameter is instead the <code>eltype</code> of the equivalent of the adjacency matrix for multilayer graphs: the adjacency tensor (see below for more).</p><p>You may also specify random <code>MultilayerGraph</code></p><pre><code class="language-julia hljs">random_multilayergraph = MultilayerGraph( 3,         # Number of layers
                                          n_nodes,   # Number of nodes
                                          min_edges, # Minimum number of edges in each layer/interlayer
                                          max_edges, # Maximum number of edges in each layer/interlayer
                                          [
                                             SimpleGraph{Int64},
                                             SimpleWeightedGraph{Int64, Float64},
                                          ]          # The set of graph types to random draw from when constructing layers and interlayers
                                        )</code></pre><p>Alternatively, one may add layers and interlayers calling the <a href="internals/#MultilayerGraphs.add_layer!-Union{Tuple{L}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerDiGraph{T, U}, L&lt;:Layer{T, U, G}}"><code>add_layer!</code></a> and <a href="internals/#MultilayerGraphs.specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G&lt;:Graphs.AbstractGraph{T}, M&lt;:MultilayerDiGraph{T, U}, In&lt;:Interlayer{T, U, G}}"><code>specify_interlayer!</code></a> functions respectively, perhaps starting with an empty multilayer graph created with the constructor:</p><pre><code class="language-julia hljs">empty_multilayergraph  = MultilayerGraph( n_nodes, # Number of nodes
                                          Int64,   # Node type
                                          Float64  # Adjacency tensor&#39;s eltype, see below
                                        )</code></pre><p>Let&#39;s explore some properties of the <code>MultilayerGraph</code> struct.</p><h4 id="Layers"><a class="docs-heading-anchor" href="#Layers">Layers</a><a id="Layers-1"></a><a class="docs-heading-anchor-permalink" href="#Layers" title="Permalink"></a></h4><p>It is an <code>OrderedDict</code> where the keys are the layers&#39; indexes within the multilayer graph (the index is repeated twice in a tuple to be consistent with <code>multilayergraph.interlayers</code>&#39; keys, see below) and the values are the actual <code>Layer</code>s.</p><pre><code class="language-julia hljs">multilayergraph.layers</code></pre><pre><code class="language-nothing hljs">OrderedDict{Tuple{Int64, Int64}, Layer{Int64, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{Int64}}} with 3 entries:
  (1, 1) =&gt; Layer{Int64, Float64, SimpleGraph{Int64}}(:layer_1, SimpleGraph{Int64}(5, [[2, 4], [1, 3, 4], [2], [1, 2, 5], [4]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}}[])
  (2, 2) =&gt; Layer{Int64, Float64, SimpleWeightedGraph{Int64, Float64}}(:layer_2, {5, 4} undirected simple Int64 graph with Float64 weights, MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}}[])
  (3, 3) =&gt; Layer{Int64, Float64, SimpleWeightedGraph{Int64, Float64}}(:layer_3, {5, 4} undirected simple Int64 graph with Float64 weights, MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}}[])</code></pre><h4 id="Interlayers"><a class="docs-heading-anchor" href="#Interlayers">Interlayers</a><a id="Interlayers-1"></a><a class="docs-heading-anchor-permalink" href="#Interlayers" title="Permalink"></a></h4><p>It is an <code>OrderedDict</code> where each key is the pair of indexes of the layers that the corresponding value, i.e. the interlayer, connects within the multilayer graph</p><pre><code class="language-julia hljs">multilayergraph.interlayers</code></pre><pre><code class="language-nothing hljs">OrderedDict{Tuple{Int64, Int64}, Interlayer{Int64, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{Int64}}} with 6 entries:
  (2, 1) =&gt; Interlayer{Int64, Float64, SimpleGraph{Int64}}(:interlayer_layer_2_layer_1, :layer_2, :layer_1, SimpleGraph{Int64}(9, [[7, 8, 9, 10], [9], [7], [7], [6, 9], [5], [1, 3, 4], [1], [1, 2, 5], [1]]), MultilayerVertex{Int64}[], Tuple{MultilayerVerte…  
  (1, 2) =&gt; Interlayer{Int64, Float64, SimpleGraph{Int64}}(:interlayer_layer_1_layer_2, :layer_1, :layer_2, SimpleGraph{Int64}(9, [[10], [6, 8, 9], [6], [6, 7, 10], [6], [2, 3, 4, 5], [4], [2], [2], [1, 4]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64},…  
  (3, 1) =&gt; Interlayer{Int64, Float64, SimpleWeightedGraph{Int64, Float64}}(:interlayer_layer_3_layer_1, :layer_3, :layer_1, {10, 7} undirected simple Int64 graph with Float64 weights, MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVer…  
  (1, 3) =&gt; Interlayer{Int64, Float64, SimpleWeightedGraph{Int64, Float64}}(:interlayer_layer_1_layer_3, :layer_1, :layer_3, {10, 4} undirected simple Int64 graph with Float64 weights, MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}…  
  (3, 2) =&gt; Interlayer{Int64, Float64, SimpleGraph{Int64}}(:interlayer_layer_3_layer_2, :layer_3, :layer_2, SimpleGraph{Int64}(5, [[6], [7], [8], [9], [10], [1], [2], [3], [4], [5]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVert…  
  (2, 3) =&gt; Interlayer{Int64, Float64, SimpleGraph{Int64}}(:interlayer_layer_2_layer_3, :layer_2, :layer_3, SimpleGraph{Int64}(5, [[6], [7], [8], [9], [10], [1], [2], [3], [4], [5]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVert…</code></pre><p>Note that the (1,2) interlayer (i.e. the interlayer between layer (1,1) and layer (2,2)) is very similar to interlayer (2,1), but not identical: its adjacency matrix rows and columns are reordered. One may get interlayer (2,1) from interlayer (1,2) (i.e. one may get the <em>symmetric</em> interlayer of (1,2)) as follows</p><pre><code class="language-julia hljs">symmetric_interlayer = get_symmetric_interlayer(multilayergraph.interlayers[(1,2)])
symmetric_interlayer == multilayergraph.interlayers[(2,1)]</code></pre><pre><code class="language-nothing hljs">true</code></pre><p>You may access individual layers and interlayers with the &quot;dot&quot; notation:</p><pre><code class="language-julia hljs">multilayergraph.layer_1</code></pre><pre><code class="language-nothing hljs">Layer{Int64, Float64, SimpleGraph{Int64}}(:layer_1, SimpleGraph{Int64}(7, [[2, 3, 4, 5], [1, 4], [1, 5], [1, 2, 5], [1, 3, 4]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}}[])</code></pre><h4 id="Adjacency-Tensor"><a class="docs-heading-anchor" href="#Adjacency-Tensor">Adjacency Tensor</a><a id="Adjacency-Tensor-1"></a><a class="docs-heading-anchor-permalink" href="#Adjacency-Tensor" title="Permalink"></a></h4><p>The adjacency tensor is a 4-dimensional array</p><pre><code class="language-julia hljs">multilayergraph.adjacency_tensor</code></pre><pre><code class="language-nothing hljs">5×5×3×3 Array{Float64, 4}:
...</code></pre><p>To understand its indexing, consider the following example</p><pre><code class="language-julia hljs">multilayergraph.adjacency_tensor[1,5,2,3]</code></pre><pre><code class="language-nothing hljs">0.0</code></pre><p>This means that there is an edge of zero weight between the vertex representing node 1 in layer 5 and the vertex representing node 2 in layer 3. It is a good time to note the difference between <em>nodes</em> and <em>vertices</em>. In the context of multilayer graphs, the vertices of every layer and interlayer represent the same set of nodes. That is, vertex 1 in layer (1,1) represents the same node as vertex 1 in layer (2,2) and so on. To make this distinction clearer the package implements the <code>MultilayerVertex</code> type, that represents vertices within the multilayer graph. The implementation of <code>MultilayerVertex</code> is</p><pre><code class="language-julia hljs">struct MultilayerVertex{T &lt;: Integer} &lt;: AbstractMultilayerVertex{T}
    node::T        # The node  the vertex represents
    layer::Symbol  # The layer the vertex belongs to
end</code></pre><p>To get the vertices of a <code>Layer</code> or an <code>Interlayer</code>, one may use the Graphs.jl APIs</p><pre><code class="language-julia hljs">vertices(multilayergraph.layers[(1,1)])</code></pre><pre><code class="language-nothing hljs">5-element Vector{MultilayerVertex{Int64}}:
 MultilayerVertex{Int64}(1, :layer_1)
 MultilayerVertex{Int64}(2, :layer_1)
 MultilayerVertex{Int64}(3, :layer_1)
 MultilayerVertex{Int64}(4, :layer_1)
 MultilayerVertex{Int64}(5, :layer_1)</code></pre><pre><code class="language-julia hljs">vertices(multilayergraph.interlayers[(1,2)])</code></pre><pre><code class="language-nothing hljs">10-element Vector{Any}:
 MultilayerVertex{Int64}(1, :layer_1)
 MultilayerVertex{Int64}(2, :layer_1)
 MultilayerVertex{Int64}(3, :layer_1)
 MultilayerVertex{Int64}(4, :layer_1)
 MultilayerVertex{Int64}(5, :layer_1)
 MultilayerVertex{Int64}(1, :layer_2)
 MultilayerVertex{Int64}(2, :layer_2)
 MultilayerVertex{Int64}(3, :layer_2)
 MultilayerVertex{Int64}(4, :layer_2)
 MultilayerVertex{Int64}(5, :layer_2)</code></pre><p>To get a specific layer of a multilayer graph from its name, one may also write</p><pre><code class="language-julia hljs">layer_1 = get_layer(multilayergraph, :layer_1)</code></pre><p>Same for interlayers</p><pre><code class="language-julia hljs">interlayer_2_1 = get_layer(multilayergraph, :interlayer_layer_2_layer_1)</code></pre><p>Both <code>MultilayerGraph</code> and <code>MultilayerDiGraph</code> fully extend <code>Graphs.jl</code>, so they have access to Graphs.jl API as one would expect, just keeping in mind that vertices are <code>MultilayerVertex</code>s and not subtypes of <code>Integer</code> (<code>MultilayerVertex</code> is actually a subtype of <code>AbstractVertex</code> that this package defines, see <a href="#Future-Developments">Future Developments</a>), and that edges are <code>MultilayerEdge</code>s, which subtype <code>AbstractEdge</code>.</p><p>Some notable examples are</p><pre><code class="language-julia hljs">edges(multilayergraph)</code></pre><pre><code class="language-nothing hljs">34-element Vector{MultilayerEdge}:
 MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(1, :layer_1), MultilayerVertex{Int64}(2, :layer_1), 1)
 MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(1, :layer_1), MultilayerVertex{Int64}(3, :layer_1), 1)
 MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(1, :layer_1), MultilayerVertex{Int64}(4, :layer_1), 1)
 MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(1, :layer_1), MultilayerVertex{Int64}(5, :layer_1), 1)
 MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(2, :layer_1), MultilayerVertex{Int64}(3, :layer_1), 1)
 MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(2, :layer_1), MultilayerVertex{Int64}(5, :layer_1), 1)
 MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(3, :layer_1), MultilayerVertex{Int64}(5, :layer_1), 1)
 MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(1, :layer_2), MultilayerVertex{Int64}(1, :layer_2), 0.7188425521261754)
 MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(2, :layer_2), MultilayerVertex{Int64}(3, :layer_2), 0.9012061650463197)
 MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(2, :layer_2), MultilayerVertex{Int64}(4, :layer_2), 0.6163304419976594)
 MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(3, :layer_2), MultilayerVertex{Int64}(5, :layer_2), 1.0046265072746847)
 MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(1, :layer_3), MultilayerVertex{Int64}(2, :layer_3), 0.2819477742859873)
 MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(2, :layer_3), MultilayerVertex{Int64}(4, :layer_3), 0.40111133874926597)
 MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(3, :layer_3), MultilayerVertex{Int64}(4, :layer_3), 0.9498077050078636)
 MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(1, :layer_3), MultilayerVertex{Int64}(5, :layer_3), 0.9618455695308973)
 ⋮</code></pre><p>The implementation of <code>MultilayerEdge</code> is</p><pre><code class="language-julia hljs">struct MultilayerEdge{ T &lt;: MultilayerVertex, U &lt;: Union{ &lt;: Real, Nothing}} &lt;: AbstractMultilayerEdge{T} # AbstractMultilayerEdge{T} subtypes AbstractEdge
    src::T    # The source vertex
    dst::T    # The destination vertex
    weight::U # The edge weight. Can be `nothing` to signify an unweighted edge, or a Real
end</code></pre><h4 id="Other-Example-APIs"><a class="docs-heading-anchor" href="#Other-Example-APIs">Other Example APIs</a><a id="Other-Example-APIs-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Example-APIs" title="Permalink"></a></h4><p>Let&#39;s showcase some other key functionalities.</p><h5 id="Get-the-node-type"><a class="docs-heading-anchor" href="#Get-the-node-type">Get the node type</a><a id="Get-the-node-type-1"></a><a class="docs-heading-anchor-permalink" href="#Get-the-node-type" title="Permalink"></a></h5><pre><code class="language-julia hljs">eltype(multilayergraph)</code></pre><pre><code class="language-nothing hljs">Int64</code></pre><h5 id="Get-the-edge-type"><a class="docs-heading-anchor" href="#Get-the-edge-type">Get the edge type</a><a id="Get-the-edge-type-1"></a><a class="docs-heading-anchor-permalink" href="#Get-the-edge-type" title="Permalink"></a></h5><pre><code class="language-julia hljs">edgetype(multilayergraph)</code></pre><pre><code class="language-nothing hljs">MultilayerEdge{MultilayerVertex{Int64}, Float64}</code></pre><h5 id="Check-whether-an-edge-exists"><a class="docs-heading-anchor" href="#Check-whether-an-edge-exists">Check whether an edge exists</a><a id="Check-whether-an-edge-exists-1"></a><a class="docs-heading-anchor-permalink" href="#Check-whether-an-edge-exists" title="Permalink"></a></h5><pre><code class="language-julia hljs">has_edge(multilayergraph, MultilayerVertex(1, :layer_1), MultilayerVertex(4, :layer_2))</code></pre><pre><code class="language-nothing hljs">false</code></pre><h5 id="Remove-an-edge"><a class="docs-heading-anchor" href="#Remove-an-edge">Remove an edge</a><a id="Remove-an-edge-1"></a><a class="docs-heading-anchor-permalink" href="#Remove-an-edge" title="Permalink"></a></h5><p><code>rem_edge!</code> mimics the behaviour of the analogous function in Graphs.jl</p><pre><code class="language-julia hljs">rem_edge!(multilayergraph, MultilayerVertex(1, :layer_1), MultilayerVertex(2, :layer_2))</code></pre><pre><code class="language-nothing hljs">The multilayer doesn&#39;t have any edge between MultilayerVertex{Int64}(1, :layer_1) and MultilayerVertex{Int64}(2, :layer_2)
false</code></pre><p>The message tells us that the edge was already non existent. In fact, if we check the <code>adjacency_tensor</code> in the corresponding entry, we see that</p><pre><code class="language-julia hljs">multilayergraph.adjacency_tensor[1,2,1,2]</code></pre><pre><code class="language-nothing hljs">0.0</code></pre><h5 id="Add-an-edge"><a class="docs-heading-anchor" href="#Add-an-edge">Add an edge</a><a id="Add-an-edge-1"></a><a class="docs-heading-anchor-permalink" href="#Add-an-edge" title="Permalink"></a></h5><p>We may add an edge using the <code>add_edge!</code> function. Since the interlayer we are adding the edge has an unweighted underlying graph (we will say that the interlayer is unweighted), we have to add an unweighted edge, so we don&#39;t specify the weight after the vertices. The adjacency tensor will be updated with a <code>one(U)</code> in the correct position. <code>add_edge!</code> mimics the behaviour of the analogous function in Graphs.jl</p><pre><code class="language-julia hljs">add_edge!(multilayergraph, MultilayerVertex(1, :layer_1), MultilayerVertex(2, :layer_2))</code></pre><pre><code class="language-nothing hljs">true</code></pre><p>To add a weighted edge we just need to write</p><pre><code class="language-julia hljs">add_edge!(multilayergraph,  MultilayerEdge(MultilayerVertex(1, :layer_1), MultilayerVertex(2, :layer_3), 3.14))</code></pre><pre><code class="language-nothing hljs">true</code></pre><h5 id="Get-the-inneighbors"><a class="docs-heading-anchor" href="#Get-the-inneighbors">Get the inneighbors</a><a id="Get-the-inneighbors-1"></a><a class="docs-heading-anchor-permalink" href="#Get-the-inneighbors" title="Permalink"></a></h5><p>To get all the inneighbors of a vertex we just need to write</p><pre><code class="language-julia hljs">inneighbors(multilayergraph, MultilayerVertex(1, :layer_1))</code></pre><pre><code class="language-nothing hljs">8-element Vector{MultilayerVertex{Int64}}:
 MultilayerVertex{Int64}(2, :layer_1)
 MultilayerVertex{Int64}(3, :layer_1)
 MultilayerVertex{Int64}(4, :layer_1)
 MultilayerVertex{Int64}(5, :layer_1)
 MultilayerVertex{Int64}(1, :layer_3)
 MultilayerVertex{Int64}(2, :layer_3)
 MultilayerVertex{Int64}(4, :layer_3)
 MultilayerVertex{Int64}(5, :layer_3)</code></pre><p><a href="internals/#Graphs.outneighbors-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>outneighbors</code></a> would be analogous.</p><h5 id="Get-the-global-clustering-coefficient"><a class="docs-heading-anchor" href="#Get-the-global-clustering-coefficient">Get the global clustering coefficient</a><a id="Get-the-global-clustering-coefficient-1"></a><a class="docs-heading-anchor-permalink" href="#Get-the-global-clustering-coefficient" title="Permalink"></a></h5><pre><code class="language-julia hljs">multilayer_global_clustering_coefficient(multilayergraph)</code></pre><pre><code class="language-nothing hljs">0.12667622867320932</code></pre><p>Since our implementation of the global clustering coefficient follows <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a> rather than <code>Graphs.jl</code>&#39;s implementation, we did not override <code>Graphs.jl</code>&#39;s <code>global_clustering_coefficient</code>, which works on <code>MultilayerGraph</code> and <code>MultilayerDiGraph</code> but yields different results. For details, consult <code>?multilayer_global_clustering_coefficient</code> or read the comments in the source code.</p><h3 id="Multilayer-Specific-Functions-and-Analysis"><a class="docs-heading-anchor" href="#Multilayer-Specific-Functions-and-Analysis">Multilayer-Specific Functions and Analysis</a><a id="Multilayer-Specific-Functions-and-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Multilayer-Specific-Functions-and-Analysis" title="Permalink"></a></h3><p>The following functions are specific to multilayer graphs or their implementations radically differ from their monoplex counterparts. For more information on every function, please refer to <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a> or consult the associated docstrings.</p><h4 id="Overlay-Monoplex-Graph"><a class="docs-heading-anchor" href="#Overlay-Monoplex-Graph">Overlay Monoplex Graph</a><a id="Overlay-Monoplex-Graph-1"></a><a class="docs-heading-anchor-permalink" href="#Overlay-Monoplex-Graph" title="Permalink"></a></h4><p>Get the overlay monoplex graph: the monoplex graph whose nodes are the nodes of the multilayer graph and the edge between node <span>$i$</span> and node <span>$j$</span> has weight equal to the sum of all the weights of the edges between all vertex representations of <span>$i$</span> and <span>$j$</span> that belong to the same layer, for all the layers in the multilayer</p><pre><code class="language-julia hljs">get_overlay_monoplex_graph(multilayergraph)</code></pre><pre><code class="language-nothing hljs">{5, 8} undirected simple Int64 graph with Float64 weights</code></pre><h4 id="Depth-Weighted-Clustering-Coefficient"><a class="docs-heading-anchor" href="#Depth-Weighted-Clustering-Coefficient">Depth-Weighted Clustering Coefficient</a><a id="Depth-Weighted-Clustering-Coefficient-1"></a><a class="docs-heading-anchor-permalink" href="#Depth-Weighted-Clustering-Coefficient" title="Permalink"></a></h4><p>Get the global clustering coefficient where triplets are weighted by how many layers they span</p><pre><code class="language-julia hljs">w =  [1/3, 1/3, 1/3]
multilayer_weighted_global_clustering_coefficient(multilayergraph,w)</code></pre><pre><code class="language-nothing hljs">0.12667622867320916</code></pre><p>The first component of <code>w</code> is the weight associated to triplets that are contained in one layer, the second component to triplets whose vertices are spread across exactly two layers, the third to triplets whose vertices are spread across exactly three layers. Weights must sum to <code>1.0</code>. When they are all equal (like in this example), the weighted global clustering coefficient coincides with the global clustering coefficient.</p><h4 id="Eigenvector-Centrality"><a class="docs-heading-anchor" href="#Eigenvector-Centrality">Eigenvector Centrality</a><a id="Eigenvector-Centrality-1"></a><a class="docs-heading-anchor-permalink" href="#Eigenvector-Centrality" title="Permalink"></a></h4><p>Calculated via an iterative algorithm, its normalization is different from the Graphs.jl implementation. See <code>?eigenvector_centrality</code> for further details and context.</p><pre><code class="language-julia hljs"># The returned values are: the eigenvector centrality and the relative error at each iteration, that is, the summed absolute values of the componentwise differences between the centrality computed at the current iteration minus the centrality computed at the previous iteration.
eig_centrality, errs = eigenvector_centrality(multilayergraph; norm = &quot;n&quot;, tol = 1e-3)</code></pre><pre><code class="language-nothing hljs">([0.260450377858897 0.02358226618172732 0.08408641909534659; 0.6517125919818912 0.646849109975291 0.25212976452498587; … ; 0.21160486454350666 0.24850764907380082 0.2809259415084613; 0.5089709123112656 0.27775286552140954 0.22663014660085468], [10.000000000000004, 0.7095737447337795, 0.329314405320397, 0.16256401870083886, 0.07860800793625616, 0.04125218689190476, 0.021191358681432643, 0.011056758224944913, 0.006831972142635288, 0.0035133270128280235, 0.0024675719418019056, 0.0013403531942171656, 0.0009739276503972424])</code></pre><h4 id="Modularity"><a class="docs-heading-anchor" href="#Modularity">Modularity</a><a id="Modularity-1"></a><a class="docs-heading-anchor-permalink" href="#Modularity" title="Permalink"></a></h4><p>Compute the modularity of the multilayer graph. The signature mimics the Graphs.jl <code>modularity</code> implementation</p><pre><code class="language-julia hljs">modularity(multilayergraph,
          rand([1, 2, 3, 4], length(nodes(multilayergraph)),length(multilayergraph.layers)) # communities
          )</code></pre><pre><code class="language-nothing hljs">-0.039890139283044884</code></pre><h4 id="Von-Neumann-Entropy"><a class="docs-heading-anchor" href="#Von-Neumann-Entropy">Von Neumann Entropy</a><a id="Von-Neumann-Entropy-1"></a><a class="docs-heading-anchor-permalink" href="#Von-Neumann-Entropy" title="Permalink"></a></h4><p>Compute the Von Neumann entropy as presented in <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a></p><pre><code class="language-julia hljs">von_neumann_entropy(multilayergraph)</code></pre><pre><code class="language-nothing hljs">3.3980014398404834</code></pre><p>The Von Neumann entropy is currently available only for undirected multilayer graphs.</p><p>Other extended functions are: <a href="internals/#Graphs.is_directed-Tuple{In} where In&lt;:Interlayer"><code>is_directed</code></a>, <a href="internals/#Graphs.has_vertex-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>has_vertex</code></a>, <a href="internals/#Graphs.ne-Tuple{In} where In&lt;:Interlayer"><code>ne</code></a>, <a href="internals/#Graphs.nv-Tuple{In} where In&lt;:Interlayer"><code>nv</code></a>, <a href="internals/#Graphs.outneighbors-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>outneighbors</code></a>, <a href="internals/#Graphs.indegree-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, AbstractVector{V}}} where {T, M&lt;:(AbstractMultilayerGraph{T}), V&lt;:MultilayerVertex{T}}"><code>indegree</code></a>, <a href="internals/#Graphs.outdegree-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, AbstractVector{V}}} where {T, M&lt;:(AbstractMultilayerGraph{T}), V&lt;:MultilayerVertex{T}}"><code>outdegree</code></a>, <a href="internals/#Graphs.degree-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, AbstractVector{V}}} where {T, M&lt;:(AbstractMultilayerGraph{T}), V&lt;:MultilayerVertex{T}}"><code>degree</code></a>, <a href="internals/#MultilayerGraphs.mean_degree-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>mean_degree</code></a>, <a href="internals/#MultilayerGraphs.degree_second_moment-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>degree_second_moment</code></a>, <a href="internals/#MultilayerGraphs.degree_variance-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>degree_variance</code></a>, <a href="internals/#MultilayerGraphs.nn-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>nn</code></a>, <a href="internals/#MultilayerGraphs.nodes-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>nodes</code></a>.</p><h2 id="How-to-Contribute"><a class="docs-heading-anchor" href="#How-to-Contribute">How to Contribute</a><a id="How-to-Contribute-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-Contribute" title="Permalink"></a></h2><p>The package is currently under development and further steps would benefit enormously from the precious feedback of the <a href="https://github.com/orgs/JuliaGraphs/people">JuliaGraph people</a>, graph theorists, network scientists and all the users who might have general questions or suggestions. </p><p>Therefore feel free to open <a href="https://github.com/InPhyT/MultilayerGraphs.jl/discussions">discussions</a>, <a href="https://github.com/InPhyT/MultilayerGraphs.jl/issues">issues</a> or <a href="https://github.com/InPhyT/MultilayerGraphs.jl/pulls">PRs</a>. They are very welcome!   </p><h2 id="How-to-Cite"><a class="docs-heading-anchor" href="#How-to-Cite">How to Cite</a><a id="How-to-Cite-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-Cite" title="Permalink"></a></h2><p>If you use this package in your work, please cite this repository using the metadata in <a href="https://github.com/InPhyT/MultilayerGraphs.jl/blob/main/CITATION.bib"><code>CITATION.bib</code></a>.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>De Domenico et al. (2013) <a href="https://doi.org/10.1103/PhysRevX.3.041022">Mathematical Formulation of Multilayer Networks</a>. <em>Physical Review X</em>.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Friday 19 August 2022 20:40">Friday 19 August 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
