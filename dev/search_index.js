var documenterSearchIndex = {"docs":
[{"location":"API_organized/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API_organized/","page":"API","title":"API","text":"This page provides a list of exported methods organized by topic and audience. Methods that act on vertices, edges, and layers are grouped together. Some methods are intended for developers who want to use the Graphs.jl library as part of their code, while others are meant for end-users. hello","category":"page"},{"location":"API_organized/#End-User","page":"API","title":"End-User","text":"","category":"section"},{"location":"API_organized/#nodes_eu","page":"API","title":"Nodes","text":"","category":"section"},{"location":"API_organized/","page":"API","title":"API","text":"Node\nid","category":"page"},{"location":"API_organized/#MultilayerGraphs.Node","page":"API","title":"MultilayerGraphs.Node","text":"Node <: AbstractNode\n\nA custom concrete type representing a node of a multilayer graph.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs.id","page":"API","title":"MultilayerGraphs.id","text":"id(n::Node)\n\nReturn the id of n.\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#vertices_eu","page":"API","title":"Vertices","text":"","category":"section"},{"location":"API_organized/","page":"API","title":"API","text":"eltype\nMultilayerVertex\nMV\nnode\nlayer\nmetadata(mv::MultilayerVertex)\nMissingVertex","category":"page"},{"location":"API_organized/#Base.eltype","page":"API","title":"Base.eltype","text":"Base.eltype(subgraph::AbstractSubGraph)\n\nReturn the vertex type of subgraph.\n\n\n\n\n\neltype(::M) where {T,M<:AbstractMultilayerGraph{T}}\n\nReturn the vertex type of mg.\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.MultilayerVertex","page":"API","title":"MultilayerGraphs.MultilayerVertex","text":"MultilayerVertex{N <: Integer} <: AbstractMultilayerVertex{N}\n\nA struct representing a vertex of a MultilayerGraph.\n\nFIELDS\n\nnode::Node: the Node that the MultilayerVertex represents;\nlayer::Union{Nothing, Symbol}: the name of the Layer the MultilayerVertex lies in;\nmetadata::Union{<: NamedTuple, <: Tuple}: the metadata associated to this MultilayerVertex.\n\nCONSTRUCTORS\n\nMultilayerVertex(node::Node, layer::Union{Nothing, Symbol},  metadata::Union{<: NamedTuple, <: Tuple})\n\nConstructs a MultilayerVertex representing Node node in Layer with metadata metadata.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs.node","page":"API","title":"MultilayerGraphs.node","text":"node(mv::MultilayerVertex)\n\nReturns the Node represented by mv.\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.layer","page":"API","title":"MultilayerGraphs.layer","text":"layer(mv::MultilayerVertex)\n\nReturn the name of the layer which the MultilayerVertex belongs to.\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.metadata-Tuple{MultilayerVertex}","page":"API","title":"MultilayerGraphs.metadata","text":"metadata(mv::MultilayerVertex)\n\nReturn the metadata associated to mv.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.MissingVertex","page":"API","title":"MultilayerGraphs.MissingVertex","text":"MissingVertex\n\nA mutable struct that acts as a placeholder for a vertex that is missing in a Layer. It is mutable so that it may be added more than once to the Bijections struct from Bijections.jl.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#edges_eu","page":"API","title":"Edges","text":"","category":"section"},{"location":"API_organized/","page":"API","title":"API","text":"MultilayerEdge\nME\nweight(e::AbstractMultilayerEdge)\nmetadata(e::AbstractMultilayerEdge)","category":"page"},{"location":"API_organized/#MultilayerGraphs.MultilayerEdge","page":"API","title":"MultilayerGraphs.MultilayerEdge","text":"struct MultilayerEdge{ T <: MultilayerVertex, U <: Union{ <: Real, Nothing}} <: AbstractMultilayerEdge{T}\n\nDefault concrete subtype of AbstractMultilayerEdge.\n\nFIELDS\n\nsrc::T: the source vertex of the edge;\ndst::T: the destination vertex of the edge;\nweight::U: the edge weight.\n\nCONSTRUCTORS\n\nMultilayerEdge(src::T, dst::T, weight::U) where { T <: MultilayerVertex, U <: Union{ <: Real, Nothing}}\n\nDefault constructor.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs.ME","page":"API","title":"MultilayerGraphs.ME","text":"ME\n\nShorter alias for MultilayerEdge.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#SimpleWeightedGraphs.weight-Tuple{AbstractMultilayerEdge}","page":"API","title":"SimpleWeightedGraphs.weight","text":"weight(e::AbstractMultilayerEdge)\n\nReturn the weight of e.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.metadata-Tuple{AbstractMultilayerEdge}","page":"API","title":"MultilayerGraphs.metadata","text":"metadata(e::AbstractMultilayerEdge)\n\nReturn the metadata of e.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#subgraphs_eu","page":"API","title":"Subgraphs","text":"","category":"section"},{"location":"API_organized/","page":"API","title":"API","text":"Layer{T <: Integer, U <: Real, G <: AbstractGraph{T}}\nLayer(\n    name::Symbol, \n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}, \n    edge_list::Union{Vector{<:MultilayerEdge},Vector{NTuple{2,MultilayerVertex{nothing}}}}, \n    null_graph::G, \n    weighttype::Type{U}; \n    default_vertex_metadata::Function = mv -> NamedTuple(), \n    default_edge_weight::Function = (src, dst) -> one(U), \n    default_edge_metadata::Function = (src, dst) -> NamedTuple()\n) where {T <: Integer, U <: Real, G <: AbstractGraph{T}}\n\nLayer(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    ne::Int64,\n    null_graph::G,\n    weighttype::Type{U};\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_weight::Function = (src, dst) -> nothing,\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    allow_self_loops::Bool = false\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nlayer_simplegraph\nlayer_simpledigraph\nlayer_simpleweightedgraph\nlayer_simpleweighteddigraph\nlayer_metadigraph\nlayer_valgraph\nlayer_valoutdigraph\nlayer_valdigraph\nlayer_metagraph\n\nhas_node(layer::Layer, n::Node)\nadd_vertex!(layer::Layer, mv::MultilayerVertex)\nadd_vertex!(layer::L, n::Node, args...; kwargs...) where {T, L <: Layer{T}} \nrem_vertex!(layer::Layer, mv::MultilayerVertex)\nrem_vertex!(layer::Layer, n::Node)\n\nInterlayer{T<:Integer,U<:Real,G<:AbstractGraph{T}}\nInterlayer(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    null_graph::G,\n    edge_list::Vector{ <: MultilayerEdge{<: Union{U, Nothing}}};\n    default_edge_weight::Function = (x,y) -> nothing,\n    default_edge_metadata::Function = (x,y) -> NamedTuple(),\n    transfer_vertex_metadata::Bool = false,\n    name::Symbol = Symbol(\"interlayer_$(layer_1.name)_$(layer_2.name)\")\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\n\nInterlayer(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    ne::Int64,\n    null_graph::G;\n    default_edge_weight::Function = (x,y) -> nothing,\n    default_edge_metadata::Function = (x,y) -> NamedTuple(),\n    name::Symbol = Symbol(\"interlayer_$(layer_1.name)_$(layer_2.name)\"),\n    transfer_vertex_metadata::Bool = false\n) where {T<:Integer, U <: Union{Nothing, <: Real},  G<:AbstractGraph{T}}\n\ninterlayer_simplegraph\ninterlayer_simpleweightedgraph\ninterlayer_metagraph\ninterlayer_valgraph\ninterlayer_simpledigraph\ninterlayer_simpleweighteddigraph\ninterlayer_metadigraph\ninterlayer_valoutdigraph\ninterlayer_valdigraph\n\n\nmultiplex_interlayer(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    null_graph::G;\n    default_edge_weight::Function = (x,y) -> nothing,\n    default_edge_metadata::Function = (x,y) -> NamedTuple(),\n    transfer_vertex_metadata::Bool = false,\n    name::Symbol = Symbol(\"interlayer_$(layer_1.name)_$(layer_2.name)\")\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\n\nempty_interlayer(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    null_graph::G;\n    default_edge_weight::Function = (x,y) -> nothing,\n    default_edge_metadata::Function = (x,y) -> NamedTuple(),\n    name::Symbol = Symbol(\"interlayer_$(layer_1.name)_$(layer_2.name)\"),\n    transfer_vertex_metadata::Bool = false\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nnodes(subgraph::AbstractSubGraph)\nhas_vertex(layer::Layer, mv::MultilayerVertex)\nhas_vertex(interlayer::Interlayer, mv::MultilayerVertex)\nnv(subgraph::AbstractSubGraph)\nmv_vertices(subgraph::AbstractSubGraph)\nmv_inneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\nmv_outneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\nmv_neighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\nhas_edge(subgraph::AbstractSubGraph,me::MultilayerEdge)\nhas_edge( subgraph::AbstractSubGraph, s::MultilayerVertex, d::MultilayerVertex)\nhas_edge( layer::Layer, s::MultilayerVertex{nothing}, d::MultilayerVertex{nothing})\nne(subgraph::AbstractSubGraph)\nedges(subgraph::S) where {T,U,S<:AbstractSubGraph{T,U}} \nadd_edge!( subgraph::S, me::E) where {T,U<:Real,S<:AbstractSubGraph{T,U},E<:MultilayerEdge{ <: Union{U, Nothing}}}\nadd_edge!(layer::Layer, src::MultilayerVertex, dst::MultilayerVertex, args...; kwargs...)\nadd_edge!(interlayer::Interlayer, src::MultilayerVertex, dst::MultilayerVertex, args...; kwargs...)\nrem_edge!(subgraph::AbstractSubGraph, src::MultilayerVertex, dst::MultilayerVertex)\nrem_edge!(subgraph::AbstractSubGraph, me::MultilayerEdge)\nget_metadata(subgraph::AbstractSubGraph, bare_mv::MultilayerVertex)\nget_metadata(subgraph::AbstractSubGraph, src::MultilayerVertex, dst::MultilayerVertex)\nget_weight(subgraph::AbstractSubGraph, src::MultilayerVertex, dst::MultilayerVertex) \nis_directed(subgraph::AbstractSubGraph)\nis_directed(::Type{S}) where {T,U,G,S <: AbstractSubGraph{T,U,G}}\nadjacency_matrix(subgraph::AbstractSubGraph)\nMultilayerGraphs.weights(subgraph::S) where {T,U,S<:AbstractSubGraph{T,U}}\n\nis_multiplex_interlayer(interlayer::Interlayer)\n\nget_symmetric_interlayer(\n    interlayer::In;\n    symmetric_interlayer_name::String = String(interlayer.name) * \"_rev\"\n) where {T,U,G,In<:Interlayer{T,U,G}}\n\nname(subgraph::AbstractSubGraph)\ngraph(subgraph::AbstractSubGraph)","category":"page"},{"location":"API_organized/#MultilayerGraphs.Layer","page":"API","title":"MultilayerGraphs.Layer","text":"mutable struct Layer{T <: Integer, U <: Real, G <: AbstractGraph{T}} <: AbstractLayer{T,U,G}\n\nRepresents a layer in a Multilayer(Di)Graph. Its type hierarchy is: Layer <: AbstractLayer <: AbstractSubGraph .\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Symbol, Union{Vector{MultilayerVertex{nothing}}, Vector{Node}}, Union{Vector{Tuple{MultilayerVertex{nothing}, MultilayerVertex{nothing}}}, Vector{<:MultilayerEdge}}, G, Type{U}}} where {T<:Integer, U<:Real, G<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.Layer","text":"Layer(\n    name::Symbol, \n    vertices::Vector{<: MultilayerVertex}, \n    edge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}, \n    null_graph::G, \n    weighttype::Type{U};  \n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_weight::Function = (src, dst) -> one(U), d\n    default_edge_metadata::Function = (src, dst) -> NamedTuple()) where {T <: Integer, U <: Real,  G <: AbstractGraph{T}}\n\nConstructor for Layer.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nedge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\nnull_graph::G: the Layer's underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown;\nweighttype::Type{U}: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Symbol, Union{Vector{MultilayerVertex{nothing}}, Vector{Node}}, Int64, G, Type{U}}} where {T<:Integer, U<:Real, G<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.Layer","text":"Layer(\n    name::Symbol,\n    vertices::Union{V, N},\n    ne::Int64,\n    null_graph::G,\n    weighttype::Type{U};\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_weight::Function = (src, dst) -> nothing,\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    allow_self_loops::Bool = false\n) where {T<:Integer,U<:Real,G<:AbstractGraph{T}, V <: Vector{MultilayerVertex{nothing}}, N <: Vector{Node}}\n\nReturn a random Layer.\n\nARGUMENTS\n\nvertices::Union{V, N}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nname::Symbol: The name of the Layer\nne::Int64: The number of edges of the Layer\nnull_graph::G: the Layer's underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.\nweighttype::Type{U}: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted);\n\nKWARGS\n\n-default_vertex_metadata::Function: Function that takes a MultilayerVertex and returns a Tuple or a NamedTuple containing the vertex metadata. defaults to mv -> NamedTuple();\n\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\nallow_self_loops::Bool: whether to allow self loops to be generated or not. Defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.layer_simplegraph","page":"API","title":"MultilayerGraphs.layer_simplegraph","text":"layer_simplegraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    edge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nConstructor for a Layer whose underlying graph is a SimpleGraph from Graphs.jl.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nedge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\nlayer_simplegraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    degree_distribution::UnivariateDistribution;\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nConstructor for a Layer whose underlying graph is a SimpleGraph from Graphs.jl with a degree sequence sampled from degree_distribution. Realization is performed via the Havel-Hakimi algorithm.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\ndegree_distribution::UnivariateDistribution: The degree distribution from which the degree sequence is sampled ;\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\nlayer_simplegraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    ne::Int64;\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nReturn a random Layer with ne edges whose underlying graph is a SimpleGraph from Graphs.jl with a degree sequence sampled from degree_distribution. Realization is performed via the Havel-Hakimi algorithm.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nne::Int64: The number of edges of the Layer;\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.layer_simpledigraph","page":"API","title":"MultilayerGraphs.layer_simpledigraph","text":"layer_simpledigraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    edge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nConstructor for a Layer whose underlying graph is a SimpleDiGraph from Graphs.jl.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nedge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\nlayer_simpledigraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    indegree_distribution::UnivariateDistribution,\n    outdegree_distribution::UnivariateDistribution;\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nConstructor for a Layer whose underlying graph is a SimplDiGraph{vertextype} from Graphs.jl with a indegree and outdegree sequences respectively sampled from indegree_distribution and outdegree_distribution. Realization is performed via the Kleitman-Wang algorithm.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nindegree_distribution::UnivariateDistribution: The degree distribution from which the indegree sequence is sampled ;\noutdegree_distribution::UnivariateDistribution: The degree distribution from which the outdegree sequence is sampled ;\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\nlayer_simpledigraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    ne::Int64;\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nReturn a random Layer with ne edges whose underlying graph is a SimplDiGraph{vertextype} from Graphs.jl with a indegree and outdegree sequences respectively sampled from indegree_distribution and outdegree_distribution. Realization is performed via the Kleitman-Wang algorithm.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nne::Int64: The number of edges of the Layer;\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.layer_simpleweightedgraph","page":"API","title":"MultilayerGraphs.layer_simpleweightedgraph","text":"layer_simpleweightedgraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    edge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};\n    default_edge_weight::Function = (src,dst) -> nothing,\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nConstructor for a Layer whose underlying graph is a SimpleWeightedGraph from SimpleWeightedGraphs.jl.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nedge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\nlayer_simpleweightedgraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    degree_distribution::UnivariateDistribution;\n    default_edge_weight::Function = (src,dst) -> nothing,\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nConstructor for a Layer whose underlying graph is a SimpleWeightedGraph from SimpleWeightedGraphs.jl. with a degree sequence sampled from degree_distribution. Realization is performed via the Havel-Hakimi algorithm.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\ndegree_distribution::UnivariateDistribution: The degree distribution from which the degree sequence is sampled ;\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\nlayer_simpleweightedgraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    ne::Int64;\n    default_edge_weight::Function = (src,dst) -> nothing,\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nReturn a random Layer with ne edges whose underlying graph is a SimpleWeightedGraph from SimpleWeightedGraphs.jl. with a degree sequence sampled from degree_distribution. Realization is performed via the Havel-Hakimi algorithm.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nne::Int64: The number of edges of the Layer;\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.layer_simpleweighteddigraph","page":"API","title":"MultilayerGraphs.layer_simpleweighteddigraph","text":"layer_simpleweighteddigraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    edge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};\n    default_edge_weight::Function = (src,dst) -> nothing,\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nConstructor for a Layer whose underlying graph is a SimpleWeightedDiGraph from SimpleWeightedGraphs.jl.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nedge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\nlayer_simpleweighteddigraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    indegree_distribution::UnivariateDistribution,\n    outdegree_distribution::UnivariateDistribution;\n    default_edge_weight::Function = (src,dst) -> nothing,\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nConstructor for a Layer whose underlying graph is a SimpleWeightedDiGraph from SimpleWeightedGraphs.jl, with a indegree and outdegree sequences respectively sampled from indegree_distribution and outdegree_distribution. Realization is performed via the Kleitman-Wang algorithm.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nindegree_distribution::UnivariateDistribution: The degree distribution from which the indegree sequence is sampled ;\noutdegree_distribution::UnivariateDistribution: The degree distribution from which the outdegree sequence is sampled ;\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\nlayer_simpleweighteddigraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    ne::Int64;\n    default_edge_weight::Function = (src,dst) -> nothing,\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nReturn a random Layer with ne edges whose underlying graph is a SimpleWeightedDiGraph from SimpleWeightedGraphs.jl, with a indegree and outdegree sequences respectively sampled from indegree_distribution and outdegree_distribution. Realization is performed via the Kleitman-Wang algorithm.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nne::Int64: The number of edges of the Layer;\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.layer_metadigraph","page":"API","title":"MultilayerGraphs.layer_metadigraph","text":"layer_metadigraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    edge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nConstructor for a Layer whose underlying graph is a MetaDiGraph from MetaGraphs.jl.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nedge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\n\nKWARGS\n\n-default_vertex_metadata::Function: Function that takes a MultilayerVertex and returns a Tuple or a NamedTuple containing the vertex metadata. defaults to mv -> NamedTuple();\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple()\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\nlayer_metadigraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    indegree_distribution::UnivariateDistribution,\n    outdegree_distribution::UnivariateDistribution;\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nConstructor for a Layer whose underlying graph is a MetaDiGraph from MetaDiGraphs.jl with a indegree and outdegree sequences respectively sampled from indegree_distribution and outdegree_distribution. Realization is performed via the Kleitman-Wang algorithm.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nindegree_distribution::UnivariateDistribution: The degree distribution from which the indegree sequence is sampled ;\noutdegree_distribution::UnivariateDistribution: The degree distribution from which the outdegree sequence is sampled ;\n\nKWARGS\n\n-default_vertex_metadata::Function: Function that takes a MultilayerVertex and returns a Tuple or a NamedTuple containing the vertex metadata. defaults to mv -> NamedTuple();\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple()\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\nlayer_metadigraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    ne::Int64;\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nReturn a random Layer with ne edges whose underlying graph is a MetaDiGraph from MetaDiGraphs.jl with a indegree and outdegree sequences respectively sampled from indegree_distribution and outdegree_distribution. Realization is performed via the Kleitman-Wang algorithm.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nne::Int64: The number of edges of the Layer;\n\nKWARGS\n\n-default_vertex_metadata::Function: Function that takes a MultilayerVertex and returns a Tuple or a NamedTuple containing the vertex metadata. defaults to mv -> NamedTuple();\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple()\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.layer_valgraph","page":"API","title":"MultilayerGraphs.layer_valgraph","text":"layer_valgraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    edge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nConstructor for a Layer whose underlying graph is a ValGraph from SimpleValueGraphs.jl.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nedge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\n\nKWARGS\n\n-default_vertex_metadata::Function: Function that takes a MultilayerVertex and returns a Tuple or a NamedTuple containing the vertex metadata. defaults to mv -> NamedTuple();\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple()\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\nlayer_valgraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    degree_distribution::UnivariateDistribution;\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nConstructor for a Layer whose underlying graph is a ValGraph from SimpleValueGraphs.jl. with a degree sequence sampled from degree_distribution. Realization is performed via the Havel-Hakimi algorithm.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\ndegree_distribution::UnivariateDistribution: The degree distribution from which the degree sequence is sampled ;\n\nKWARGS\n\n-default_vertex_metadata::Function: Function that takes a MultilayerVertex and returns a Tuple or a NamedTuple containing the vertex metadata. defaults to mv -> NamedTuple();\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple()\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\nlayer_valgraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    ne::Int64;\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nReturn a random Layer with ne edges whose underlying graph is a ValGraph from SimpleValueGraphs.jl. with a degree sequence sampled from degree_distribution. Realization is performed via the Havel-Hakimi algorithm.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nne::Int64: The number of edges of the Layer;\n\nKWARGS\n\n-default_vertex_metadata::Function: Function that takes a MultilayerVertex and returns a Tuple or a NamedTuple containing the vertex metadata. defaults to mv -> NamedTuple();\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple()\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.layer_valoutdigraph","page":"API","title":"MultilayerGraphs.layer_valoutdigraph","text":"layer_valoutdigraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    edge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nConstructor for a Layer whose underlying graph is a ValOutDiGraph from SimpleValueGraphs.jl.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nedge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\n\nKWARGS\n\n-default_vertex_metadata::Function: Function that takes a MultilayerVertex and returns a Tuple or a NamedTuple containing the vertex metadata. defaults to mv -> NamedTuple();\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple()\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\nlayer_valoutdigraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    indegree_distribution::UnivariateDistribution,\n    outdegree_distribution::UnivariateDistribution;\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nConstructor for a Layer whose underlying graph is a ValOutDiGraph from SimpleValueGraphs.jl with a indegree and outdegree sequences respectively sampled from indegree_distribution and outdegree_distribution. Realization is performed via the Kleitman-Wang algorithm.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nindegree_distribution::UnivariateDistribution: The degree distribution from which the indegree sequence is sampled ;\noutdegree_distribution::UnivariateDistribution: The degree distribution from which the outdegree sequence is sampled ;\n\nKWARGS\n\n-default_vertex_metadata::Function: Function that takes a MultilayerVertex and returns a Tuple or a NamedTuple containing the vertex metadata. defaults to mv -> NamedTuple(). Do not type this function's arguments;\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple(),  Do not type this function's arguments;\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\nlayer_valoutdigraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    ne::Int64;\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nReturn a random Layer with ne edges whose underlying graph is a ValOutDiGraph from SimpleValueGraphs.jl with a indegree and outdegree sequences respectively sampled from indegree_distribution and outdegree_distribution. Realization is performed via the Kleitman-Wang algorithm.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nne::Int64: The number of edges of the Layer;\n\nKWARGS\n\n-default_vertex_metadata::Function: Function that takes a MultilayerVertex and returns a Tuple or a NamedTuple containing the vertex metadata. defaults to mv -> NamedTuple(). Do not type this function's arguments;\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple(),  Do not type this function's arguments;\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.layer_valdigraph","page":"API","title":"MultilayerGraphs.layer_valdigraph","text":"layer_valdigraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    edge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nConstructor for a Layer whose underlying graph is a ValDiGraph from SimpleValueGraphs.jl.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nedge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\n\nKWARGS\n\n-default_vertex_metadata::Function: Function that takes a MultilayerVertex and returns a Tuple or a NamedTuple containing the vertex metadata. defaults to mv -> NamedTuple();\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple()\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\nlayer_valdigraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    indegree_distribution::UnivariateDistribution,\n    outdegree_distribution::UnivariateDistribution;\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nConstructor for a Layer whose underlying graph is a ValDiGraph from SimpleValueGraphs.jl with a indegree and outdegree sequences respectively sampled from indegree_distribution and outdegree_distribution. Realization is performed via the Kleitman-Wang algorithm.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nindegree_distribution::UnivariateDistribution: The degree distribution from which the indegree sequence is sampled ;\noutdegree_distribution::UnivariateDistribution: The degree distribution from which the outdegree sequence is sampled ;\n\nKWARGS\n\n-default_vertex_metadata::Function: Function that takes a MultilayerVertex and returns a Tuple or a NamedTuple containing the vertex metadata. defaults to mv -> NamedTuple(). Do not type this function's arguments;\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple(),  Do not type this function's arguments;\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\nlayer_valdigraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    ne::Int64;\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nReturn a random Layer with ne edges whose underlying graph is a ValDiGraph from SimpleValueGraphs.jl with a indegree and outdegree sequences respectively sampled from indegree_distribution and outdegree_distribution. Realization is performed via the Kleitman-Wang algorithm.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nne::Int64: The number of edges of the Layer;\n\nKWARGS\n\n-default_vertex_metadata::Function: Function that takes a MultilayerVertex and returns a Tuple or a NamedTuple containing the vertex metadata. defaults to mv -> NamedTuple(). Do not type this function's arguments;\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple(),  Do not type this function's arguments;\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.layer_metagraph","page":"API","title":"MultilayerGraphs.layer_metagraph","text":"layer_metagraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    edge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nConstructor for a Layer whose underlying graph is a MetaGraph from MetaGraphs.jl.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nedge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\n\nKWARGS\n\n-default_vertex_metadata::Function: Function that takes a MultilayerVertex and returns a Tuple or a NamedTuple containing the vertex metadata. defaults to mv -> NamedTuple();\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple()\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\nlayer_metagraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    degree_distribution::UnivariateDistribution;\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nConstructor for a Layer whose underlying graph is a MetaGraph from MetaGraphs.jl with a degree sequence sampled from degree_distribution. Realization is performed via the Havel-Hakimi algorithm.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\ndegree_distribution::UnivariateDistribution: The degree distribution from which the degree sequence is sampled ;\n\nKWARGS\n\n-default_vertex_metadata::Function: Function that takes a MultilayerVertex and returns a Tuple or a NamedTuple containing the vertex metadata. defaults to mv -> NamedTuple();\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple()\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\nlayer_metagraph(\n    name::Symbol,\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},\n    ne::Int64;\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    vertextype::Type{T} = Int64,\n    weighttype::Type{U} = Float64\n) where {T<:Integer,U<:Real}\n\nReturn a random Layer with ne edges whose underlying graph is a MetaGraph from MetaGraphs.jl with a degree sequence sampled from degree_distribution. Realization is performed via the Havel-Hakimi algorithm.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}: The MultilayerVertexs of the Layer. May be a vector of MultilayerVertex{nothing}s or a vector of Nodes. In the latter case, the metadata of the MultilayerVertex to be added are computed via the default_vertex_metadata before the vertex is added (the function will act on each element of MV.(vertices));\nne::Int64: The number of edges of the Layer;\n\nKWARGS\n\n-default_vertex_metadata::Function: Function that takes a MultilayerVertex and returns a Tuple or a NamedTuple containing the vertex metadata. defaults to mv -> NamedTuple();\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple()\nvertextype::Type{T} = Int64: The type of the underlying integer labels associated to vertices.\nweighttype::Type{U} = Float64: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.has_node-Tuple{Layer, Node}","page":"API","title":"MultilayerGraphs.has_node","text":"has_node(layer::Layer, n::Node)\n\nReturn true if n is a node of layer.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.SimpleGraphs.add_vertex!-Tuple{Layer, MultilayerVertex}","page":"API","title":"Graphs.SimpleGraphs.add_vertex!","text":"add_vertex!(layer::Layer, mv::MultilayerVertex)\n\nAdd vertex to layer layer. \n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.SimpleGraphs.add_vertex!-Union{Tuple{L}, Tuple{T}, Tuple{L, Node, Vararg{Any}}} where {T, L<:(Layer{T, U, G} where {U<:Real, G<:AbstractGraph{T}})}","page":"API","title":"Graphs.SimpleGraphs.add_vertex!","text":"add_vertex!(layer::L, n::Node, args...; kwargs...) where {T, L <: Layer{T}}\n\nAdd vertex associated with node n to layer layer. This method supports the uniform and transparent interfaces. See the Vertices section of the Tutorial.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.SimpleGraphs.rem_vertex!-Tuple{Layer, MultilayerVertex}","page":"API","title":"Graphs.SimpleGraphs.rem_vertex!","text":"rem_vertex!(layer::Layer, mv::MultilayerVertex)\n\nRemove vertex mv from layer layer.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.SimpleGraphs.rem_vertex!-Tuple{Layer, Node}","page":"API","title":"Graphs.SimpleGraphs.rem_vertex!","text":"rem_vertex!(layer::Layer, n::Node)\n\nRemove node n from layer. Modify layer.v_N_associations according to how rem_vertex! works in Graph.jl.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.Interlayer","page":"API","title":"MultilayerGraphs.Interlayer","text":"Interlayer{T<:Integer,U<:Real,G<:AbstractGraph{T}} <: AbstractInterlayer{T,U,G}\n\nRepresents an interlayer in a Multilayer(Di)Graph. Its type hierarchy is: Interlayer <: AbstractInterlayer <: AbstractSubGraph .\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G<:AbstractGraph{T}, Layer{T, U, G} where G<:AbstractGraph{T}, G, Vector{<:MultilayerEdge{<:Union{Nothing, U}}}}} where {T<:Integer, U<:Real, G<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.Interlayer","text":"Interlayer(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    null_graph::G,\n    edge_list::Vector{ <: MultilayerEdge{<: Union{U, Nothing}}};\n    default_edge_weight::Function = (x,y) -> nothing,\n    default_edge_metadata::Function = (x,y) -> NamedTuple(),\n    transfer_vertex_metadata::Bool = false,\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nConstructor for Interlayer.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nedge_list::Vector{ <: MultilayerEdge{<: Union{U, Nothing}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\nnull_graph::G: the Interlayer's underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.\n\nKWARGS\n\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\ntransfer_vertex_metadata::Bool:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don't support metadata or that pose limitations to it may result in errors.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G<:AbstractGraph{T}, Layer{T, U, G} where G<:AbstractGraph{T}, Int64, G}} where {T<:Integer, U<:(Union{Nothing, var\"#s2\"} where var\"#s2\"<:Real), G<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.Interlayer","text":"Interlayer(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    ne::Int64,\n    null_graph::G;\n    default_edge_weight::Function = (x,y) -> nothing,\n    default_edge_metadata::Function = (x,y) -> NamedTuple(),\n    interlayer_name::Symbol,\n    transfer_vertex_metadata::Bool = false\n) where {T<:Integer, U <: Union{Nothing, <: Real}, G<:AbstractGraph{T}}\n\nReturn a random Interlayer.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nne::Int64: The number of edges of the Interlayer;\nnull_graph::G: the Interlayer's underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.\n\nKWARGS\n\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\ntransfer_vertex_metadata::Bool:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don't support metadata or that pose limitations to it may result in errors.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.interlayer_simplegraph","page":"API","title":"MultilayerGraphs.interlayer_simplegraph","text":"interlayer_simplegraph(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    edge_list::Union{<:Vector{<:MultilayerEdge{<:Union{U, Nothing}}}, Vector{ <:Tuple{<:MultilayerVertex, <:MultilayerVertex}}};\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nConstructor for Interlayer whose underlying graph is a SimpleGraph from Graphs.jl, with vertex type T and weight type U.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nedge_list::Union{<:Vector{<:MultilayerEdge{ <: Union{U,Nothing}}}, <:Vector{ <: Tuple{<:MultilayerVertex, <:MultilayerVertex}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\n\nKWARGS\n\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\n\n\n\n\n\ninterlayer_simplegraph(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    ne::Int64;\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nReturn a random Interlayer with ne edges whose underlying graph is a SimpleGraph from Graphs.jl, with vertex type T and weight type U.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nne::Int64: The number of edges of the Interlayer;\n\nKWARGS\n\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.interlayer_simpleweightedgraph","page":"API","title":"MultilayerGraphs.interlayer_simpleweightedgraph","text":"interlayer_simpleweightedgraph(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    edge_list::Union{<:Vector{<:MultilayerEdge{ <: Union{U,Nothing}}}, <:Vector{ <: Tuple{<:MultilayerVertex, <:MultilayerVertex}}};\n    default_edge_weight::Function=(x, y) -> nothing,\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nConstructor for Interlayer whose underlying graph is a SimpleWeightedGraph from SimpleWeightedGraphs.jl, with vertex type T and weight type U.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nedge_list::Union{<:Vector{<:MultilayerEdge{ <: Union{U,Nothing}}}, <:Vector{ <: Tuple{<:MultilayerVertex, <:MultilayerVertex}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\n\nKWARGS\n\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\n\n\n\n\n\ninterlayer_simpleweightedgraph(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    ne::Int64;\n    default_edge_weight::Function=(x, y) -> nothing,\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nReturn a random Interlayer with ne edges whose underlying graph is a SimpleWeightedGraph from SimpleWeightedGraphs.jl, with vertex type T and weight type U.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nne::Int64: The number of edges of the Interlayer;\n\nKWARGS\n\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.interlayer_metagraph","page":"API","title":"MultilayerGraphs.interlayer_metagraph","text":"interlayer_metagraph(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    edge_list::Union{<:Vector{<:MultilayerEdge{ <: Union{U,Nothing}}}, <:Vector{ <: Tuple{<:MultilayerVertex, <:MultilayerVertex}}};\n    default_edge_metadata::Function=(x, y) -> NamedTuple(),\n    transfer_vertex_metadata::Bool=false,\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nConstructor for Interlayer whose underlying graph is a MetaGraph from MetaGraphs.jl, with vertex type T and weight type U.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nedge_list::Union{<:Vector{<:MultilayerEdge{ <: Union{U,Nothing}}}, <:Vector{ <: Tuple{<:MultilayerVertex, <:MultilayerVertex}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\n\nKWARGS\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\ntransfer_vertex_metadata::Bool:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don't support metadata or that pose limitations to it may result in errors;\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\n\n\n\n\n\ninterlayer_metagraph(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    ne::Int64;\n    default_edge_metadata::Function=(x, y) -> NamedTuple(),\n    transfer_vertex_metadata::Bool=false,\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nReturn a random Interlayer with ne edges whose underlying graph is a MetaGraph from MetaGraphs.jl, with vertex type T and weight type U.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nne::Int64: The number of edges of the Interlayer;\n\nKWARGS\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\ntransfer_vertex_metadata::Bool:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don't support metadata or that pose limitations to it may result in errors;\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.interlayer_valgraph","page":"API","title":"MultilayerGraphs.interlayer_valgraph","text":"interlayer_valgraph(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    edge_list::Union{<:Vector{<:MultilayerEdge{ <: Union{U,Nothing}}}, <:Vector{ <: Tuple{<:MultilayerVertex, <:MultilayerVertex}}};\n    default_edge_metadata::Function=(x, y) -> NamedTuple()\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nConstructor for Interlayer whose underlying graph is a ValGraph from SimpleValueGraphs.jl, with vertex type T. By default, transfer_vertex_metadata is set to false.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nedge_list::Union{<:Vector{<:MultilayerEdge{ <: Union{U,Nothing}}}, <:Vector{ <: Tuple{<:MultilayerVertex, <:MultilayerVertex}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\n\nKWARGS\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\n\n\n\n\n\ninterlayer_valgraph(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    ne::Int64;\n    default_edge_metadata::Function=(x, y) -> NamedTuple()\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nReturn a random Interlayer with ne edges whose underlying graph is a ValGraph from SimpleValueGraphs.jl, with vertex type T. By default, transfer_vertex_metadata is set to false.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nne::Int64: The number of edges of the Interlayer;\n\nKWARGS\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.interlayer_simpledigraph","page":"API","title":"MultilayerGraphs.interlayer_simpledigraph","text":"interlayer_simpledigraph(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    edge_list::Union{<:Vector{<:MultilayerEdge{ <: Union{U,Nothing}}}, <:Vector{ <: Tuple{<:MultilayerVertex, <:MultilayerVertex}}};\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nConstructor for Interlayer whose underlying graph is a SimpleDiGraph from Graphs.jl, with vertex type T and weight type U.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nedge_list::Union{<:Vector{<:MultilayerEdge{ <: Union{U,Nothing}}}, <:Vector{ <: Tuple{<:MultilayerVertex, <:MultilayerVertex}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\n\nKWARGS\n\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\n\n\n\n\n\ninterlayer_simpledigraph(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    ne::Int64;\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nReturn a random Interlayer with ne edges whose underlying graph is a SimpleDiGraph from Graphs.jl, with vertex type T and weight type U.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nne::Int64: The number of edges of the Interlayer;\n\nKWARGS\n\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.interlayer_simpleweighteddigraph","page":"API","title":"MultilayerGraphs.interlayer_simpleweighteddigraph","text":"interlayer_simpleweighteddigraph(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    edge_list::Union{<:Vector{<:MultilayerEdge{ <: Union{U,Nothing}}}, <:Vector{ <: Tuple{<:MultilayerVertex, <:MultilayerVertex}}};\n    default_edge_weight::Function=(x, y) -> nothing,\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nConstructor for Interlayer whose underlying graph is a SimpleWeightedDiGraph from SimpleWeightedGraphs.jl, with vertex type T and weight type U.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nedge_list::Union{<:Vector{<:MultilayerEdge{ <: Union{U,Nothing}}}, <:Vector{ <: Tuple{<:MultilayerVertex, <:MultilayerVertex}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\n\nKWARGS\n\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\n\n\n\n\n\ninterlayer_simpleweighteddigraph(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    ne::Int64;\n    default_edge_weight::Function=(x, y) -> nothing,\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nReturn a random Interlayer with ne edges underlying graph is a SimpleWeightedDiGraph from SimpleWeightedGraphs.jl, with vertex type T and weight type U.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nne::Int64: The number of edges of the Interlayer;\n\nKWARGS\n\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.interlayer_metadigraph","page":"API","title":"MultilayerGraphs.interlayer_metadigraph","text":"interlayer_metadigraph(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    edge_list::Union{<:Vector{<:MultilayerEdge{ <: Union{U,Nothing}}}, <:Vector{ <: Tuple{<:MultilayerVertex, <:MultilayerVertex}}};\n    default_edge_metadata::Function=(x, y) -> NamedTuple(),\n    transfer_vertex_metadata::Bool=false,\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nConstructor for Interlayer whose underlying graph is a MetaDiGraph from MetaGraphs.jl, with vertex type T and weight type U.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nedge_list::Union{<:Vector{<:MultilayerEdge{ <: Union{U,Nothing}}}, <:Vector{ <: Tuple{<:MultilayerVertex, <:MultilayerVertex}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\n\nKWARGS\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\ntransfer_vertex_metadata::Bool:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don't support metadata or that pose limitations to it may result in errors;\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\n\n\n\n\n\ninterlayer_metadigraph(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    ne::Int64;\n    default_edge_metadata::Function=(x, y) -> NamedTuple(),\n    transfer_vertex_metadata::Bool=false,\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nReturn a random Interlayer with ne edges whose underlying graph is a MetaDiGraph from MetaGraphs.jl, with vertex type T and weight type U.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nne::Int64: The number of edges of the Interlayer;\n\nKWARGS\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\ntransfer_vertex_metadata::Bool:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don't support metadata or that pose limitations to it may result in errors;\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.interlayer_valoutdigraph","page":"API","title":"MultilayerGraphs.interlayer_valoutdigraph","text":"interlayer_valoutdigraph(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    edge_list::Union{<:Vector{<:MultilayerEdge{ <: Union{U,Nothing}}}, <:Vector{ <: Tuple{<:MultilayerVertex, <:MultilayerVertex}}};\n    default_edge_metadata::Function=(x, y) -> NamedTuple()\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nConstructor for Interlayer whose underlying graph is a ValOutDiGraph from SimpleValueGraphs.jl, with vertex type T. By default, transfer_vertex_metadata is set to false.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nedge_list::Union{<:Vector{<:MultilayerEdge{ <: Union{U,Nothing}}}, <:Vector{ <: Tuple{<:MultilayerVertex, <:MultilayerVertex}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\n\nKWARGS\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\n\n\n\n\n\ninterlayer_valoutdigraph(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    ne::Int64;\n    default_edge_metadata::Function=(x, y) -> NamedTuple()\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nReturn a random Interlayer with ne edges whose underlying graph is a ValOutDiGraph from SimpleValueGraphs.jl, with vertex type T. By default, transfer_vertex_metadata is set to false.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nne::Int64: The number of edges of the Interlayer;\n\nKWARGS\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.interlayer_valdigraph","page":"API","title":"MultilayerGraphs.interlayer_valdigraph","text":"interlayer_valdigraph(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    edge_list::Union{<:Vector{<:MultilayerEdge{ <: Union{U,Nothing}}}, <:Vector{ <: Tuple{<:MultilayerVertex, <:MultilayerVertex}}};\n    default_edge_metadata::Function=(x, y) -> NamedTuple()\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nConstructor for Interlayer whose underlying graph is a ValDiGraph from SimpleValueGraphs.jl, with vertex type T. By default, transfer_vertex_metadata is set to false.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nedge_list::Union{<:Vector{<:MultilayerEdge{ <: Union{U,Nothing}}}, <:Vector{ <: Tuple{<:MultilayerVertex, <:MultilayerVertex}}}: The list of MultilayerEdges. It may be a vector of MultilayerEdges or a Vector of 2-tuples of MultilayerVertexs. In the latter case, the weight and the metadata of the MultilayerEdge to be added are computed respectively via the default_edge_weight and default_edge_metadata functions;\n\nKWARGS\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\n\n\n\n\n\ninterlayer_valdigraph(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    ne::Int64;\n    default_edge_metadata::Function=(x, y) -> NamedTuple()\n    interlayer_name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nReturn a random Interlayer with ne edges whose underlying graph is a ValDiGraph from SimpleValueGraphs.jl, with vertex type T. By default, transfer_vertex_metadata is set to false.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nne::Int64: The number of edges of the Interlayer;\n\nKWARGS\n\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\n\n\n\n\n\n","category":"function"},{"location":"API_organized/#MultilayerGraphs.multiplex_interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G<:AbstractGraph{T}, Layer{T, U, G} where G<:AbstractGraph{T}, G}} where {T<:Integer, U<:Real, G<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.multiplex_interlayer","text":"multiplex_interlayer(\n    nv::Int64,\n    interlayer_name::Symbol,\n    layer_1::Symbol, \n    layer_2::Symbol, \n    graph_type::Type{G}; \n    forbidden_vertices::Vector{MultilayerVertex}, forbidden_edges::Vector{NTuple{2, MultilayerVertex}}\n) where {T <: Union{ <: Integer, AbstractVertex}, G <: AbstractGraph{T}}\n\nReturn an Interlayer{T,U,G} that has edges only between vertices that represent the same node.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nnull_graph::G: the Interlayer's underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.\n\nKWARGS\n\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\ntransfer_vertex_metadata::Bool:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don't support metadata or that pose limitations to it may result in errors;\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.empty_interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G<:AbstractGraph{T}, Layer{T, U, G} where G<:AbstractGraph{T}, G}} where {T<:Integer, U<:Real, G<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.empty_interlayer","text":"empty_interlayer(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    null_graph::G;\n    default_edge_weight::Function = (x,y) -> nothing,\n    default_edge_metadata::Function = (x,y) -> NamedTuple(),\n    interlayer_name::Symbol),\n    transfer_vertex_metadata::Bool = false\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nConstruct an empty interlayer (i.e. an interlayer with no edges).\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nnull_graph::G: the Interlayer's underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.\n\nKWARGS\n\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\ninterlayer_name::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\ntransfer_vertex_metadata::Bool:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don't support metadata or that pose limitations to it may result in errors;\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.nodes-Tuple{AbstractSubGraph}","page":"API","title":"MultilayerGraphs.nodes","text":"nodes(subgraph::AbstractSubGraph)\n\nReturn the collection of the nodes of subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.has_vertex-Tuple{Layer, MultilayerVertex}","page":"API","title":"Graphs.has_vertex","text":"has_vertex(layer::Layer, mv::MultilayerVertex)\n\nReturn true if v is a vertex of layer.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.has_vertex-Tuple{Interlayer, MultilayerVertex}","page":"API","title":"Graphs.has_vertex","text":"has_vertex(interlayer::Interlayer, v::MultilayerVertex)\n\nReturn true if v is a vertex of interlayer.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.nv-Tuple{AbstractSubGraph}","page":"API","title":"Graphs.nv","text":"nv(subgraph::AbstractSubGraph)\n\nReturn the number of vertices in subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.mv_vertices-Tuple{AbstractSubGraph}","page":"API","title":"MultilayerGraphs.mv_vertices","text":"mv_vertices(subgraph::AbstractSubGraph)\n\nReturn the collection of the MultilayerVertexs of subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.mv_inneighbors-Tuple{AbstractSubGraph, MultilayerVertex}","page":"API","title":"MultilayerGraphs.mv_inneighbors","text":"mv_inneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\n\nReturn the MultilayerVertexs inneighbors of mv within subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.mv_outneighbors-Tuple{AbstractSubGraph, MultilayerVertex}","page":"API","title":"MultilayerGraphs.mv_outneighbors","text":"mv_outneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\n\nReturn the MultilayerVertexs outneighbors of mv within subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.mv_neighbors-Tuple{AbstractSubGraph, MultilayerVertex}","page":"API","title":"MultilayerGraphs.mv_neighbors","text":"mv_neighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\n\nDefaults to mv_outneighbors.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.has_edge-Tuple{AbstractSubGraph, MultilayerEdge}","page":"API","title":"Graphs.has_edge","text":"has_edge(subgraph::AbstractSubGraph,me::MultilayerEdge)\n\nReturn true if there is an edge from src(me) to dst(me) within subgraph, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.has_edge-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}","page":"API","title":"Graphs.has_edge","text":"has_edge( subgraph::AbstractSubGraph, s::MultilayerVertex, d::MultilayerVertex)\n\nReturn true if there is an edge between s and d, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.has_edge-Tuple{Layer, MultilayerVertex{nothing}, MultilayerVertex{nothing}}","page":"API","title":"Graphs.has_edge","text":"has_edge( layer::Layer, s::MultilayerVertex{nothing}, d::MultilayerVertex{nothing})\n\nReturn true if there is an edge between s and d, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.ne-Tuple{AbstractSubGraph}","page":"API","title":"Graphs.ne","text":"ne(subgraph::AbstractSubGraph)\n\nReturn the number of edges in subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.edges-Union{Tuple{S}, Tuple{U}, Tuple{T}} where {T, U, S<:(AbstractSubGraph{T, U, G} where G<:AbstractGraph{T})}","page":"API","title":"Graphs.edges","text":"edges(subgraph::S) where {T,U,S<:AbstractSubGraph{T,U}}\n\nReturn an iterator over all the edges of subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{S}, Tuple{U}, Tuple{T}, Tuple{S, E}} where {T, U<:Real, S<:(AbstractSubGraph{T, U, G} where G<:AbstractGraph{T}), E<:(MultilayerEdge{<:Union{Nothing, U}})}","page":"API","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!( subgraph::S, me::E) where {T,U<:Real,S<:AbstractSubGraph{T,U},E<:MultilayerEdge{ <: Union{U, Nothing}}}\n\nAdd unweighted edge me to subgraph. Its weight and metadata fields are passed to the uniform interface of add_edge!(::Layer, ::MultilayerVertex, ::MultilayerVertex, ::Tuple).\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.SimpleGraphs.add_edge!-Tuple{Layer, MultilayerVertex, MultilayerVertex, Vararg{Any}}","page":"API","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(layer::L, src::MultilayerVertex, dst::MultilayerVertex, args...; kwargs...) where {L <: Layer}\n\nAdd edge from vertex src to vertex dst to layer layer. Returns true if succeeds. This method supports the uniform and transparent interfaces. See the Edges section of the Tutorial.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.SimpleGraphs.add_edge!-Tuple{Interlayer, MultilayerVertex, MultilayerVertex, Vararg{Any}}","page":"API","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(interlayer::Interlayer, src::MultilayerVertex, dst::MultilayerVertex, args...; kwargs...)\n\nAdd edge from vertex src to vertex dst to Interlayer interlayer.Returns true if succeeds, but will fail (return false) if src and dst belong to the same layer, since interlayers are always bipartite. This method supports the uniform and transparent interfaces. See the Edges section of the Tutorial.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.SimpleGraphs.rem_edge!-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}","page":"API","title":"Graphs.SimpleGraphs.rem_edge!","text":"rem_edge!(subgraph::AbstractSubGraph, src::MultilayerVertex, dst::MultilayerVertex)\n\nRemove edge from src to dst in subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.SimpleGraphs.rem_edge!-Tuple{AbstractSubGraph, MultilayerEdge}","page":"API","title":"Graphs.SimpleGraphs.rem_edge!","text":"rem_edge!(subgraph::AbstractSubGraph, me::MultilayerEdge)\n\nRemove edge from src(me) to dst(me) in subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.get_metadata-Tuple{AbstractSubGraph, MultilayerVertex}","page":"API","title":"MultilayerGraphs.get_metadata","text":"get_metadata(subgraph::AbstractSubGraph, bare_mv::MultilayerVertex)\n\nReturn the metadata of the vertex bare_mv in subgraph (metadata assigned to bare_mv will be discarded). \n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.get_metadata-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}","page":"API","title":"MultilayerGraphs.get_metadata","text":"get_edge_metadata(subgraph::S, src::MultilayerVertex, dst::MultilayerVertex)\n\nReturn the metadata of the edge between the source vertex src and the destination vertex dst in subgraph. \n\n\n\n\n\n","category":"method"},{"location":"API_organized/#SimpleWeightedGraphs.get_weight-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}","page":"API","title":"SimpleWeightedGraphs.get_weight","text":"get_weight(subgraph::S, src::MultilayerVertex, dst::MultilayerVertex)\n\nReturn the weight of the edge between the source vertex src and the destination vertex dst in subgraph. \n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.is_directed-Tuple{AbstractSubGraph}","page":"API","title":"Graphs.is_directed","text":"is_directed(subgraph::AbstractSubGraph)\n\nReturn true if subgraph is directed, false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.is_directed-Union{Tuple{Type{S}}, Tuple{S}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, S<:AbstractSubGraph{T, U, G}}","page":"API","title":"Graphs.is_directed","text":"is_directed(::Type{S}) where {T,U,G,S <: AbstractSubGraph{T,U,G}}\n\nReturn true if instances of S are directed, false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.LinAlg.adjacency_matrix-Tuple{AbstractSubGraph}","page":"API","title":"Graphs.LinAlg.adjacency_matrix","text":"adjacency_matrix(subgraph::AbstractSubGraph)\n\nReturn the adjacency matrix of subgraph.graph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.weights-Union{Tuple{S}, Tuple{U}, Tuple{T}} where {T, U, S<:(AbstractSubGraph{T, U, G} where G<:AbstractGraph{T})}","page":"API","title":"Graphs.weights","text":"weights(subgraph::S) where { T,U, G <: AbstractGraph{T}, S <:AbstractSubGraph{T,U,G}}\n\nReturn the weights of subgraph.graph, with the eltype converted to U.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.is_multiplex_interlayer-Tuple{Interlayer}","page":"API","title":"MultilayerGraphs.is_multiplex_interlayer","text":"is_multiplex_interlayer(interlayer::In) where {In <: Interlayer}\n\nCheck that Interlayer interlayer is a multiplex-type Interlayer.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.get_symmetric_interlayer-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, In<:Interlayer{T, U, G}}","page":"API","title":"MultilayerGraphs.get_symmetric_interlayer","text":"get_symmetric_interlayer(interlayer::In; symmetric_interlayer_name::String) where{T,U,G, In <: Interlayer{T,U,G}}\n\nReturn the Interlayer corresponding to interlayer where layer_1 and layer_2 are swapped. Its interlayername will be `symmetricinterlayername(defaults tointerlayer(interlayer.layer2)(interlayer.layer_1)`).\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.name-Tuple{AbstractSubGraph}","page":"API","title":"MultilayerGraphs.name","text":"name(subgraph::AbstractSubGraph)\n\nReturn the name of subgraph. \n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.graph-Tuple{AbstractSubGraph}","page":"API","title":"MultilayerGraphs.graph","text":"name(subgraph::AbstractSubGraph)\n\nReturn the underlying graph of subgraph. \n\n\n\n\n\n","category":"method"},{"location":"API_organized/#msm_eu","page":"API","title":"Multilayer-Specific Methods","text":"","category":"section"},{"location":"API_organized/","page":"API","title":"API","text":"MultilayerGraph{T,U}\n\nMultilayerDiGraph{T,U}\n\nMultilayerGraph(T::Type{<:Number}, U::Type{<:Number})\n\nMultilayerDiGraph(T::Type{<:Number}, U::Type{<:Number})\n\nMultilayerGraph(\n    layers::Vector{<:Layer{T,U}},\n    specified_interlayers::Vector{<:Interlayer{T,U}};\n    default_interlayers_null_graph::H = SimpleGraph{T}(),\n    default_interlayers_structure::String=\"multiplex\",\n) where {T,U, H <: AbstractGraph{T}}\n\nMultilayerDiGraph(\n    layers::Vector{<:Layer{T,U}},\n    specified_interlayers::Vector{<:Interlayer{T,U}};\n    default_interlayers_null_graph::H = SimpleGraph{T}(),\n    default_interlayers_structure::String=\"multiplex\",\n) where {T,U, H <: AbstractGraph{T}}\n\nMultilayerGraph(\n    empty_layers::Vector{<:Layer{T,U}},\n    empty_interlayers::Vector{<:Interlayer{T,U}},\n    degree_distribution::UnivariateDistribution;\n    allow_self_loops::Bool = false,\n    default_interlayers_null_graph::H = SimpleGraph{T}(),\n) where {T <: Integer, U <: Real, H <: AbstractGraph{T}}\n\nMultilayerDiGraph(\n    empty_layers::Vector{<:Layer{T,U}},\n    empty_interlayers::Vector{<:Interlayer{T,U}},\n    indegree_distribution::UnivariateDistribution,\n    outdegree_distribution::UnivariateDistribution;\n    allow_self_loops::Bool = false,\n    default_interlayers_null_graph::H = SimpleGraph{T}(),\n) where {T <: Integer, U <: Real, H <: AbstractGraph{T}}\n\nMultilayerGraph(\n    empty_multilayergraph::MultilayerGraph{T,U}, \n    degree_sequence::Vector{<:Integer}; \n    allow_self_loops::Bool = false, \n    perform_checks::Bool = true\n) where {T,U}\n\nMultilayerDiGraph(\n    empty_multilayerdigraph::MultilayerDiGraph{T,U}, \n    indegree_sequence::Vector{<:Integer},\n    outdegree_sequence::Vector{<:Integer};\n    allow_self_loops::Bool = false,\n     perform_checks::Bool = false\n) where {T,U}\n\nSynchronizedEdgeColoredGraph{T,U}\n\nSynchronizedEdgeColoredGraph(\n    layers::Vector{<:Layer{T,U}},\n) where {T,U}\n\nSynchronizedEdgeColoredDiGraph{T,U}\n\n\n\nnodes(mg::AbstractMultilayerGraph)\nnn(mg::AbstractMultilayerGraph) \n<!-- add_node!(mg::AbstractMultilayerGraph, n::Node; add_vertex_to_layers::Union{Vector{Symbol}, Symbol}) -->\n<!-- rem_node!(mg::AbstractMultilayerGraph, n::Node) -->\nhas_vertex(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\nnv(mg::M) where {M <: AbstractMultilayerGraph }\nmv_vertices(mg::AbstractMultilayerGraph)\nmv_inneighbors(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\nmv_outneighbors(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\nmv_neighbors( mg::AbstractMultilayerGraph, mv::MultilayerVertex)\n<!-- add_vertex!(mg::AbstractMultilayerGraph, mv::MultilayerVertex; add_node::Bool) -->\n<!-- rem_vertex!(mg::AbstractMultilayerUGraph, V::MultilayerVertex) -->\n<!-- rem_vertex!(mg::AbstractMultilayerDiGraph, V::MultilayerVertex) -->\nhas_edge(mg::AbstractMultilayerGraph, edge::MultilayerEdge) \nhas_edge( subgraph::AbstractMultilayerGraph, s::MultilayerVertex, d::MultilayerVertex)\nne(mg::AbstractMultilayerGraph)\n<!-- edges(mg::AbstractMultilayerUGraph) -->\n<!-- edges(mg::M) where {T,U,M<:AbstractMultilayerUGraph{T,U}} -->\nedges(mg::M) where {T,U,M<:AbstractMultilayerGraph{T,U}; IsDirected{M}}\nedges\nadd_edge!(mg::M, src::V, dst::V; weight::Union{Nothing, U} = one(U), metadata::Union{Tuple,NamedTuple} = NamedTuple() ) where {T,U, M <: AbstractMultilayerGraph{T,U}, V <: MultilayerVertex}\nadd_edge!(mg::M, me::E) where {T,U, M <: AbstractMultilayerGraph{T,U}, E <: MultilayerEdge{ <: Union{U,Nothing}}}\nrem_edge!(mg::AbstractMultilayerGraph, me::MultilayerEdge)\nrem_edge!(mg::MultilayerGraph, src::MultilayerVertex, dst::MultilayerVertex)\nrem_edge!(mg::MultilayerDiGraph, src::MultilayerVertex, dst::MultilayerVertex)\nget_metadata(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\nget_metadata(mg::AbstractMultilayerGraph, src::MultilayerVertex, dst::MultilayerVertex)\nget_weight(mg::AbstractMultilayerGraph, src::MultilayerVertex, dst::MultilayerVertex)\n<!-- set_weight!(mg::M, src::MultilayerVertex, dst::MultilayerVertex, weight::U) where { T,U, M <: AbstractMultilayerUGraph{T,U}}\nset_weight!(mg::M, src::MultilayerVertex, dst::MultilayerVertex, weight::U) where {T,U,M<:AbstractMultilayerGraph{T,U}; IsDirected{M}} -->\nset_weight!\n<!-- is_directed(mg::AbstractMultilayerUGraph) -->\n<!-- is_directed(m::M) where { M <: Type{ <: AbstractMultilayerUGraph}} -->\n<!-- is_directed(mg::AbstractMultilayerDiGraph)\nis_directed(m::M) where { M <: Type{ <: AbstractMultilayerDiGraph}} -->\nhas_node(mg::AbstractMultilayerGraph, n::Node)\n<!-- set_metadata!(mg::AbstractMultilayerGraph, mv::MultilayerVertex, metadata::Union{Tuple, NamedTuple}) \n<!-- set_metadata!(mg::AbstractMultilayerDiGraph, src::MultilayerVertex, dst::MultilayerVertex, metadata::Union{Tuple, NamedTuple}) -->\nset_metadata!(mg::AbstractMultilayerUGraph, src::MultilayerVertex, dst::MultilayerVertex, metadata::Union{Tuple, NamedTuple}) -->\nset_metadata!\nnl(mg::AbstractMultilayerGraph)\nnIn(mg::AbstractMultilayerGraph)\nhas_layer(mg::AbstractMultilayerGraph, layer_name::Symbol)\n\n<!-- add_layer!(mg::M, new_layer::L; default_interlayers_null_graph::H = SimpleGraph{T}(), default_interlayers_structure::String =\"multiplex\"\n) where {T,U,G<:AbstractGraph{T},M<:AbstractMultilayerUGraph{T,U},L<:Layer{T,U,G}, H <: AbstractGraph{T}} -->\n\n<!-- add_layer!(\n    mg::M, new_layer::L; default_interlayers_null_graph::H = SimpleGraph{T}(), default_interlayers_structure::String =\"multiplex\"\n) where {T,U,G<:AbstractGraph{T},M<:AbstractMultilayerDiGraph{T,U},L<:Layer{T,U,G}, H <: AbstractGraph{T}} -->\n\nspecify_interlayer!\n\nget_interlayer(\n    mg::AbstractMultilayerGraph, layer_1_name::Symbol, layer_2_name::Symbol\n)\n\n\nindegree(mg::AbstractMultilayerGraph, mv::V) where {V <: MultilayerVertex}\nindegree(mg::AbstractMultilayerGraph, vs::AbstractVector{<:MultilayerVertex}=vertices(mg))\n\noutdegree(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\noutdegree(mg::AbstractMultilayerGraph, vs::AbstractVector{<:MultilayerVertex}=vertices(mg))\n\ndegree(mg::AbstractMultilayerGraph, vs::AbstractVector{<:MultilayerVertex}=vertices(mg)) \n\nmean_degree(mg::AbstractMultilayerGraph)\n\ndegree_second_moment(mg::AbstractMultilayerGraph) \n\ndegree_variance(mg::AbstractMultilayerGraph)\n\nMultilayerGraphs.weighttype(::M) where {T,U,M<:AbstractMultilayerGraph{T,U}}\n\nmultilayer_global_clustering_coefficient(\n    mg::AbstractMultilayerGraph, norm_factor::Union{Float64,Symbol}=:max\n)\n\noverlay_clustering_coefficient(\n    mg::AbstractMultilayerGraph,\n    norm_factor::Union{Float64,Symbol}=:max\n)\n\neigenvector_centrality(\n    mg::M; weighted::Bool = true,  norm::String=\"1\", tol::Float64=1e-6, maxiter::Int64=2000\n) where {T,U,M<:AbstractMultilayerGraph{T,U}}\n\nmodularity(\n    mg::M, c::Matrix{Int64}; null_model::Union{String,Array{U,4}}=\"degree\"\n) where {T,U,M<:AbstractMultilayerGraph{T,U}}\n\n\n<!-- von_neumann_entropy(mg::M) where {T,U,M<:AbstractMultilayerUGraph{T,U}} -->","category":"page"},{"location":"API_organized/#MultilayerGraphs.MultilayerGraph","page":"API","title":"MultilayerGraphs.MultilayerGraph","text":"MultilayerGraph{T, U, G <: AbstractGraph{T}} <: AbstractMultilayerGraph{T,U}\n\nA concrete type that can represent a general multilayer graph. Its internal fields aren't meant to be modified by the user. Please prefer the provided API.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs.MultilayerDiGraph","page":"API","title":"MultilayerGraphs.MultilayerDiGraph","text":"MultilayerDiGraph{T, U, G <: AbstractGraph{T}} <: AbstractMultilayerGraph{T,U}\n\nA concrete type that can represent a general multilayer graph. Its internal fields aren't meant to be modified by the user. Please prefer the provided API.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs.MultilayerGraph-Tuple{Type{<:Number}, Type{<:Number}}","page":"API","title":"MultilayerGraphs.MultilayerGraph","text":"MultilayerGraph(T::Type{<:Number}, U::Type{<:Number})\n\nReturn a null MultilayerGraph with with vertex type T weighttype U. Use this constructor and then add Layers and Interlayers via the add_layer! and specify_interlayer! methods.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.MultilayerDiGraph-Tuple{Type{<:Number}, Type{<:Number}}","page":"API","title":"MultilayerGraphs.MultilayerDiGraph","text":"MultilayerDiGraph(n_nodes::Int64, T::Type{ <: Number}, U::Type{ <: Number} )\n\nReturn a null MultilayerDiGraph with with vertex type T weighttype U. Use this constructor and then add Layers and Interlayers via the add_layer! and specify_interlayer! methods.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.MultilayerGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{<:Layer{T, U, G} where G<:AbstractGraph{T}}, Vector{<:Interlayer{T, U, G} where G<:AbstractGraph{T}}}} where {T, U, H<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.MultilayerGraph","text":"MultilayerGraph(\n    layers::Vector{<:Layer{T,U}},\n    specified_interlayers::Vector{<:Interlayer{T,U}};\n    default_interlayers_null_graph::H = SimpleGraph{T}(),\n    default_interlayers_structure::String=\"multiplex\",\n) where {T,U, H <: AbstractGraph{T}}\n\nConstruct a MultilayerGraph with layers given by layers. The interlayers will be constructed by default according to default_interlayer where only \"multiplex\" and \"empty\" are allowed, except for those specified in specified_interlayers. default_interlayer = \"multiplex\" will imply that unspecified interlayers will have only diagonal couplings, while  default_interlayer = \"multiplex\" will produced interlayers that have no couplings.\n\nARGUMENTS\n\nlayers::Vector{<:Layer{T,U}}: The (ordered) list of layers the multilayer graph will have;\nspecified_interlayers::Vector{<:Interlayer{T,U}}: The list of interlayers specified by the user. Note that the user does not need to specify all interlayers, as the unspecified ones will be automatically constructed using the indications given by the default_interlayers_null_graph and default_interlayers_structure keywords;\ndefault_interlayers_null_graph::H = SimpleGraph{T}(): Sets the underlying graph for the interlayers that are to be automatically specified. Defaults to SimpleGraph{T}(). See the Interlayer constructors for more information;\ndefault_interlayers_structure::String = \"multiplex\": Sets the structure of the interlayers that are to be automatically specified. May be \"multiplex\" for diagonally coupled interlayers, or \"empty\" for empty interlayers (no edges).  \"multiplex\". See the Interlayer constructors for more information.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.MultilayerDiGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{<:Layer{T, U, G} where G<:AbstractGraph{T}}, Vector{<:Interlayer{T, U, G} where G<:AbstractGraph{T}}}} where {T, U, H<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.MultilayerDiGraph","text":"MultilayerDiGraph(\n    layers::Vector{<:Layer{T,U}},\n    specified_interlayers::Vector{<:Interlayer{T,U}};\n    default_interlayers_null_graph::H = SimpleGraph{T}(),\n    default_interlayers_structure::String=\"multiplex\",\n) where {T,U, H <: AbstractGraph{T}}\n\nConstruct a MultilayerDiGraph with layers given by layers. The interlayers will be constructed by default according to default_interlayer where only \"multiplex\" and \"empty\" are allowed, except for those specified in specified_interlayers. default_interlayer = \"multiplex\" will imply that unspecified interlayers will have only diagonal couplings, while  default_interlayer = \"multiplex\" will produced interlayers that have no couplings.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.MultilayerGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{<:Layer{T, U, G} where G<:AbstractGraph{T}}, Vector{<:Interlayer{T, U, G} where G<:AbstractGraph{T}}, UnivariateDistribution}} where {T<:Integer, U<:Real, H<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.MultilayerGraph","text":"MultilayerGraph(\n    empty_layers::Vector{<:Layer{T,U}},\n    empty_interlayers::Vector{<:Interlayer{T,U}},\n    degree_distribution::UnivariateDistribution;\n    allow_self_loops::Bool = false,\n    default_interlayers_null_graph::H = SimpleGraph{T}(),\n) where {T <: Integer, U <: Real, H <: AbstractGraph{T}}\n\nReturn a random MultilayerGraph that has empty_layers as layers and empty_interlayers as specified interlayers. empty_layers and empty_interlayers must respectively be Layers and Interlayers with whatever number of vertices but no edges (if any edge is found, an error is thrown). The  degree distribution of the returned random MultilayerGraph is given by degree_distribution, which must have a support that only contains positive numbers for obvious reasons. allow_self_loops = true allows for self loops t be present in the final random MultilayerGraph. default_interlayers_null_graph controls the null_graph argument passed to automatically-generated interlayers. \n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.MultilayerDiGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{<:Layer{T, U, G} where G<:AbstractGraph{T}}, Vector{<:Interlayer{T, U, G} where G<:AbstractGraph{T}}, UnivariateDistribution, UnivariateDistribution}} where {T<:Integer, U<:Real, H<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.MultilayerDiGraph","text":"MultilayerDiGraph(\n    empty_layers::Vector{<:Layer{T,U}},\n    empty_interlayers::Vector{<:Interlayer{T,U}},\n    indegree_distribution::UnivariateDistribution,\n    outdegree_distribution::UnivariateDistribution;\n    allow_self_loops::Bool = false,\n    default_interlayers_null_graph::H = SimpleGraph{T}(),\n) where {T <: Integer, U <: Real, H <: AbstractGraph{T}}\n\nReturn a random MultilayerDiGraph that has empty_layers as layers and empty_interlayers as specified interlayers. empty_layers and empty_interlayers must respectively be Layers and Interlayers with whatever number of vertices but no edges (if any edge is found, an error is thrown). The  degree distribution of the returned random MultilayerDiGraph is given by degree_distribution, which must have a support that only contains positive numbers for obvious reasons. allow_self_loops = true allows for self loops t be present in the final random MultilayerDiGraph. default_interlayers_null_graph controls the null_graph argument passed to automatically-generated interlayers. \n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.MultilayerGraph-Union{Tuple{U}, Tuple{T}, Tuple{MultilayerGraph{T, U}, Vector{<:Integer}}} where {T, U}","page":"API","title":"MultilayerGraphs.MultilayerGraph","text":"MultilayerGraph(empty_multilayergraph::MultilayerGraph{T,U},\ndegree_sequence::Vector{<:Integer}; \nallow_self_loops::Bool = false,\nperform_checks::Bool = false) where {T,U}\n\nReturn a random MultilayerGraph with degree sequence degree_sequence. allow_self_loops controls the presence of self-loops, while if perform_checks is true, the degree_sequence os checked to be graphical.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.MultilayerDiGraph-Union{Tuple{U}, Tuple{T}, Tuple{MultilayerDiGraph{T, U}, Vector{<:Integer}, Vector{<:Integer}}} where {T, U}","page":"API","title":"MultilayerGraphs.MultilayerDiGraph","text":"MultilayerDiGraph(\n    empty_multilayerdigraph::MultilayerDiGraph{T,U}, \n    indegree_sequence::Vector{<:Integer},\n    outdegree_sequence::Vector{<:Integer};\n    allow_self_loops::Bool = false,\n    perform_checks::Bool = false\n) where {T,U}\n\nReturn a random MultilayerDiGraph with degree sequence degree_sequence. allow_self_loops controls the presence of self-loops, while if perform_checks is true, the degree_sequence os checked to be graphical.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.nodes-Tuple{AbstractMultilayerGraph}","page":"API","title":"MultilayerGraphs.nodes","text":"nodes(mg::AbstractMultilayerGraph\n\nReturn the nodes of the AbstractMultilayerGraph mg, in order of addition.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.nn-Tuple{AbstractMultilayerGraph}","page":"API","title":"MultilayerGraphs.nn","text":"nn(mg::M) where {M <: AbstractMultilayerGraph }\n\nReturn the number of nodes in mg.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#representations_eu","page":"API","title":"Representations","text":"","category":"section"},{"location":"API_organized/","page":"API","title":"API","text":"array(atr::AbstractTensorRepresentation)\nWeightTensor{U}\nweight_tensor(mg::M) where {T,U, M <: AbstractMultilayerGraph{T,U}}\nMetadataTensor{U}\nmetadata_tensor(mg::M) where {T,U, M <: AbstractMultilayerGraph{T,U}}\narray(amr::AbstractMatrixRepresentation)\nSupraWeightMatrix{T,U}\nsupra_weight_matrix(mg::M) where {T,U, M <: AbstractMultilayerGraph{T,U}}","category":"page"},{"location":"API_organized/#MultilayerGraphs.array-Tuple{AbstractTensorRepresentation}","page":"API","title":"MultilayerGraphs.array","text":"array(atr::AbstractTensorRepresentation)\n\nReturn the array representation of atr.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.WeightTensor","page":"API","title":"MultilayerGraphs.WeightTensor","text":"WeightTensor{U}\n\nConcrete type representing the weight tensor of a multilayer graph.  Look at the EXAMPLES section below to learn how to use it.\n\nEXAMPLES\n\n# Assuming a MultilayerGraph named mg is defined, and that mv1 and mv2 are two of its `MultilayerVertex`ss\nwt = WeightTensor(mg)\n# One may access te corresponding WeightTensor's entry via:\nwt[mv1, mv2]\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs.weight_tensor-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M<:AbstractMultilayerGraph{T, U}}","page":"API","title":"MultilayerGraphs.weight_tensor","text":"weight_tensor(mg::M) where {T,U, M <: AbstractMultilayerGraph{T,U}}\n\nCompute the weight tensor of mg. Return an object of type WeightTensor.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.MetadataTensor","page":"API","title":"MultilayerGraphs.MetadataTensor","text":"MetadataTensor{U}\n\nConcrete type representing the metadata tensor of a multilayer graph.  Look at the EXAMPLES section below to learn how to use it.\n\nEXAMPLES\n\n# Assuming a MultilayerGraph named mg is defined, and that mv1 and mv2 are two of its `MultilayerVertex`s\nmt = MetadataTensor(mg)\n# One may access te corresponding MetadataTensor's entry via:\nmt[mv1, mv2]\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs.metadata_tensor-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M<:AbstractMultilayerGraph{T, U}}","page":"API","title":"MultilayerGraphs.metadata_tensor","text":"metadata_tensor(mg::M) where {T,U, M <: AbstractMultilayerGraph{T,U}}\n\nCompute the weight tensor of mg. Return an object of type WeightTensor.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.array-Tuple{AbstractMatrixRepresentation}","page":"API","title":"MultilayerGraphs.array","text":"array(amr::AbstractMatrixRepresentation)\n\nReturn the array representation of amr.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.SupraWeightMatrix","page":"API","title":"MultilayerGraphs.SupraWeightMatrix","text":"SupraWeightMatrix{T,U}\n\nA concrete type representing the (supra) weight matrix of a multilayer graph. It takes into account missing vertices by default. Look at the EXAMPLES section to learn how to use it.\n\nEXAMPLES\n\n# Assuming a MultilayerGraph named mg is defined, and that mv1 and mv2 are two of its `MultilayerVertex`ss\nswm = SupraWeightMatrix(mg)\n# One may access te corresponding SupraWeightMatrix's entry via:\nswm[mv1, mv2]\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs.supra_weight_matrix-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M<:AbstractMultilayerGraph{T, U}}","page":"API","title":"MultilayerGraphs.supra_weight_matrix","text":"supra_weight_matrix(mg::M) where {T,U, M <: AbstractMultilayerGraph{T,U}}\n\nCompute the supra weight matrix of mg. Return an object of type SupraWeightMatrix\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#traits_eu","page":"API","title":"Traits","text":"","category":"section"},{"location":"API_organized/","page":"API","title":"API","text":"is_weighted(g::G) where { G <: AbstractGraph}\nis_weighted(g::G) where {G<:Type{<:AbstractGraph}}\n\nis_meta(g::G) where {G <: AbstractGraph}\nis_meta(g::G) where {G<:Type{<:AbstractGraph}}","category":"page"},{"location":"API_organized/#MultilayerGraphs.is_weighted-Tuple{G} where G<:AbstractGraph","page":"API","title":"MultilayerGraphs.is_weighted","text":"is_weighted(g::G) where { G <: AbstractGraph}\n\nCheck whether g is weighted.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.is_weighted-Tuple{G} where G<:(Type{<:AbstractGraph})","page":"API","title":"MultilayerGraphs.is_weighted","text":"is_weighted(g::G) where {G<:Type{<:AbstractGraph}}\n\nCheck whether g is weighted.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.is_meta-Tuple{G} where G<:AbstractGraph","page":"API","title":"MultilayerGraphs.is_meta","text":"is_meta(g::G) where {G <: AbstractGraph}\n\nCheck whether g supports edge AND vertex metadata.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.is_meta-Tuple{G} where G<:(Type{<:AbstractGraph})","page":"API","title":"MultilayerGraphs.is_meta","text":"is_meta(g::G) where {G<:Type{<:AbstractGraph}}\n\nCheck whether g supports edge AND vertex metadata.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#utilities_eu","page":"API","title":"Utilities","text":"","category":"section"},{"location":"API_organized/","page":"API","title":"API","text":"multilayer_kronecker_delta(dims::NTuple{4,Int64})\nk{T}\nk(N::Int64)\n_1{T<: Number}\n_2{T<:Number}\n_3{T<:Number}\n_{T}","category":"page"},{"location":"API_organized/#MultilayerGraphs.multilayer_kronecker_delta-Tuple{NTuple{4, Int64}}","page":"API","title":"MultilayerGraphs.multilayer_kronecker_delta","text":"multilayer_kronecker_delta(dims::NTuple{4,Int64})\n\nReturn a 4-dimensional Kronecker delta with size equal to dims.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.k","page":"API","title":"MultilayerGraphs.k","text":"mutable struct k{T} <: AbstractVector{T}\n\nThe Kronecker delta.\n\nFIELDS\n\nN::Int64: the number of dimensions;\nrepresentation::Matrix{Int64}: the matrix representing the Kronecker delta;\nT: the return type when called k[i,j].\n\nCONSTRUCTORS\n\nk{T}(N::Int64) where {T <: Number}\n\nInner constructor that only requires N and the eltype.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs.k-Tuple{Int64}","page":"API","title":"MultilayerGraphs.k","text":"k(N::Int64)\n\nOuter constructor that only requires N.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs._1","page":"API","title":"MultilayerGraphs._1","text":"struct _1{T<: Number}\n\nThe _1 from De Domenico et al. (2013). Evaluate it via the notation [i,j].\n\nFIELDS\n\nN:Int64: the dimensionality of _1;\nT: the return type.\n\nCONSTRUCTORS\n\n_1{T<: Number}(N::Int64)\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs._2","page":"API","title":"MultilayerGraphs._2","text":"struct _2{T<: Number}\n\nThe _2 from De Domenico et al. (2013). Evaluate it via the notation [i,j].\n\nFIELDS\n\nN:Int64: the dimensionality of _2;\nT: the return type.\n\nCONSTRUCTORS\n\n_2{T<: Number}(N::Int64)\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs._3","page":"API","title":"MultilayerGraphs._3","text":"struct _3{T<: Number}\n\nThe _3 from De Domenico et al. (2013). Evaluate it via the notation [i,j].\n\nFIELDS\n\nN:Int64: the dimensionality of _3;\nT: the return type.\n\nCONSTRUCTORS\n\n_3{T<: Number}(N::Int64)\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs._","page":"API","title":"MultilayerGraphs._","text":"_{T} <: AbstractVector{T}\n\nStruct that represents the _ defined in De Domenico et al. (2013).\n\nFIELDS\n\n_1::_1{T}: Instance of _1;\n_2::_2{T}: Instance of _2;\n_3::_3{T}: Instance of _3;\nN::Int64  : Maximum index (number of layers);\nrepresentation::Array{Int64,4}: Multidimensional-array representation of _.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#Developer","page":"API","title":"Developer","text":"","category":"section"},{"location":"API_organized/#nodes_dev","page":"API","title":"Nodes","text":"","category":"section"},{"location":"API_organized/","page":"API","title":"API","text":"AbstractNode","category":"page"},{"location":"API_organized/#MultilayerGraphs.AbstractNode","page":"API","title":"MultilayerGraphs.AbstractNode","text":"abstract type AbstractNode\n\nAn abstract type representing a node.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#vertices_dev","page":"API","title":"Vertices","text":"","category":"section"},{"location":"API_organized/","page":"API","title":"API","text":"AbstractVertex\nAbstractMultilayerVertex","category":"page"},{"location":"API_organized/#MultilayerGraphs.AbstractVertex","page":"API","title":"MultilayerGraphs.AbstractVertex","text":"abstract type AbstractVertex\n\nAn abstract type for vertices that may not be represented by Integer and for which it may be inappropriate to use a graph with vertex-level metadata.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs.AbstractMultilayerVertex","page":"API","title":"MultilayerGraphs.AbstractMultilayerVertex","text":"AbstractMultilayerVertex{S} <: AbstractVertex\n\nAn abstract type representing an abstract MultilayerGraph vertex.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#edges_dev","page":"API","title":"Edges","text":"","category":"section"},{"location":"API_organized/","page":"API","title":"API","text":"AbstractMultilayerEdge\nmetadata(he::MultilayerGraphs.HalfEdge)\nweight(he::MultilayerGraphs.HalfEdge)","category":"page"},{"location":"API_organized/#MultilayerGraphs.AbstractMultilayerEdge","page":"API","title":"MultilayerGraphs.AbstractMultilayerEdge","text":"AbstractMultilayerEdge{T} <: AbstractEdge{T}\n\nAn abstract type representing a MultilayerGraph edge.\n\nIt must have fields: src, dst, weight.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs.metadata-Tuple{MultilayerGraphs.HalfEdge}","page":"API","title":"MultilayerGraphs.metadata","text":"metadata(he::HalfEdge)\n\nReturn the metadata associated to the edge.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#SimpleWeightedGraphs.weight-Tuple{MultilayerGraphs.HalfEdge}","page":"API","title":"SimpleWeightedGraphs.weight","text":"weight(he::HalfEdge)\n\nReturn the weight of the edge.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#subgraphs_dev","page":"API","title":"Subgraphs","text":"","category":"section"},{"location":"API_organized/","page":"API","title":"API","text":"has_vertex(subgraph::S, v::T ) where {T,S<:AbstractSubGraph{T}}\nvertices(subgraph::AbstractSubGraph)\ninneighbors(subgraph::S, v::T) where {T, S <: AbstractSubGraph{T}}\ninneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\noutneighbors(subgraph::S, v::T) where {T,S<:AbstractSubGraph{T}}\noutneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\nneighbors(subgraph::S, v::T) where {T,S<:AbstractSubGraph{T}}\nneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\nedgetype(::S) where {T,U,S<:AbstractSubGraph{T,U}}\nhas_edge( subgraph::S, s::T, d::T) where {T,S<:AbstractSubGraph{T}}\nadd_edge!(subgraph::S, src::T, dst::T; weight::W = nothing, metadata::Union{Tuple, NamedTuple}= NamedTuple()) where {T, U<: Real, W<:Union{ U, Nothing},G<:AbstractGraph{T},S<:AbstractSubGraph{T,U,G}} \nrem_edge!(subgraph::S, src::T, dst::T) where {T, S<:AbstractSubGraph{T}}\nAbstractLayer\nLayer(descriptor::MultilayerGraphs.LayerDescriptor{T}, vertices::Vector{<: MultilayerVertex}, edge_list::Vector{<:MultilayerEdge}) where {T <: Integer}\nrem_vertex!(layer::L, v::T) where {T, L <: Layer{T}} \nAbstractInterlayer","category":"page"},{"location":"API_organized/#Graphs.has_vertex-Union{Tuple{S}, Tuple{T}, Tuple{S, T}} where {T, S<:(AbstractSubGraph{T, U, G} where {U<:Real, G<:AbstractGraph{T}})}","page":"API","title":"Graphs.has_vertex","text":"has_vertex( subgraph::S, v::T ) where {T,S<:AbstractSubGraph{T}}\n\nReturn true if v is a vertex of subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.vertices-Tuple{AbstractSubGraph}","page":"API","title":"Graphs.vertices","text":"vertices(subgraph::AbstractSubGraph)\n\nReturn the collection of the vertices of subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.inneighbors-Union{Tuple{S}, Tuple{T}, Tuple{S, T}} where {T, S<:(AbstractSubGraph{T, U, G} where {U<:Real, G<:AbstractGraph{T}})}","page":"API","title":"Graphs.inneighbors","text":"inneighbors(subgraph::S, v::T) where {T, S <: AbstractSubGraph{T}}\n\nReturn the list of inneighbors of v within subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.inneighbors-Tuple{AbstractSubGraph, MultilayerVertex}","page":"API","title":"Graphs.inneighbors","text":"inneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\n\nReturn the list of inneighbors of mv within subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.outneighbors-Union{Tuple{S}, Tuple{T}, Tuple{S, T}} where {T, S<:(AbstractSubGraph{T, U, G} where {U<:Real, G<:AbstractGraph{T}})}","page":"API","title":"Graphs.outneighbors","text":"outneighbors(subgraph::S, v::T) where {T,S<:AbstractSubGraph{T}}\n\nReturn the list of outneighbors of v within subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.outneighbors-Tuple{AbstractSubGraph, MultilayerVertex}","page":"API","title":"Graphs.outneighbors","text":"outneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\n\nReturn the list of outneighbors of mv within subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.neighbors-Union{Tuple{S}, Tuple{T}, Tuple{S, T}} where {T, S<:(AbstractSubGraph{T, U, G} where {U<:Real, G<:AbstractGraph{T}})}","page":"API","title":"Graphs.neighbors","text":"neighbors(subgraph::S, v::T) where {T, S <: AbstractSubGraph{T}}\n\nReturn the list of neighbors of v within subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.neighbors-Tuple{AbstractSubGraph, MultilayerVertex}","page":"API","title":"Graphs.neighbors","text":"neighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\n\nReturn the list of neighbors of mv within subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.edgetype-Union{Tuple{S}, Tuple{U}, Tuple{T}} where {T, U, S<:(AbstractSubGraph{T, U, G} where G<:AbstractGraph{T})}","page":"API","title":"Graphs.edgetype","text":"edgetype(::S) where {T,U,S<:AbstractSubGraph{T,U}}\n\nReturn the edge type for subgraph.\n\n\n\n\n\nedgetype(::M) where {T,U,M<:AbstractMultilayerGraph{T,U}}\n\nReturn the edge type for mg.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.has_edge-Union{Tuple{S}, Tuple{T}, Tuple{S, T, T}} where {T, S<:(AbstractSubGraph{T, U, G} where {U<:Real, G<:AbstractGraph{T}})}","page":"API","title":"Graphs.has_edge","text":"has_edge( subgraph::S, s::T, d::T) where {T,S<:AbstractSubGraph{T}}\n\nReturn true if there is an edge between s and d, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{S}, Tuple{G}, Tuple{W}, Tuple{U}, Tuple{T}, Tuple{S, T, T}} where {T, U<:Real, W<:Union{Nothing, U}, G<:AbstractGraph{T}, S<:AbstractSubGraph{T, U, G}}","page":"API","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(subgraph::S, src::T, dst::T; weight::W = nothing, metadata::Union{Tuple, NamedTuple}= NamedTuple()) where {T, U<: Real, W<:Union{ U, Nothing},S<:AbstractSubGraph{T,U}}\n\nAdd edge from src to dst with weight weight and metadata metadata to subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.SimpleGraphs.rem_edge!-Union{Tuple{S}, Tuple{T}, Tuple{S, T, T}} where {T, S<:(AbstractSubGraph{T, U, G} where {U<:Real, G<:AbstractGraph{T}})}","page":"API","title":"Graphs.SimpleGraphs.rem_edge!","text":"rem_edge!(subgraph::S, src::T, dst::T) where {T, S<:AbstractSubGraph{T}}\n\nRemove edge from src to dst in a directed subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.AbstractLayer","page":"API","title":"MultilayerGraphs.AbstractLayer","text":"AbstractLayer{T,U,G}\n\nAn abstract type representing a generic Layer.\n\nFIELDS\n\nT: the node type;\nU: the MultilayerEdge weight eltype;\nG: the underlying graph type.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs.Layer-Union{Tuple{T}, Tuple{MultilayerGraphs.LayerDescriptor{T}, Vector{<:MultilayerVertex}, Vector{<:MultilayerEdge}}} where T<:Integer","page":"API","title":"MultilayerGraphs.Layer","text":"Layer(\n    descriptor::LayerDescriptor{T}, \n    vertices::Union{<:Vector{<:MultilayerVertex}, Vector{Node}}, \n    edge_list::Union{Vector{<:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}) where {T <: Integer}\n\nConstructor for Layer.\n\nARGUMENTS\n\ndescriptor::LayerDescriptor{T};\nvertices::Union{Vector{<:MultilayerVertex}, Vector{<:Node}};\nedge_list::Union{Vector{<:MultilayerEdge},Vector{NTuple{2, MultilayerVertex{nothing}}}};\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.SimpleGraphs.rem_vertex!-Union{Tuple{L}, Tuple{T}, Tuple{L, T}} where {T, L<:(Layer{T, U, G} where {U<:Real, G<:AbstractGraph{T}})}","page":"API","title":"Graphs.SimpleGraphs.rem_vertex!","text":"rem_vertex!(layer::L, v::T) where {T, L <: Layer{T}}\n\nRemove vertex v from layer layer.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#MultilayerGraphs.AbstractInterlayer","page":"API","title":"MultilayerGraphs.AbstractInterlayer","text":"AbstractInterlayer{T,U,G}\n\nAn abstract type representing a generic Interlayer.\n\nPARAMETRIC TYPES\n\nT: the node type;\nU: the adjacency matrix/tensor eltype;\nG: the underlying graph type.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#msm_dev","page":"API","title":"Multilayer-Specific Methods","text":"","category":"section"},{"location":"API_organized/","page":"API","title":"API","text":"AbstractMultilayerGraph{T <: Integer, U <: Real}\nfadjlist\nhas_vertex(mg::M, v::T) where {T, M <: AbstractMultilayerGraph{T}}\nvertices(mg::AbstractMultilayerGraph)\n<!-- inneighbors(mg::M, v::T) where {T,M<:AbstractMultilayerUGraph{T,<:Real}} -->\ninneighbors(mg::M, v::T) where {T, M<:AbstractMultilayerGraph{T,<:Real}}\ninneighbors(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\noutneighbors(mg::M, v::T) where {T, M<:AbstractMultilayerGraph{T}}\nneighbors(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\nedgetype(::M) where {T,U,M<:AbstractMultilayerGraph{T,U}}\n<!-- has_edge(mg::M, src::T, dst::T) where { T, M <: AbstractMultilayerUGraph{T}}\nhas_edge(mg::M, src::T, dst::T) where {T,M<:AbstractMultilayerGraph{T}; IsDirected{M}} -->\nhas_edge\nadd_edge!(mg::M,src::T,dst::T;weight::Union{Nothing,U}=one(U),metadata::Union{Tuple,NamedTuple}=NamedTuple(),) where {T,U,M<:AbstractMultilayerGraph{T,U}}\nrem_edge!(mg::M, src::T, dst::T) where {T, M <: AbstractMultilayerGraph{T}\n<!-- AbstractMultilayerUGraph{T,U} -->\n<!-- AbstractMultilayerDiGraph{T,U} -->\nAbstractMultiplexUGraph\nAbstractMultiplexDiGraph","category":"page"},{"location":"API_organized/#MultilayerGraphs.AbstractMultilayerGraph","page":"API","title":"MultilayerGraphs.AbstractMultilayerGraph","text":"AbstractMultilayerGraph{T <: Integer, U <: Real} <: AbstractGraph{T}\n\nAn abstract type for multilayer graphs. It is a subtype of AbstractGraph and its concrete subtypes may extend Graphs.jl.\n\nIts concrete subtypes must have the following fields:\n\nidx_N_associations::Bijection{Int64,Node}:;\nv_V_associations::Bijection{T,<:MultilayerVertex}:;\nv_metadata_dict::Dict{T,<:Union{<:Tuple,<:NamedTuple}}:;\nlayers: an indexable collection of Layers.\ninterlayers:a collection of Interlayers;\nlayers_names: a collection of the names of the layers.\nsubgraphs_names: a collection of the names of all the subgraphs.\nfadjlist::Vector{Vector{HalfEdge{<:MultilayerVertex,<:Union{Nothing,U}}}}: the forward adjacency list.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#Graphs.has_vertex-Union{Tuple{M}, Tuple{T}, Tuple{M, T}} where {T, M<:(AbstractMultilayerGraph{T})}","page":"API","title":"Graphs.has_vertex","text":"has_vertex(mg::M, v::T) where {T,M <: AbstractMultilayerGraph{T}}\n\nReturn true if v is in mg, else false.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#Graphs.vertices-Tuple{AbstractMultilayerGraph}","page":"API","title":"Graphs.vertices","text":"vertices(mg::M) where {M<:AbstractMultilayerGraph}\n\nReturn the collection of the vertices of mg.\n\n\n\n\n\n","category":"method"},{"location":"API_organized/#representations_dev","page":"API","title":"Representations","text":"","category":"section"},{"location":"API_organized/","page":"API","title":"API","text":"AbstractTensorRepresentation{U}\nAbstractMatrixRepresentation{T,U}","category":"page"},{"location":"API_organized/#MultilayerGraphs.AbstractTensorRepresentation","page":"API","title":"MultilayerGraphs.AbstractTensorRepresentation","text":"AbstractTensorRepresentation{U}\n\nAn abstract type encoding a generic tensorial representation of the links and metadata of a multilayer graph. \n\nConcrete subtypes must have an array field (a 4-dimensional tensor of eltype U, indexes as [sourcenodeidx, destinationnodeidx, sourcelayeridx, destinationlayeridx ]).\n\nPARAMETRIC TYPES\n\nU: the weight type of the multilayer graph.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs.AbstractMatrixRepresentation","page":"API","title":"MultilayerGraphs.AbstractMatrixRepresentation","text":"AbstractMatrixRepresentation{T,U}\n\nAn abstract type encoding a generic matrix representation of the links and metadata of a multilayer graph. \n\nConcrete subtypes must have an array field (a matrix of eltype U) and a v_V_associations (a Bijection{T, Union{MissingVertex, MultilayerVertex}}).\n\nPARAMETRIC TYPES\n\nT: the type of the internal representation of vertices;\nU: the weight type of the multilayer graph.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#traits_dev","page":"API","title":"Traits","text":"","category":"section"},{"location":"API_organized/","page":"API","title":"API","text":"IsWeighted{X}\nIsMeta{X}\nIsMultiplex{X}","category":"page"},{"location":"API_organized/#MultilayerGraphs.IsWeighted","page":"API","title":"MultilayerGraphs.IsWeighted","text":"IsWeighted{X}\n\nTrait that discerns between weighted and unweighted graphs. A graph type should take the IsWeighted trait IF AND ONLY IF it implements the signature add_edge!(src,dst,weight). Otherwise it should not.\n\n\n\n\n\n","category":"type"},{"location":"API_organized/#MultilayerGraphs.IsMeta","page":"API","title":"MultilayerGraphs.IsMeta","text":"IsMeta{X}\n\nTrait that discerns between graphs that sport edge and vertex metadata.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MultilayerGraphs","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div style=\"width:100%; height:150px;border-width:4px;border-style:solid;padding-top:25px;\n        border-color:#000;border-radius:10px;text-align:center;background-color:#B3D8FF;\n        color:#000\">\n    <h3 style=\"color: black;\">Star us on GitHub!</h3>\n    <a class=\"github-button\" href=\"https://github.com/JuliaGraphs/MultilayerGraphs.jl\" data-icon=\"octicon-star\" data-size=\"large\" data-show-count=\"true\" aria-label=\"Star JuliaGraphs/MultilayerGraphs.jl on GitHub\" style=\"margin:auto\">Star</a>\n    <script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n</div>","category":"page"},{"location":"#MultilayerGraphs.jl","page":"Home","title":"MultilayerGraphs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraphs.jl is a Julia package for the creation, manipulation and analysis of the structure, dynamics and functions of multilayer graphs. ","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A multilayer graph is a graph consisting of multiple standard subgraphs called layers which can be interconnected through bipartite graphs called interlayers composed of the vertex sets of two different layers and the edges between them. The vertices in each layer represent a single set of nodes, although not all nodes have to be represented in every layer. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Formally, a multilayer graph can be defined as a triple G=(VEL), where:","category":"page"},{"location":"","page":"Home","title":"Home","text":"V\nis the set of vertices;\nE\nis the set of edges, pairs of nodes (u v) representing a connection, relationship or interaction between the nodes u and v;\nL\nis a set of layers, which are subsets of V and E encoding the nodes and edges within each layer.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each layer ell in L is a tuple (V_ell E_ell), where V_ell is a subset of V that represents the vertices within that layer, and E_ell is a subset of E that represents the edges within that layer.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Multiple theoretical frameworks have been proposed to formally subsume all instances of multilayer graphs [1]. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Multilayer graphs have been adopted to model the structure and dynamics of a wide spectrum of high-dimensional, non-linear, multi-scale, time-dependent complex systems including physical, chemical, biological, neuronal, socio-technical, epidemiological, ecological and economic networks [2]. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraphs.jl is an integral part of the JuliaGraphs ecosystem extending Graphs.jl so all the methods and metrics exported by Graphs.jl work for multilayer graphs, but due to the special nature of multilayer graphs the package features a peculiar implementation that maps a standard integer-labelled vertex representation to a more user-friendly framework exporting all the objects an experienced practitioner would expect such as nodes (Node), vertices (MultilayerVertex), layers (Layer), interlayers (Interlayer), etc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A multilayer graph is composed of layers, i.e. graphs whose vertices represent the same set of nodes (not all nodes need to be represented in every layer), and interlayers, i.e. the bipartite graphs that connect vertices in two different layers. Vertices in a multilayer graph are represented using the MultilayerVertex struct, while nodes are represented using the Node struct.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraph and MultilayerDiGraph are fully-fledged Graphs.jl extensions. Both structs are designed to allow for layers and interlayers of any type (as long as they are Graphs.jl extensions themselves) and to permit layers and interlayers of different types. However, it is required that all layers and interlayers in MultilayerGraph are undirected, and all layers and interlayers in MultilayerDiGraph are directed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraph and MultilayerDiGraph support the specification of vertex and edge metadata, provided that the underlying layer or interlayer also supports metadata.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation is organized as follows: you will find a comprehensive Tutorial below, complemented by an API page. The API page is organized in two sections: the End-User section lists all the methods intended for the user who does not need to write code that is also compatible with other libraries in the Graphs.jl's ecosystem, while the Developer section contains methods that allow MultilayerGraphs.jl to be used as any package that extend Graphs.jl . Bot section are further stratified by topic. The tutorial below will be focused on the end-used experience, as developer methods often have very similar signature and will be better addressed in a future developer-oriented guide, should the community manifest the need of it.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install MultilayerGraphs.jl it is sufficient to activate the pkg mode by pressing ] in the Julia REPL and then run the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MultilayerGraphs","category":"page"},{"location":"#Tutorial","page":"Home","title":"Tutorial","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here we illustrate how to define, handle and analyse a MultilayerGraph (the directed version is completely analogous).","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Revise\nusing StatsBase, Distributions\nusing Graphs, SimpleWeightedGraphs, MetaGraphs, SimpleValueGraphs\nusing MultilayerGraphs","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define some constants that will prove useful later in the tutorial:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Set the minimum and maximum number of nodes_list and edges for random graphs\nconst vertextype   = Int64\nconst _weighttype  = Float64\nconst min_vertices = 5\nconst max_vertices = 7\nconst n_nodes      = max_vertices","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next we define the list of immutable objects that are represented (through vertices, see below) in the various layers and interlayers of a multilayer graph. These objects are called Nodes. The constructor for a Node reads:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Node(\n    id::String\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Where id is a String that is the name of what the Node stands for (could be cities in a transportation network, users in a social network, etc.). Let's construct a list of Nodes to use in the remainder of the tutorial:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# The constructor for nodes (which are immutable) only requires a name (`id`) for the node\nconst nodes_list = [Node(\"node_$i\") for i in 1:n_nodes]","category":"page"},{"location":"","page":"Home","title":"Home","text":"7-element Vector{Node}:\n Node(\"node_1\")\n Node(\"node_2\")\n Node(\"node_3\")\n Node(\"node_4\")\n Node(\"node_5\")\n Node(\"node_6\")\n Node(\"node_7\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"You may access (but not modify) the id of a Node via the id function. Nodes are represented throughout layers and interlayers via a struct named MultilayerVertex. It has several convenience constructors, the most complete of them reads:","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultilayerVertex( \n                node::Node,                            # The Node that the vertex will represent     \n                layer::Union{Nothing,Symbol},          # The layer which the `Node` will be represented in. Should be set to `nothing` when constructing layers.\n                metadata::Union{<:NamedTuple,<:Tuple} # The metadata associated to this vertex\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's contruct a list of MultilayerVertexs to use in the remainder of the tutorial:","category":"page"},{"location":"","page":"Home","title":"Home","text":"## Convert nodes to multilayer vertices without metadata\nconst multilayervertices = MV.(nodes_list)\n## Convert nodes multilayer vertices with metadata\nconst multilayervertices_meta  = [MV(node, (\"I'm node $(node.id)\",)) for node in nodes_list] # `MV` is an alias for `MultilayerVertex`","category":"page"},{"location":"","page":"Home","title":"Home","text":"7-element Vector{MultilayerVertex{nothing}}:\n MV(Node(\"node_1\"), :nothing, (\"I'm node node_1\",))\n MV(Node(\"node_2\"), :nothing, (\"I'm node node_2\",))\n MV(Node(\"node_3\"), :nothing, (\"I'm node node_3\",))\n MV(Node(\"node_4\"), :nothing, (\"I'm node node_4\",))\n MV(Node(\"node_5\"), :nothing, (\"I'm node node_5\",))\n MV(Node(\"node_6\"), :nothing, (\"I'm node node_6\",))\n MV(Node(\"node_7\"), :nothing, (\"I'm node node_7\",))","category":"page"},{"location":"","page":"Home","title":"Home","text":"This conversion from Nodes to MultilayerVertexs is performed since it is logical to add vertices to a graph, not nodes, and also for consistency reasons with the ecosystem. Regarding layers, adding/removing nodes or vertices allows for selecting the most comfortable interface. A similar mechanism is implemented for edges (see below).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Printing a MultilayerVertex returns:","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayervertices_meta[1]","category":"page"},{"location":"","page":"Home","title":"Home","text":"MV(Node(\"node_1\"), :nothing, (\"I'm node node_1\",))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Where MV is an alias for MultilayerVertex. The first field is the Node being represented (accessible via the node function), the second the (name of) the layer the vertex is represented in (accessible via the layer function, here it is set to nothing, since these vertices are yet to be assigned), and the metadata associated to the vertex (accessible via the metadata function, no metadata are currently represented via an empty NamedTuple). MultilayerVertex metadata can be represented via a Tuple or a NamedTuple (see below for examples). For a complete list of methods applicable to MultilayerVertices, please refer to the Vertices of the API.","category":"page"},{"location":"#Layers","page":"Home","title":"Layers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As said before, to define a multilayer graph we need to specify its layers and interlayers. Layers and the individual graphs that make up multilayer graphs. We proceed by constructing a Layer using the constructor that randomly specifies the edges:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Layer(\n    name::Symbol,                                                     # The name of the layer\n    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},  # The `MultilayerVertex`s of the Layer. May be a vector of `MultilayerVertex{nothing}`s or a vector of `Node`s. In the latter case, the metadata of the `MultilayerVertex` to be added are computed via the `default_vertex_metadata` before the vertex is added (the function will act on each element of `MV.(vertices)`);\n    ne::Int64,                                                        # The number of edges of the Layer\n    null_graph::AbstractGraph{T},                                     # The Layer's underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.\n    weighttype::Type{U};                                              # The type of the `MultilayerEdge` weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the `MultilayerGraph`s will always be weighted)\n    default_vertex_metadata::Function = mv -> NamedTuple(),           # Function that takes a `MultilayerVertex` and returns a `Tuple` or a `NamedTuple` containing the vertex metadata. Defaults to `mv -> NamedTuple()`;\n    default_edge_weight::Function = (src, dst) -> nothing,            #  Function that takes a pair of `MultilayerVertex`s and returns an edge weight of type `weighttype` or `nothing` (which is compatible with unweighted underlying graphs and corresponds to `one(weighttype)` for weighted underlying graphs). Defaults to `(src, dst) -> nothing`;\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),     # Function that takes a pair of `MultilayerVertex`s and  returns a `Tuple` or a `NamedTuple` containing the edge metadata, that will be called when `add_edge!(mg,src,dst, args...; kwargs...)` is called without the `metadata` keyword argument, and when generating the edges in this constructor. Defaults to  `(src, dst) -> NamedTuple()`;\n    allow_self_loops::Bool = false                                    # whether to allow self loops to be generated or not. Defaults to `false`.\n) where {T<:Integer, U<: Real}","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Layer is considered \"weighted\" if its underlying graph (null_graph argument) has been given the IsWeighted trait (traits throughout this package are implemented via SimpleTraits.jl, just like Graphs.jl does). Since one may at any moment add a new weighted Layer to a MultilayerGraph (see below for details), the latter is always considered a \"weighted graph\", so it is given the IsWeighted trait. Thus, all Layers and Interlayers (collectively named \"subgraphs\" hereafter) must specify their weighttype as the last argument of their constructor, so the user may debug their weight matrices (weights(subgraph::AbstractSubGraph)) immediately after construction. As better specified below, all subgraphs that are meant to be part of the same MultilayerGraph must have the same weighttype. Moreover, also the vertex type T (i.e. the internal representation of vertices) should be the same.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Before instantiating Layers, we define an utility function to ease randomisation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Utility function that returns a random number of vertices and edges each time it is called:\nfunction rand_nv_ne_layer(min_vertices, max_vertices)\n    _nv = rand(min_vertices:max_vertices)\n    _ne = rand(1:(_nv*(_nv-1))  2 )\n    return (_nv,_ne)\nend\n\n# Utility function that returns two vertices of a Layer that are not adjacent.\nfunction _get_srcmv_dstmv_layer(layer::Layer)\n    mvs = MultilayerGraphs.get_bare_mv.(collect(mv_vertices(layer)))\n\n    src_mv_idx = findfirst(mv -> !isempty(setdiff(\n        Set(mvs),\n        Set(\n            vcat(MultilayerGraphs.get_bare_mv.(mv_outneighbors(layer, mv)), mv)\n        ),\n    )), mvs)\n\n    src_mv = mvs[src_mv_idx]\n\n    _collection = setdiff(\n        Set(mvs),\n        Set(\n            vcat(MultilayerGraphs.get_bare_mv.(mv_outneighbors(layer, src_mv)), src_mv)\n        ),\n    )\n    \n    dst_mv = MultilayerGraphs.get_bare_mv(rand(_collection))\n\n    return mvs, src_mv, dst_mv\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"We are now are ready to define some Layers. Every type of graph from the Graphs.jl ecosystem may underlie a Layer (or an Interlayer). We will construct a few of them, each time with a different number of vertices and edges.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# An unweighted simple layer:\n_nv, _ne  = rand_nv_ne_layer(min_vertices,max_vertices)\nlayer_sg = Layer(   :layer_sg,\n                    sample(nodes_list, _nv, replace = false),\n                    _ne,\n                    SimpleGraph{vertextype}(),\n                    _weighttype\n)\n\n# A weighted `Layer`\n_nv, _ne  = rand_nv_ne_layer(min_vertices,max_vertices)\nlayer_swg = Layer(  :layer_swg,\n                    sample(nodes_list, _nv, replace = false),\n                    _ne,\n                    SimpleWeightedGraph{vertextype, _weighttype}(),\n                    _weighttype;\n                    default_edge_weight = (src,dst) -> rand()\n)\n# A `Layer` with an underlying `MetaGraph`:\n_nv, _ne = rand_nv_ne_layer(min_vertices,max_vertices)\nlayer_mg = Layer(   :layer_mg,\n                    sample(nodes_list, _nv, replace = false),\n                    _ne,\n                    MetaGraph{vertextype, _weighttype}(),\n                    _weighttype;\n                    default_edge_metadata = (src,dst) -> (from_to = \"from_$(src)_to_$(dst)\",)\n)\n# `Layer` with an underlying `ValGraph` from `SimpleValueGraphs.jl`\n_nv, _ne = rand_nv_ne_layer(min_vertices,max_vertices)\nlayer_vg = Layer(   :layer_vg,\n                    sample(nodes_list, _nv, replace = false),\n                    _ne,\n                    MultilayerGraphs.ValGraph(SimpleGraph{vertextype}();\n                                                edgeval_types=(Float64, String, ),\n                                                edgeval_init=(s, d) -> (s+d, \"hi\"),\n                                                vertexval_types=(String,),\n                                                vertexval_init=v -> (\"$v\",),),\n                                                _weighttype;\n                                                default_edge_metadata = (src,dst) -> (rand(), \"from_$(src)_to_$(dst)\",),\n                                                default_vertex_metadata = mv -> (\"This metadata had been generated via the default_vertex_metadata method\",)\n)\n\n# Collect all layers in an ordered list. Order will be recorded when instantiating the multilayer graph.\nlayers = [layer_sg, layer_swg, layer_mg, layer_vg]","category":"page"},{"location":"","page":"Home","title":"Home","text":"The API that inspects and modifies Layers will be shown below together with that of Interlayers, since they are usually the same.  There are of course other constructors that you may discover by reading the API. They include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Constructors that exempt the user from having to explicitly specify the null_graph, at the cost of some flexibility;\nConstructors that allow for a configuration model-like specifications.","category":"page"},{"location":"#Interlayers","page":"Home","title":"Interlayers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Now we turn to defining Interlayers. Interlayers are the graphs containing all the edges between vertices is two distinct layers. As before, we need an utility to ease randomization:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Utilities for Interlayer\n## Utility function that returns two vertices of an Interlayer that are not adjacent.\nfunction _get_srcmv_dstmv_interlayer(interlayer::Interlayer)\n\n    mvs = get_bare_mv.(collect(mv_vertices(interlayer)))\n\n    src_mv = nothing    \n    _collection = []\n\n    while isempty(_collection)\n        src_mv = rand(mvs)\n        _collection = setdiff(Set(mvs), Set(vcat(get_bare_mv.(mv_outneighbors(interlayer, src_mv)), src_mv, get_bare_mv.(mv_vertices( eval(src_mv.layer) ))) ) )  \n    end\n\n    dst_mv = get_bare_mv(rand(_collection))\n\n    return mvs, src_mv, dst_mv\nend\n\n## Utility function that returns a random number edges between its arguments `layer_1` and `layer_2`:\nfunction rand_ne_interlayer(layer_1, layer_2)\n    nv_1 = nv(layer_1)\n    nv_2 = nv(layer_2)\n    _ne = rand(1: (nv_1 * nv_2 - 1) )\n    return _ne\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"An Interlayer is constructed by passing its name, the two Layers it should connect, and the other parameters just like the Layer's constructor. The random constructor reads:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Interlayer(\n    layer_1::Layer{T,U},                                                 # One of the two layers connected by the Interlayer\n    layer_2::Layer{T,U},                                                 # One of the two layers connected by the Interlayer  \n    ne::Int64,                                                           # The number of edges of the Interlayer\n    null_graph::G;                                                       # the Interlayer's underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.\n    default_edge_weight::Function = (x,y) -> nothing,                    # Function that takes a pair of `MultilayerVertex`s and returns an edge weight of type `weighttype` or `nothing` (which is compatible with unweighted underlying graphs and corresponds to `one(weighttype)` for weighted underlying graphs). Defaults to `(src, dst) -> nothing`;\n    default_edge_metadata::Function = (x,y) -> NamedTuple(),             # Function that takes a pair of `MultilayerVertex`s and  returns a `Tuple` or a `NamedTuple` containing the edge metadata, that will be called when `add_edge!(mg,src,dst, args...; kwargs...)` is called without the `metadata` keyword argument, and when generating the edges in this constructor. Defaults to  `(src, dst) -> NamedTuple()`;\n    name::Symbol = Symbol(\"interlayer_$(layer_1.name)_$(layer_2.name)\"), # The name of the Interlayer. Defaults to Symbol(\"interlayer_(layer_1.name)_(layer_2.name)\");\n    transfer_vertex_metadata::Bool = false                               # If true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don't support metadata or that pose limitations to it may result in errors.;\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We will build a few of random Interlayers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Define the random undirected simple Interlayer\n_ne = rand_ne_interlayer(layer_sg, layer_swg)\ninterlayer_sg_swg = Interlayer( layer_sg,                  # The first layer to be connected\n                                layer_swg,                 # The second layer to be connected\n                                _ne,                       # The number of edges to randomly generate\n                                SimpleGraph{vertextype}(), # The underlying graph, passed as a null graph\n                                interlayer_name = :random_interlayer  # The name of the interlayer. We will be able to access it as a property of the multilayer graph via its name. This kwarg's default value is given by a combination of the two layers' names.\n)\n# Define a weighted `Interlayer`\n_ne = rand_ne_interlayer(layer_swg, layer_mg)\ninterlayer_swg_mg = Interlayer( layer_swg,\n                                layer_mg,\n                                _ne,\n                                SimpleWeightedGraph{vertextype, _weighttype}();\n                                default_edge_weight = (x,y) -> rand() # Arguments follow the same rules as in Layer\n)\n# Define an `Interlayer` with an underlying `MetaGraph`\n_ne = rand_ne_interlayer(layer_mg, layer_vg)\ninterlayer_mg_vg = Interlayer(  layer_mg,\n                                layer_vg,\n                                _ne,\n                                MetaGraph{vertextype, _weighttype}();\n                                default_edge_metadata = (x,y) -> (mymetadata = rand(),),\n                                transfer_vertex_metadata = true # This boolean kwarg controls whether vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don't support metadata or that pose limitations to it may result in errors.\n)\n# Define an `Interlayer` with an underlying `ValGraph` from `SimpleValueGraphs.jl`, with diagonal couplings only:\ninterlayer_multiplex_sg_mg = multiplex_interlayer(  layer_sg,\n                                                    layer_mg,\n                                                    ValGraph(SimpleGraph{vertextype}(); edgeval_types=(from_to = String,), edgeval_init=(s, d) -> (from_to = \"from_$(s)_to_$(d)\"));\n                                                    default_edge_metadata = (x,y) -> (from_to = \"from_$(src)_to_$(dst)\",)\n)\n# Finally, An `Interlayer` with no couplings (an \"empty\" interlayer):\ninterlayer_empty_sg_vg = empty_interlayer(  layer_sg,\n                                            layer_vg,\n                                            SimpleGraph{vertextype}()\n)\n\n# Collect all interlayers. Even though the list is ordered, order will not matter when instantiating the multilayer graph.\ninterlayers = [interlayer_sg_swg, interlayer_swg_mg, interlayer_mg_vg, interlayer_multiplex_sg_mg, interlayer_empty_sg_vg]","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are of course other constructors that you may discover by reading the API. They include constructors that exempt the user from having to explicitly specify the null_graph, at the cost of some flexibility;","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next, we explore the API associated to modify and analyze Layers and Interlayers.","category":"page"},{"location":"#Subgraphs-API","page":"Home","title":"Subgraphs API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"API for  Layers and Interlayers (collectively, \"subgraphs\") are very similar, so we will just show them for the Layer case, pointing out differences to the Interlayer scenario whenever they occur.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Subgraphs extend the Graphs.jl's interface, so one may expect every method from Graphs.jl to apply. Anyway, the output and signature is slightly different and thus worth pointing out below.","category":"page"},{"location":"#[Nodes](@ref-nodes_tut_subg)","page":"Home","title":"Nodes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"One may retrieve the Nodes that a Layer represents via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"layer_sg_nodes = nodes(layer_sg)","category":"page"},{"location":"","page":"Home","title":"Home","text":"6-element Vector{Node}:\n Node(\"node_2\")\n Node(\"node_3\")\n Node(\"node_4\")\n Node(\"node_6\")\n Node(\"node_5\")\n Node(\"node_7\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The same would be for Interlayers. In this case, the union of the set of nodes represented by the two layers the interlayer connects is returned:","category":"page"},{"location":"","page":"Home","title":"Home","text":"interlayer_sg_swg_nodes  = nodes(interlayer_sg_swg)","category":"page"},{"location":"","page":"Home","title":"Home","text":"7-element Vector{Node}:\n Node(\"node_2\")\n Node(\"node_3\")\n Node(\"node_4\")\n Node(\"node_6\")\n Node(\"node_5\")\n Node(\"node_7\")\n Node(\"node_1\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"One may check for the existence of a node within a layer (or interlayer) via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"has_node(layer_sg, layer_sg_nodes[1])","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"#[Vertices](@ref-vertices_tut_subg)","page":"Home","title":"Vertices","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"One may retrieve the MultilayerVertexs of a layer by calling:","category":"page"},{"location":"","page":"Home","title":"Home","text":"layer_sg_vertices = mv_vertices(layer_sg)","category":"page"},{"location":"","page":"Home","title":"Home","text":"6-element Vector{MultilayerVertex{:layer_sg}}:\n MV(Node(\"node_2\"), :layer_sg, NamedTuple())\n MV(Node(\"node_3\"), :layer_sg, NamedTuple())\n MV(Node(\"node_4\"), :layer_sg, NamedTuple())\n MV(Node(\"node_6\"), :layer_sg, NamedTuple())\n MV(Node(\"node_5\"), :layer_sg, NamedTuple())\n MV(Node(\"node_7\"), :layer_sg, NamedTuple())","category":"page"},{"location":"","page":"Home","title":"Home","text":"While vertices with metadata would look like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mv_vertices(layer_mg)","category":"page"},{"location":"","page":"Home","title":"Home","text":"6-element Vector{MultilayerVertex{:layer_mg}}:\n MV(Node(\"node_7\"), :layer_mg, (var\"1\" = \"I'm node node_7\",))\n MV(Node(\"node_6\"), :layer_mg, (var\"1\" = \"I'm node node_6\",))\n MV(Node(\"node_2\"), :layer_mg, (var\"1\" = \"I'm node node_2\",))\n MV(Node(\"node_4\"), :layer_mg, (var\"1\" = \"I'm node node_4\",))\n MV(Node(\"node_1\"), :layer_mg, (var\"1\" = \"I'm node node_1\",))\n MV(Node(\"node_5\"), :layer_mg, (var\"1\" = \"I'm node node_5\",))","category":"page"},{"location":"","page":"Home","title":"Home","text":"The vertices of an interlayer are the union of the sets of vertices of the two layers it connects:","category":"page"},{"location":"","page":"Home","title":"Home","text":"interlayer_sg_swg_vertices = mv_vertices(interlayer_sg_swg)","category":"page"},{"location":"","page":"Home","title":"Home","text":"11-element Vector{MultilayerVertex}:\n MV(Node(\"node_2\"), :layer_sg, NamedTuple())\n MV(Node(\"node_3\"), :layer_sg, NamedTuple())\n MV(Node(\"node_4\"), :layer_sg, NamedTuple())\n MV(Node(\"node_6\"), :layer_sg, NamedTuple())\n MV(Node(\"node_5\"), :layer_sg, NamedTuple())\n MV(Node(\"node_7\"), :layer_sg, NamedTuple())\n MV(Node(\"node_1\"), :layer_swg, NamedTuple())\n MV(Node(\"node_4\"), :layer_swg, NamedTuple())\n MV(Node(\"node_5\"), :layer_swg, NamedTuple())\n MV(Node(\"node_2\"), :layer_swg, NamedTuple())\n MV(Node(\"node_3\"), :layer_swg, NamedTuple())","category":"page"},{"location":"","page":"Home","title":"Home","text":"The vertices(subgraph::AbstractSubGraph) command would return an internal representation of the MultilayerVertexs (that of type vertextype). This method, together with others, serves to make MultilayerGraphs.jl compatible with the Graphs.jl ecosystem, but it is not meant to be called by the end user. It is, anyway, thought to be used by developers who wish to interface their packages with MultilayerGraphs.jl just as with other packages of the Graphs.jl ecosystem: as said above, a developer-oriented guide will be compiled if there is the need, although docstrings are already completed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To add a vertex, simply use add_vertex!. Let us define a vertex with metadata to add. Since nodes may not be represented more than once in layers, we have to define a new node too:","category":"page"},{"location":"","page":"Home","title":"Home","text":"new_node     = Node(\"missing_node\")\nnew_metadata = (meta = \"my_metadata\",)\nnew_vertex   = MV(new_node, new_metadata)","category":"page"},{"location":"","page":"Home","title":"Home","text":"MV(Node(\"missing_node\"), :nothing, (meta = \"my_metadata\",))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course, to be able to add a vertex with metadata to a layer, one must make sure that the underlying graph supports vertex-level metadata. Should one try to add a vertex with metadata different from an empty NamedTuple (i.e. no metadata) to a layer whose underlying graph does not support metadata, a warning is issued and the metadata are discarded.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thus, if we consider a layer whose underlying graph is a MetaGraph, the following three syntaxes would be equivalent.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The standard interface:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_vertex!(layer_mg, new_vertex)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The uniform interface. This signature has one keyword argument, metadata:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_vertex!(layer_mg, new_node, metadata = new_metadata)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The transparent interface. After you pass to add_vertex the Layer and the Node you wish to add, you  may pass the same args and kwargs  that you would pass to the add_vertex! dispatch that acts on the underlying graph (after the graph argument). This is a way to let the user directly exploit the API of the underlying graph package, which could be useful for two reasons:\nThey may be more convenient;\nThey should work even if we are not able to integrate the standard and the uniform interface with a particular Graphs.jl's extension.\nHere is an example on how to use it:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_vertex!(layer_mg, new_node, Dict(pairs(new_metadata)))","category":"page"},{"location":"","page":"Home","title":"Home","text":"where Dict(pairs(new_metadata)) is exactly what you would pass to the add_vertex! method that acts on MetaGraphs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"metagraph = MetaGraph()\nadd_vertex!(metagraph,  Dict(pairs(new_metadata))) # true","category":"page"},{"location":"","page":"Home","title":"Home","text":"If an underlying graph has an add_vertex! interface whose signature overlaps with that of the uniform interface, the uniform interface will be prevail.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If, using the transparent interface, one does not specify any metadata, the default_vertex_metadata function passed to the Layer's constructor is called to provide metadata to the vertex (type ?Layer in the REPL for more information).","category":"page"},{"location":"","page":"Home","title":"Home","text":"To remove the vertex, simply do:","category":"page"},{"location":"","page":"Home","title":"Home","text":"rem_vertex!(layer_sg, new_vertex) # Returns true if succeeds","category":"page"},{"location":"","page":"Home","title":"Home","text":"To extract metadata:","category":"page"},{"location":"","page":"Home","title":"Home","text":"get_metadata(layer_mg, MV(new_node))","category":"page"},{"location":"","page":"Home","title":"Home","text":"By design, one may not add nor remove vertices to Interlayers.","category":"page"},{"location":"#[Edges](@ref-edges_tut_subg)","page":"Home","title":"Edges","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The edge type for multilayer graphs (and thus for this subgraphs) is MultilayerEdge, which has a type parameter corresponding to the chosen weight type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"edgetype(layer_sg)","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultilayerEdge{Float64}","category":"page"},{"location":"","page":"Home","title":"Home","text":"The MultilayerEdges of an unweighted simple layer are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"collect(edges(layer_sg))","category":"page"},{"location":"","page":"Home","title":"Home","text":"9-element Vector{MultilayerEdge{Float64}}:\n ME(MV(Node(\"node_2\"), :layer_sg, NamedTuple()) --> MV(Node(\"node_4\"), :layer_sg, NamedTuple()),\tweight = 1.0,\tmetadata = NamedTuple())\n ME(MV(Node(\"node_2\"), :layer_sg, NamedTuple()) --> MV(Node(\"node_6\"), :layer_sg, NamedTuple()),\tweight = 1.0,\tmetadata = NamedTuple())\n ME(MV(Node(\"node_2\"), :layer_sg, NamedTuple()) --> MV(Node(\"node_5\"), :layer_sg, NamedTuple()),\tweight = 1.0,\tmetadata = NamedTuple())\n ME(MV(Node(\"node_3\"), :layer_sg, NamedTuple()) --> MV(Node(\"node_4\"), :layer_sg, NamedTuple()),\tweight = 1.0,\tmetadata = NamedTuple())\n ME(MV(Node(\"node_3\"), :layer_sg, NamedTuple()) --> MV(Node(\"node_6\"), :layer_sg, NamedTuple()),\tweight = 1.0,\tmetadata = NamedTuple())\n ME(MV(Node(\"node_4\"), :layer_sg, NamedTuple()) --> MV(Node(\"node_6\"), :layer_sg, NamedTuple()),\tweight = 1.0,\tmetadata = NamedTuple())\n ME(MV(Node(\"node_4\"), :layer_sg, NamedTuple()) --> MV(Node(\"node_5\"), :layer_sg, NamedTuple()),\tweight = 1.0,\tmetadata = NamedTuple())\n ME(MV(Node(\"node_6\"), :layer_sg, NamedTuple()) --> MV(Node(\"node_5\"), :layer_sg, NamedTuple()),\tweight = 1.0,\tmetadata = NamedTuple())\n ME(MV(Node(\"node_6\"), :layer_sg, NamedTuple()) --> MV(Node(\"node_7\"), :layer_sg, NamedTuple()),\tweight = 1.0,\tmetadata = NamedTuple())","category":"page"},{"location":"","page":"Home","title":"Home","text":"Where ME is a shorthand for MultilayerEdge. Besides the two vertices connected, each MultilayerEdge carries the information about its weight and metadata. For unweighted subgraphs, the weight is just one(weighttype) and for non-meta subgraphs the metadata are an empty NamedTuples. See ?MultilayerEdge for additional information, or refer to the Edges to discover more methods related to MultilayerEdgess.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The add_edge function has the standard, uniform and transparent interfaces too. To understand how they work, let's define a weighted edge:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Define a weighted edge for the layer_swg\n## Define the weight\n_weight = rand()\n## Select two non-adjacent vertices in layer_swg\n_, src_w, dst_w  = _get_srcmv_dstmv_layer(layer_swg)\n## Construct a weighted MultilayerEdge\nme_w = ME(src_w, dst_w, _weight) # ME is an alias for MultilayerEdge","category":"page"},{"location":"","page":"Home","title":"Home","text":"ME(MV(Node(\"node_4\"), :layer_swg, NamedTuple()) --> MV(Node(\"node_1\"), :layer_swg, NamedTuple()),\tweight = 0.6369546116248217,\tmetadata = NamedTuple())","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course, to be able to add a weighted edge to a subgraph, one must make sure that the underlying graph supports edge weights. Should one try to add a weight different from one(weighttype) or nothing to an edge of a subgraph whose underlying graph does not support edge weights, a warning is issued and the weight is discarded.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thus, if we consider a layer whose underlying graph is a SimpleWeightedGraph, the following three syntaxes would be equivalent.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The standard interface:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(layer_swg, me_w)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The uniform interface. This signature has two keyword arguments, weight and metadata that could be used exclusively (if, respectively, the underlying graph is weighted or supports edge-level metadata) or in combination (if the underlying graph supports both edge weights and edge-level metadata):","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(layer_swg, src_w, dst_w, weight = _weight)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The transparent interface. After you pass to add_edge! the Layer and the two vertices you wish to connect, you  may pass the same args and kwargs  that you would pass to the add_edge! dispatch that acts on the underlying graph (after the graph and vertices arguments). This is done for the same reasons explained above. Here is an example on how to use it:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(layer_swg, src_w, dst_w, _weight)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where _weight is exactly what you would pass to the add_edge! method that acts on SimpleWeightedGraph after:","category":"page"},{"location":"","page":"Home","title":"Home","text":"simpleweightedgraph = SimpleWeightedGraph(5, 0)\nadd_edge!(simpleweightedgraph, 1, 2, _weight)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If an underlying graph has an add_edge! interface whose signature overlaps with that of the uniform interface, the uniform interface will prevail.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If, using the transparent interface, one does not specify any weight or (inclusively) metadata keyword argument, the default_edge_weight or (inclusively) the default_edge_metadata function passed to the subgraph's constructor will be called to provide weight or metadata to the edge (type ?Layer in the REPL for more information).","category":"page"},{"location":"","page":"Home","title":"Home","text":"To remove the edge, simply do:","category":"page"},{"location":"","page":"Home","title":"Home","text":"rem_edge!(layer_swg, src_w, dst_w) # Returns true if succeeds","category":"page"},{"location":"","page":"Home","title":"Home","text":"To extract weight:","category":"page"},{"location":"","page":"Home","title":"Home","text":"get_weight(layer_swg, src_w, dst_w)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For an edge with metadata, it would be analogous. Let's define an edge with metadata:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Define an edge with metadata for the layer_mg\n## Define the metadata\n_metadata  = (meta = \"mymetadata\",)\n## Select two non-adjacent vertices in layer_mg\n_, src_m, dst_m  = _get_srcmv_dstmv_layer(layer_mg)\n## Construct a MultilayerEdge with metadata\nme_m = ME(src_m, dst_m, _metadata)","category":"page"},{"location":"","page":"Home","title":"Home","text":"ME(MV(Node(\"node_6\"), :layer_mg, NamedTuple()) --> MV(Node(\"node_5\"), :layer_mg, NamedTuple()),\tweight = nothing,\tmetadata = (meta = \"mymetadata\",))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then the following three signatures would be equivalent:","category":"page"},{"location":"","page":"Home","title":"Home","text":"standard interface:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(layer_mg, me_m)","category":"page"},{"location":"","page":"Home","title":"Home","text":"uniform interface:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(layer_mg, src_m, dst_m, metadata = _metadata)","category":"page"},{"location":"","page":"Home","title":"Home","text":"transparent interface","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(layer_mg, src_m, dst_m, Dict(pairs(_metadata)))","category":"page"},{"location":"","page":"Home","title":"Home","text":"To extract metadata:","category":"page"},{"location":"","page":"Home","title":"Home","text":"get_metadata(layer_mg, src_m, dst_m)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the layer_swg, the following three signatures would be equivalent:","category":"page"},{"location":"","page":"Home","title":"Home","text":"standard interface:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(layer_swg, me_w)","category":"page"},{"location":"","page":"Home","title":"Home","text":"uniform interface:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(layer_swg, src_w, dst_w, weight = _weight)","category":"page"},{"location":"","page":"Home","title":"Home","text":"transparent interface","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(layer_swg, src_w, dst_w, _weight)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The uniform interface of add_edge! works so that the user may specify the keyword weight and/or the keyword metadata. If an underlying subgraph has a transparent interface whose signature overlaps with that of the uniform interface, the uniform interface will be prevail.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The edge may be removed via","category":"page"},{"location":"","page":"Home","title":"Home","text":"rem_edge!(layer_swg, src_w, dst_w)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A complete list of methods relating to subgraphs can be found here.","category":"page"},{"location":"#Multilayer-Graphs","page":"Home","title":"Multilayer Graphs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Given all the Layers and the Interlayers, let's instantiate a multilayer graph as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayergraph = MultilayerGraph(  layers,                                                 # The (ordered) list of layers the multilayer graph will have\n                                    interlayers;                                            # The list of interlayers specified by the user. Note that the user does not need to specify all interlayers, as the unspecified ones will be automatically constructed using the indications given by the `default_interlayers_null_graph` and `default_interlayers_structure` keywords.\n                                    default_interlayers_null_graph = SimpleGraph{vertextype}(), # Sets the underlying graph for the interlayers that are to be automatically specified.  Defaults to `SimpleGraph{T}()`, where `T` is the `T` of all the `layers` and `interlayers`. See the `Layer` constructors for more information.\n                                    default_interlayers_structure = \"multiplex\" # Sets the structure of the interlayers that are to be automatically specified. May be \"multiplex\" for diagonally coupled interlayers, or \"empty\" for empty interlayers (no edges).  \"multiplex\". See the `Interlayer` constructors for more information.\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"`MultilayerGraph` with vertex type `Int64` and weight type `Float64`.\n\n### LAYERS\n\n   NAME                                                                    UNDERLYING GRAPH                                                                \n\n layer_sg                                                                 SimpleGraph{Int64}                                                               \n\n layer_swg                                                       SimpleWeightedGraph{Int64, Float64}                                                       \n\n layer_mg                                                             MetaGraph{Int64, Float64}                                                            \n\n layer_vg   ValGraph{Int64, Tuple{String}, Tuple{Float64, String}, Tuple{}, Tuple{Vector{String}}, Tuple{Vector{Vector{Float64}}, Vector{Vector{String}}}} \n\n\n\n### INTERLAYERS\n\n             NAME                LAYER 1    LAYER 2                                                                UNDERLYING GRAPH                                                               TRANSFER VERTEX METADATA \n\n interlayer_layer_sg_layer_swg  layer_sg   layer_swg                                                              SimpleGraph{Int64}                                                                       false           \n\n interlayer_layer_sg_layer_mg   layer_sg   layer_mg   ValGraph{Int64, Tuple{}, NamedTuple{(:from_to,), Tuple{String}}, Tuple{}, Tuple{}, NamedTuple{(:from_to,), Tuple{Vector{Vector{String}}}}}           false           \n\n interlayer_layer_swg_layer_mg  layer_swg  layer_mg                                                      SimpleWeightedGraph{Int64, Float64}                                                               false           \n\n interlayer_layer_sg_layer_vg   layer_sg   layer_vg                                                               SimpleGraph{Int64}                                                                       false           \n\n interlayer_layer_vg_layer_swg  layer_vg   layer_swg                                                              SimpleGraph{Int64}                                                                       false           \n\n interlayer_layer_mg_layer_vg   layer_mg   layer_vg                                                           MetaGraph{Int64, Float64}                                                                     true           \n","category":"page"},{"location":"","page":"Home","title":"Home","text":"Keep in mind that Multilayer(Di)Graph only supports uniform and standard interface for both add_vertex! and add_edge!.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As already stated, a MultilayerGraph is an object made of Layers and Interlayers whose collections of vertices each represents a subset of the set of nodes, here being the variable nodes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Adding a Node to a MultilayerGraph will enable its Layers  (and thus its Interlayers) to represent it i.e. you will be able to add MultilayerVertexs that represent that Node to the multilayer graph.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Another constructor allows for a limited configuration model-like specification. It allows to generate a multilayer graph with a specific degree distribution. Since edges are created according to the provided distribution, it is necessary that the layers and interlayers specified are empty (i.e. they have no edges). Notice that layers and interlayers whose underlying graph is a SimpleWeighted(Di)Graph may not be used until this PR is merged.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is used as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# The configuration model-like constructor will be responsible for creating the edges, so we need to provide it with empty layers and interlayers.\n# To create empty layers and interlayers, we will empty the above subgraphs, and, for compatibility reasons, we'll remove the ones having a `SimpleWeightedGraph`s. These lines are not necessary to comprehend the tutorial, they may be skipped. Just know that the variables `empty_layers` and `empty_interlayers` are two lists of, respectively, empty layers and interlayers that do not have `SimpleWeightedGraph`s as their underlying graphs\n\nempty_layers =  deepcopy([layer for layer in layers if !(layer.graph isa SimpleWeightedGraphs.AbstractSimpleWeightedGraph)])\n\nempty_layers_names = name.(empty_layers)\n\nempty_interlayers =  deepcopy([interlayer for interlayer in interlayers if all(in.(interlayer.layers_names, Ref(empty_layers_names))) && !(interlayer.graph isa SimpleWeightedGraphs.AbstractSimpleWeightedGraph) ])\n\nfor layer in empty_layers\n    for edge in edges(layer)\n        rem_edge!(layer, edge)\n    end\nend\n\nfor interlayer in empty_interlayers\n    for edge in edges(interlayer)\n        rem_edge!(interlayer, edge)\n    end\nend\n\n# Construct a multilayer graph that has a normal degree distribution. The support of the distribution must be positive, since negative degrees are not possible\nconfiguration_multilayergraph = MultilayerGraph(empty_layers, empty_interlayers, truncated(Normal(10), 0.0, 20.0));","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that this is not an implementation of a fully-fledged configuration model, which would require to be able to specify a degree distribution for every dimension of multiplexity. Moreover, it still lacks the ability to specify a minimum discrepancy (w.r.t. a yet-to-be-chosen metric) between the empirical distributions of the sampled sequence and the provided theoretical distribution. Please refer to Future Developments.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There is a similar constructor for MultilayerDiGraph which requires both the indegree distribution and the outdegree distribution. Anyway due to current performance limitations in the graph realization algorithms, it is suggested to provide two \"similar\" distributions (similar mean or location parameter, similar variance or shape parameter), in order not to incur in lengthy computational times.  ","category":"page"},{"location":"#[Nodes](@ref-nodes_tut_multig)","page":"Home","title":"Nodes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You may add a node via add_node:","category":"page"},{"location":"","page":"Home","title":"Home","text":"new_node = Node(\"new_node\")\nadd_node!(multilayergraph, new_node) # Return true if succeeds","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now one may add vertices that represent that node, e.g.:","category":"page"},{"location":"","page":"Home","title":"Home","text":"new_vertex = MV(new_node, :layer_sg)\nadd_vertex!(multilayergraph, new_vertex)","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"","page":"Home","title":"Home","text":"And remove the node via rem_node!:","category":"page"},{"location":"","page":"Home","title":"Home","text":"rem_node!(multilayergraph, new_node) # Return true if succeeds","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"#Modifying-edge-weight-and-metadata-and-vertex-metadata","page":"Home","title":"Modifying edge weight and metadata and vertex metadata","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"One may modify the weight of the edge of a multilayer graph via the set_weight! function. The call will succeed only if the edge that is acted upon exists and belongs to a weighted subgraph:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# This will succeed\nrandom_weighted_edge = rand(collect(edges(multilayergraph.layer_swg)))\nset_weight!(multilayergraph, src(random_weighted_edge), dst(random_weighted_edge), rand())","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"","page":"Home","title":"Home","text":"# This will not succeed\nrandom_unweighted_edge = rand(collect(edges(multilayergraph.layer_sg)))\nset_weight!(multilayergraph, src(random_unweighted_edge), dst(random_unweighted_edge), rand())","category":"page"},{"location":"","page":"Home","title":"Home","text":"false","category":"page"},{"location":"","page":"Home","title":"Home","text":"Equivalent arguments can be made for set_metadata! (both vertex and edge dispatches).","category":"page"},{"location":"#Adding,-Removing,-Modifying-and-Accessing-layers-and-interlayers","page":"Home","title":"Adding, Removing, Modifying and Accessing layers and interlayers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"One may of course add layers on the fly:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Instantiate a new Layer\n_nv, _ne = rand_nv_ne_layer(min_vertices,max_vertices)\nnew_layer = Layer(  :new_layer,\n                    sample(nodes_list, _nv, replace = false),\n                    _ne,\n                    SimpleGraph{vertextype}(),\n                    _weighttype\n)\n\n# Add the Layer\nadd_layer!(\n            multilayergraph,                                # the `Multilayer(Di)Graph` which the new layer will be added to;\n            new_layer;                                      # the new `Layer` to add to the `multilayergraph`\n            default_interlayers_null_graph = SimpleGraph{vertextype}(), # upon addition of a new `Layer`, all the `Interlayer`s between the new and the existing `Layer`s are immediately created. This keyword argument specifies their `null_graph` See the `Layer` constructor for more information. Defaults to `SimpleGraph{T}()`\n            default_interlayers_structure = \"empty\"         # The structure of the `Interlayer`s created by default. May either be \"multiplex\" to have diagonally-coupled only interlayers, or \"empty\" for empty interlayers. Defaults to \"multiplex\".\n)\n\n# Check that the new layer now exists within the multilayer graph\nhas_layer(multilayergraph, :new_layer)","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"","page":"Home","title":"Home","text":"The add_layer! function will automatically instantiate all the Interlayers between the newly added Layer and the Layers already present in the multilayer graph, according to its kwargs default_interlayers_null_graph and default_interlayers_structure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you wish to manually specify an interlayer, just do:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Instantiate a new Interlayer. Notice that its name will be given by default as\n_ne = rand_ne_interlayer(layer_sg, new_layer)\nnew_interlayer = Interlayer(    layer_sg,                \n                                new_layer,               \n                                _ne,                     \n                                SimpleGraph{vertextype}(),\n                                interlayer_name = :new_interlayer\n)\n\n# Modify an existing interlayer with the latter i.e. specify the latter interlayer:\nspecify_interlayer!( multilayergraph,\n                     new_interlayer)\n\n# Now the interlayer between `layer_sg` and `new_layer` is `new_interlayer`","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"","page":"Home","title":"Home","text":"Suppose that, after some modifications of multilayergraph, you would like to inspect a particular slice (or subgraph) of it (i.e. a Layer or an Interlayer). You may use both layers and interlayers names as properties of the multilayer graph itself.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Get a layer by name\nmultilayergraph.new_layer","category":"page"},{"location":"","page":"Home","title":"Home","text":"Layer   new_layer\nunderlying_graph: SimpleGraph{Int64}\nvertex type: Int64\nweight type: Float64\nnv = 7\nne = 11","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Get an Interlayer by name\nmultilayergraph.new_interlayer","category":"page"},{"location":"","page":"Home","title":"Home","text":"Interlayer      new_interlayer\nlayer_1: layer_sg\nlayer_2: new_layer\nunderlying graph: SimpleGraph{Int64}\nvertex type : Int64\nweight type : Float64\nnv : 14\nne : 46","category":"page"},{"location":"","page":"Home","title":"Home","text":"Interlayers may also be accessed by remembering the names of the Layers they connect:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Get an Interlayer from the names of the two layers that it connects\nget_interlayer(multilayergraph, :new_layer, :layer_sg )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Interlayer      new_interlayer_rev\nlayer_1: new_layer\nlayer_2: layer_sg\nunderlying graph: SimpleGraph{Int64}\nvertex type : Int64\nweight type : Float64\nnv : 14\nne : 46","category":"page"},{"location":"","page":"Home","title":"Home","text":"NB: Although the interlayer from an arbitrary layer_1 to layer_2 is the same mathematical object as the interlayer from layer_2 to layer_1, their representations as Interlayers differ in the internals, and most notably in the order of the vertices. The Interlayer from layer_1 to layer_2 orders its vertices so that the MultilayerVertexs of layer_1 (in the order they were in layer_1 when the Interlayer was instantiated) come before the MultilayerVertexs of layer_2 (in the order they were in layer_2 when the Interlayer was instantiated).","category":"page"},{"location":"","page":"Home","title":"Home","text":"When calling get_interlayer(multilayergraph, :layer_1, :layer_2) it is returned the Interlayer from layer_1 to layer_2. If the Interlayer from layer_2 to layer_1 was manually specified or automatically generated during the instantiation of the multilayer graph with name, say, \"some_interlayer\", then the returned Interlayer will be named \"some_interlayer_rev\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"To remove a layer:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Remove the layer. This will also remove all the interlayers associated to it.\nrem_layer!( multilayergraph,\n            :new_layer;\n            remove_nodes = false # Whether to also remove all nodes represented in the to-be-removed layer from the multilayer graph\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"","page":"Home","title":"Home","text":"Visit the multilayer graph subsection of the edn-user APIs to discover more useful methods.","category":"page"},{"location":"#Weight/Adjacency-Tensor,-Metadata-Tensor-and-Supra-Weight/Adjacency-Matrix","page":"Home","title":"Weight/Adjacency Tensor, Metadata Tensor and Supra Weight/Adjacency Matrix","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"One may extract the weight tensor of a multilayergraph via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"wgt = weight_tensor(multilayergraph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"WeightTensor{Float64}([0.0 0.0  0.0 0.0; 0.0 0.0  0.0 0.0;  ; 0.0 0.0  0.0 0.0; 0.0 0.0  0.0 0.0;;; 0.0 1.0  0.0 0.0; 1.0 1.0  0.0 0.0;  ; 0.0 0.0  0.0 0.0; 0.0 1.0  1.0 0.0;;; 1.0 0.0  0.0 0.0; 0.0 0.0  0.0 0.0;  ; 0.0 0.0  1.0 0.0; 0.0 0.0  0.0 0.0;;; 0.0 0.0  0.0 0.0; 0.0 0.0  0.0 0.0;  ; 0.0 0.0  0.0 0.0; 0.0 0.0  0.0 0.0;;;; 0.0 1.0  0.0 0.0; 1.0 1.0  0.0 1.0;  ; 0.0 0.0  0.0 1.0; 0.0 0.0  0.0 0.0;;; 0.0 0.9828581516714545  0.0 0.7736606234481569; 0.9828581516714545 0.0  0.0 0.0;  ; 0.0 0.0  0.0 0.0; 0.7736606234481569 0.0  0.0 0.0;;; 0.19989407135094706 0.0  0.0 0.16650315003660054; 0.0 0.0  0.0 0.0;  ; 0.0 0.6643136923736794  0.0 0.0; 0.40879510776523964 0.7458197468092816  0.0 0.0;;; 1.0 0.0  0.0 0.0; 0.0 0.0  0.0 0.0;  ; 0.0 0.0  0.0 0.0; 0.0 0.0  0.0 1.0;;;; 1.0 0.0  0.0 0.0; 0.0 0.0  0.0 0.0;  ; 0.0 0.0  1.0 0.0; 0.0 0.0  0.0 0.0;;; 0.19989407135094706 0.0  0.0 0.40879510776523964; 0.0 0.0  0.6643136923736794 0.7458197468092816;  ; 0.0 0.0  0.0 0.0; 0.16650315003660054 0.0  0.0 0.0;;; 0.0 0.0  0.0 1.0; 0.0 0.0  0.0 0.0;  ; 0.0 0.0  0.0 0.0; 1.0 0.0  0.0 0.0;;; 1.0 0.0  1.0 1.0; 0.0 0.0  0.0 0.0;  ; 0.0 0.0  1.0 0.0; 0.0 0.0  1.0 1.0;;;; 0.0 0.0  0.0 0.0; 0.0 0.0  0.0 0.0;  ; 0.0 0.0  0.0 0.0; 0.0 0.0  0.0 0.0;;; 1.0 0.0  0.0 0.0; 0.0 0.0  0.0 0.0;  ; 0.0 0.0  0.0 0.0; 0.0 0.0  0.0 1.0;;; 1.0 0.0  0.0 0.0; 0.0 0.0  0.0 0.0;  ; 1.0 0.0  1.0 1.0; 1.0 0.0  0.0 1.0;;; 0.0 0.0  1.0 0.0; 0.0 0.0  0.0 0.0;  ; 1.0 0.0  0.0 1.0; 0.0 0.0  1.0 0.0], [:layer_sg, :layer_swg, :layer_mg, :layer_vg], Bijection{Int64,Node} (with 7 pairs))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that wgt is an object of type WeightTensor. You may access its array representation using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"array(wgt)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also, you may index it using MultilayerVertexs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Get two random vertices from the MultilayerGraph\nmv1, mv2 = rand(mv_vertices(multilayergraph), 2)\n\n# Get the strength of the edge between them (0 for no edge):\nwgt[mv1, mv2]","category":"page"},{"location":"","page":"Home","title":"Home","text":"0.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similarly, there is a MetadataTensor, that may be created via metadata_tensor(multilayergraph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package also exports a SupraWeightMatrix which is a supra (weighted) adjacency matrix with the same indexing functionality as above. You may instantiate it via supra_weight_matrix(multilayergraph).","category":"page"},{"location":"#Sub-ecosystem","page":"Home","title":"Sub-ecosystem","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Special applications may not require all the representational generality enabled by Multilayer(Di)Graphs, and, on the contrary, could benefit from the simpler interface and higher performance that come with restricted subtypes of multilayer graphs (e.g. multiplex graphs, edge-colored graph, etc).","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraphs.jl, via an apporoach that combines type-hierarchy with traits, allows for implementing custom multilayer graphs (similar to what Graphs.jl does). This feature has been initially proven with the implementation of SynchronizedEdgeColoredGraph and SynchronizedEdgeColoredDiGraph, which aim at representing edge-colored graphs by naturally mapping them to multilayer graphs.","category":"page"},{"location":"#Multilayer-specific-analytical-tools","page":"Home","title":"Multilayer-specific analytical tools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Read a complete list of analytical methods exclusive to multilayer graphs in the dedicated API section (here \"exclusive\" means that wither those methods do not exists for standard graphs, or that they had to be reimplemented and so may present some caveats). Refer to their docstrings for more information.","category":"page"},{"location":"#Compatibility-with-Agents.jl","page":"Home","title":"Compatibility with Agents.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multilayer(Di)Graphs may be used as an argument to GraphSpace in Agents.jl. A complete compatibility example may be found in this test.","category":"page"},{"location":"#Future-Developments","page":"Home","title":"Future Developments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All the information regarding the future developments of MultilayerGraphs.jl can be found in the issues.","category":"page"},{"location":"#How-to-Contribute","page":"Home","title":"How to Contribute","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The ongoing development of this package would greatly benefit from the valuable feedback of the esteemed members of the JuliaGraph community, as well as from graph theorists, network scientists, and any users who may have general questions or suggestions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We therefore encourage you to participate in discussions, raise issues, or submit pull requests. Your contributions are most welcome!","category":"page"},{"location":"#How-to-Cite","page":"Home","title":"How to Cite","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you utilize this package in your project, please consider citing this repository using the citation information provided in CITATION.bib. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will help to give appropriate credit to the contributors and support the continued development of the package.","category":"page"},{"location":"#Announcements","page":"Home","title":"Announcements","text":"","category":"section"},{"location":"#v0.1","page":"Home","title":"v0.1","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraphs.jl (v0.1) and its features were announced on the following platforms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Discourse;\nForem;\nTwitter.","category":"page"},{"location":"#v1.1","page":"Home","title":"v1.1","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraphs.jl (v1.1) and its features were announced on the following platforms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Discourse;\nForem;\nTwitter.","category":"page"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"#R","page":"Home","title":"R","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here is a list of software packages for the creation, manipulation, analysis and visualisation of multilayer graphs implemented in the R language: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"muxViz implements functions to perform multilayer correlation analysis, multilayer centrality analysis, multilayer community structure detection, multilayer structural reducibility, multilayer motifs analysis and utilities to statically and dynamically visualise multilayer graphs;\nmultinet implements functions to import, export, create and manipulate multilayer graphs, several state-of-the-art multiplex graph analysis algorithms for centrality measures, layer comparison, community detection and visualization;\nmully implements functions to import, export, create, manipulate and merge multilayer graphs and utilities to visualise multilayer graphs in 2D and 3D;\nmultinets implements functions to import, export, create, manipulate multilayer graphs and utilities to visualise multilayer graphs.","category":"page"},{"location":"#Python","page":"Home","title":"Python","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here is a list of software packages for the creation, manipulation, analysis and visualisation of multilayer graphs implemented in the Python language: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultiNetX implements methods to create undirected networks with weighted or unweighted links, to analyse the spectral properties of adjacency or Laplacian matrices and to visualise multilayer graphs and dynamical processes by coloring the nodes and links accordingly;\nPyMNet implements data structures for multilayer graphs and multiplex graphs, methods to import, export, create, manipulate multilayer graphs and for the rule-based generation and lazy-evaluation of coupling edges and utilities to visualise multilayer graphs.","category":"page"},{"location":"#Julia","page":"Home","title":"Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"At the best of our knowledge there are currently no software packages dedicated to the creation, manipulation and analysis of multilayer graphs implemented in the Julia language apart from MultilayerGraphs.jl itself.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"De Domenico et al. (2013) Mathematical Formulation of Multilayer Networks. Physical Review X; \nKivel et al. (2014) Multilayer networks. Journal of Complex Networks; \nBoccaletti et al. (2014) The structure and dynamics of multilayer networks. Physics Reports; \nLee et al. (2015) Towards real-world complexity: an introduction to multiplex networks. The European Physical Journal B; \nBianconi (2018) Multilayer Networks: Structure and Function. Oxford University Press;\nCozzo et al. (2018) Multiplex Networks: Basic Formalism and Structural Properties. SpringerBriefs in Complexity; \nAleta and Moreno (2019) Multilayer Networks in a Nutshell. Annual Review of Condensed Matter Physics; \nArtime et al. (2022) Multilayer Network Science: From Cells to Societies. Cambridge University Press; \nDe Domenico (2022) Multilayer Networks: Analysis and Visualization. Springer Cham. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: De Domenico  et al. (2013); Kivel et al. (2014); Boccaletti et al. (2014); Lee et al. (2015); Aleta and Moreno (2019); Bianconi (2018); Cozzo et al. (2018); Artime et al. (2022); De Domenico (2022).","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: Cozzo et al. (2013); Granell et al. (2013); Massaro and Bagnoli (2014); Estrada and Gomez-Gardenes (2014); Azimi-Tafreshi (2016); Baggio et al. (2016); DeDomenico et al. (2016); Amato et al. (2017); DeDomenico (2017); Pilosof et al. (2017); de Arruda et al. (2017); Gosak et al. (2018); Soriano-Panos et al. (2018); Timteo et al. (2018); Buld et al. (2018); Lim et al. (2019); Mangioni et al. (2020); Aleta et al. (2020); Aleta et al. (2022)).","category":"page"}]
}
