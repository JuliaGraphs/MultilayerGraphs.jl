var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MultilayerGraphs","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div style=\"width:100%; height:150px;border-width:4px;border-style:solid;padding-top:25px;\n        border-color:#000;border-radius:10px;text-align:center;background-color:#B3D8FF;\n        color:#000\">\n    <h3 style=\"color: black;\">Star us on GitHub!</h3>\n    <a class=\"github-button\" href=\"https://github.com/InPhyT/MultilayerGraphs.jl\" data-icon=\"octicon-star\" data-size=\"large\" data-show-count=\"true\" aria-label=\"Star InPhyT/MultilayerGraphs.jl on GitHub\" style=\"margin:auto\">Star</a>\n    <script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n</div>","category":"page"},{"location":"#MultilayerGraphs.jl","page":"Home","title":"MultilayerGraphs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraphs.jl is a Julia package for the construction, manipulation and analysis of multilayer graphs extending Graphs.jl.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraphs.jl implements the mathematical formulation of multilayer graphs proposed by De Domenico et al. (2013). It mainly revolves around two custom types, MultilayerGraph and MultilayerDiGraph, encoding undirected and directed multilayer graphs respectively.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Roughly speaking, a multilayer graph is a collection of layers, i.e. graphs whose vertices are representations of the same set of nodes, and interlayers, i.e the bipartite graphs whose vertices are those of any two layers and whose edges are those between vertices of the same two layers. See below for the distinction between ***nodes*** and ***vertices***.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraph and MultilayerDiGraph are fully-fledged Graphs.jl extensions. Both structs are designed so that their layers and interlayers can be of any type (as long as they are Graphs.jl extensions themselves) and they need not be all of the same type. It is anyway required that all layers and interlayers of MultilayerGraph and MultilayerDiGraph are respectively undirected and directed. Directedness is checked via the IsDirected trait defined in Graphs.jl adopting SimpleTraits.jl. Since the layers' and interlayers' graph types don't need to be the same, multilayer graph types are considered weighted graphs by default, and thus are assigned the trait IsWeighted.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Press ] in the Julia REPL and then","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/InPhyT/MultilayerGraphs.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Registration is in progress.","category":"page"},{"location":"#Tutorial","page":"Home","title":"Tutorial","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here we illustrate how to define, handle and analyse a MultilayerGraph (the directed version is completely analogous).","category":"page"},{"location":"#Layers-and-Interlayers","page":"Home","title":"Layers and Interlayers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's import some necessary packages","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Import necessary dependencies\nusing Graphs, SimpleWeightedGraphs, MultilayerGraphs","category":"page"},{"location":"","page":"Home","title":"Home","text":"We define some methods and constants that will prove useful later in the tutorial","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Set the number of nodes, minimum and maximum number of edges for random graphs\nconst n_nodes   = 5\nconst min_edges = n_nodes\nconst max_edges = 10\n\n# Define methods generating random graphs\nget_SimpleGraph()   = SimpleGraph(n_nodes, rand(min_edges:max_edges))   # Undirected graph\nget_SimpleDiGraph() = SimpleDiGraph(n_nodes, rand(min_edges:max_edges)) # Directed graph\n\n# Define variables for random weighted graphs\nconst simpleweightedgraph_sources      = 1:n_nodes\nconst simpleweightedgraph_destinations = rand(1:n_nodes, n_nodes)\nconst simpleweightedgraph_weights      = rand(n_nodes)\n\n# Define methods generating random weighted graphs\nget_SimpleWeightedGraph()   = SimpleWeightedGraph(simpleweightedgraph_sources, rand(1:n_nodes, n_nodes), rand(n_nodes))    # Undirected graph\nget_SimpleWeightedDiGraph() = SimpleWeightedDiGraph(simpleweightedgraph_sources, rand(1:n_nodes, n_nodes), rand(n_nodes))  # Directed graph","category":"page"},{"location":"","page":"Home","title":"Home","text":"As said before, to define a multilayer graph we need to specify its layers and interlayers. We proceed by constructing a layer (see Layer)","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Construct a layer\nlayer = Layer(:layer_1, SimpleGraph(n_nodes, rand(min_edges:max_edges)); U = Float64)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Layer has a name (here :layer_1), an underlying graph (SimpleGraph(n_nodes, rand(min_edges:max_edges))) and a weight matrix eltype U (it defaults to the adjacency matrix's eltype if the graph is unweighted). To correctly specify a multilayer graph all layers and interlayers must have the same U, otherwise the multilayers's adjacency tensor would be poorly specified.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Notice that U does not need to coincide with the eltype of the adjacency matrix of the underlying graph: as far as we know, there is no way to set it explicitly for all Graphs.jl extensions, nor it is required for extensions to implement such feature, so our package converts to U the eltype of Layers and Interlayers weight (/adjacency) matrices every time they are invoked","category":"page"},{"location":"","page":"Home","title":"Home","text":"adjacency_matrix(layers[1])","category":"page"},{"location":"","page":"Home","title":"Home","text":"5×5 SparseMatrixCSC{Float64, Int64} with 16 stored entries:\n  ⋅   1.0   ⋅   1.0  1.0\n 1.0   ⋅   1.0  1.0   ⋅\n  ⋅   1.0   ⋅   1.0  1.0\n 1.0  1.0  1.0   ⋅   1.0\n 1.0   ⋅   1.0  1.0   ⋅","category":"page"},{"location":"","page":"Home","title":"Home","text":"We may define more Layers for future use","category":"page"},{"location":"","page":"Home","title":"Home","text":"layers = [\n            Layer(:layer_1, get_SimpleGraph(); U = Float64),\n            Layer(:layer_2, get_SimpleWeightedGraph(); U = Float64),\n            Layer(:layer_3, get_SimpleWeightedGraph(); U = Float64),\n         ]","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are other constructors for the Layer struct you may want to consult via ?Layer.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We similarly define an interlayer (see Interlayer)","category":"page"},{"location":"","page":"Home","title":"Home","text":"interlayer = Interlayer(n_nodes, :interlayer_layer_1_layer_2 , :layer_1, :layer_2, SimpleGraph{Int64}, rand(min_edges:max_edges); U = Float64)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here we used a constructor that returns a random Interlayer. Its arguments are the number of nodes n_nodes, the name of the Interlayer interlayer_layer_1_layer_2, the name of the Layers that it connects (:layer_1 and :layer_2), the underlying graph type SimpleGraph{Int64}, and the number of edges rand(min_edges:max_edges) and the weight/adjacency matrix eltype again needs to be specified (although it may be left blank and the constructor will default to eltype(adjacency_matrix(SimpleGraph{Int64}))).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The adjacency matrix of an Interlayer is that of a bipartite graph","category":"page"},{"location":"","page":"Home","title":"Home","text":"adjacency_matrix(interlayer)","category":"page"},{"location":"","page":"Home","title":"Home","text":"10×10 SparseMatrixCSC{Float64, Int64} with 18 stored entries:\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0\n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅   1.0  1.0   ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0  1.0   ⋅    ⋅   1.0\n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅\n  ⋅   1.0  1.0  1.0  1.0   ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n 1.0   ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is a 4 block matrix where the first n_nodes rows and columns refer to :layer_1's vertices, while the last n_nodes rows and columns refer to :layer_2's vertices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We may define more Interlayers for future use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"interlayers = [\n                Interlayer(n_nodes, :interlayer_layer_1_layer_2, :layer_1, :layer_2, SimpleGraph{Int64}, rand(min_edges:max_edges); U = Float64),\n                Interlayer(n_nodes, :interlayer_layer_1_layer_3, :layer_1, :layer_3, SimpleWeightedGraph{Int64,Float64}, rand(min_edges:max_edges))\n              ]","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are other constructors for the Interlayer struct you may want to consult via ?Interlayer.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Layers and Interlayers and complete extensions of Graphs.jl, so all methods in Graphs.jl should just work. The explicitly extended methods are edges, eltype, edgetype, has_edge, has_vertex, inneighbors, ne, nv, outneighbors, vertices, is_directed, add_edge!, rem_edge!.","category":"page"},{"location":"#Instantiation-and-Handling-of-MultilayerGraph","page":"Home","title":"Instantiation and Handling of MultilayerGraph","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We can define a MultilayerGraph by specifying its layers and interlayers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayergraph = MultilayerGraph(layers, interlayers; default_interlayer = \"multiplex\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraph{Int64, Float64}([0.0 1.0 … 1.0 1.0; 1.0 0.0 … 0.0 1.0; … ; 1.0 0.0 … 0.0 0.0; 1.0 1.0 … 0.0 0.0;;; 0.0 0.0 … 0.0 0.0; 0.0 1.0 …],...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is not important that the interlayers array contains all the interlayers needed to specify the multilayer graph: the unspecified interlayers are automatically generated according to the default_interlayer argument. Right now only the \"multiplex\" value is supported, and will generate interlayers that have edges between pair of vertices of the two layers that represent the same node.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Notice that in the output the signature of MultilayerGraph has two parametric types, namely MultilayerGraph{Int64, Float64}. The first is referred to the node type, that just as in every Graphs.jl extension it is a subtype of Integer. The second parameter is instead the eltype of the equivalent of the adjacency matrix for multilayer graphs: the adjacency tensor (see below for more).","category":"page"},{"location":"","page":"Home","title":"Home","text":"You may also specify random MultilayerGraph","category":"page"},{"location":"","page":"Home","title":"Home","text":"random_multilayergraph = MultilayerGraph( 3,         # Number of layers\n                                          n_nodes,   # Number of nodes\n                                          min_edges, # Minimum number of edges in each layer/interlayer\n                                          max_edges, # Maximum number of edges in each layer/interlayer\n                                          [\n                                             SimpleGraph{Int64},\n                                             SimpleWeightedGraph{Int64, Float64},\n                                          ]          # The set of graph types to random draw from when constructing layers and interlayers\n                                        )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, one may add layers and interlayers calling the add_layer! and specify_interlayer! functions respectively, perhaps starting with an empty multilayer graph created with the constructor:","category":"page"},{"location":"","page":"Home","title":"Home","text":"empty_multilayergraph  = MultilayerGraph( n_nodes, # Number of nodes\n                                          Int64,   # Node type\n                                          Float64  # Adjacency tensor's eltype, see below\n                                        )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's explore some properties of the MultilayerGraph struct.","category":"page"},{"location":"#Layers","page":"Home","title":"Layers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is an OrderedDict where the keys are the layers' indexes within the multilayer graph (the index is repeated twice in a tuple to be consistent with multilayergraph.interlayers' keys, see below) and the values are the actual Layers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayergraph.layers","category":"page"},{"location":"","page":"Home","title":"Home","text":"OrderedDict{Tuple{Int64, Int64}, Layer{Int64, U, G} where {U<:Real, G<:AbstractGraph{Int64}}} with 3 entries:\n  (1, 1) => Layer{Int64, Float64, SimpleGraph{Int64}}(:layer_1, SimpleGraph{Int64}(5, [[2, 4], [1, 3, 4], [2], [1, 2, 5], [4]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}}[])\n  (2, 2) => Layer{Int64, Float64, SimpleWeightedGraph{Int64, Float64}}(:layer_2, {5, 4} undirected simple Int64 graph with Float64 weights, MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}}[])\n  (3, 3) => Layer{Int64, Float64, SimpleWeightedGraph{Int64, Float64}}(:layer_3, {5, 4} undirected simple Int64 graph with Float64 weights, MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}}[])","category":"page"},{"location":"#Interlayers","page":"Home","title":"Interlayers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is an OrderedDict where each key is the pair of indexes of the layers that the corresponding value, i.e. the interlayer, connects within the multilayer graph","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayergraph.interlayers","category":"page"},{"location":"","page":"Home","title":"Home","text":"OrderedDict{Tuple{Int64, Int64}, Interlayer{Int64, U, G} where {U<:Real, G<:AbstractGraph{Int64}}} with 6 entries:\n  (2, 1) => Interlayer{Int64, Float64, SimpleGraph{Int64}}(:interlayer_layer_2_layer_1, :layer_2, :layer_1, SimpleGraph{Int64}(9, [[7, 8, 9, 10], [9], [7], [7], [6, 9], [5], [1, 3, 4], [1], [1, 2, 5], [1]]), MultilayerVertex{Int64}[], Tuple{MultilayerVerte…  \n  (1, 2) => Interlayer{Int64, Float64, SimpleGraph{Int64}}(:interlayer_layer_1_layer_2, :layer_1, :layer_2, SimpleGraph{Int64}(9, [[10], [6, 8, 9], [6], [6, 7, 10], [6], [2, 3, 4, 5], [4], [2], [2], [1, 4]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64},…  \n  (3, 1) => Interlayer{Int64, Float64, SimpleWeightedGraph{Int64, Float64}}(:interlayer_layer_3_layer_1, :layer_3, :layer_1, {10, 7} undirected simple Int64 graph with Float64 weights, MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVer…  \n  (1, 3) => Interlayer{Int64, Float64, SimpleWeightedGraph{Int64, Float64}}(:interlayer_layer_1_layer_3, :layer_1, :layer_3, {10, 4} undirected simple Int64 graph with Float64 weights, MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}…  \n  (3, 2) => Interlayer{Int64, Float64, SimpleGraph{Int64}}(:interlayer_layer_3_layer_2, :layer_3, :layer_2, SimpleGraph{Int64}(5, [[6], [7], [8], [9], [10], [1], [2], [3], [4], [5]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVert…  \n  (2, 3) => Interlayer{Int64, Float64, SimpleGraph{Int64}}(:interlayer_layer_2_layer_3, :layer_2, :layer_3, SimpleGraph{Int64}(5, [[6], [7], [8], [9], [10], [1], [2], [3], [4], [5]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVert…","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the (1,2) interlayer (i.e. the interlayer between layer (1,1) and layer (2,2)) is very similar to interlayer (2,1), but not identical: its adjacency matrix rows and columns are reordered. One may get interlayer (2,1) from interlayer (1,2) (i.e. one may get the symmetric interlayer of (1,2)) as follows","category":"page"},{"location":"","page":"Home","title":"Home","text":"symmetric_interlayer = get_symmetric_interlayer(multilayergraph.interlayers[(1,2)])\nsymmetric_interlayer == multilayergraph.interlayers[(2,1)]","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"","page":"Home","title":"Home","text":"You may access individual layers and interlayers with the \"dot\" notation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayergraph.layer_1","category":"page"},{"location":"","page":"Home","title":"Home","text":"Layer{Int64, Float64, SimpleGraph{Int64}}(:layer_1, SimpleGraph{Int64}(7, [[2, 3, 4, 5], [1, 4], [1, 5], [1, 2, 5], [1, 3, 4]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}}[])","category":"page"},{"location":"#Adjacency-Tensor","page":"Home","title":"Adjacency Tensor","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The adjacency tensor is a 4-dimensional array","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayergraph.adjacency_tensor","category":"page"},{"location":"","page":"Home","title":"Home","text":"5×5×3×3 Array{Float64, 4}:\n...","category":"page"},{"location":"","page":"Home","title":"Home","text":"To understand its indexing, consider the following example","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayergraph.adjacency_tensor[1,5,2,3]","category":"page"},{"location":"","page":"Home","title":"Home","text":"0.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"This means that there is an edge of zero weight between the vertex representing node 1 in layer 5 and the vertex representing node 2 in layer 3. It is a good time to note the difference between nodes and vertices. In the context of multilayer graphs, the vertices of every layer and interlayer represent the same set of nodes. That is, vertex 1 in layer (1,1) represents the same node as vertex 1 in layer (2,2) and so on. To make this distinction clearer the package implements the MultilayerVertex type, that represents vertices within the multilayer graph. The implementation of MultilayerVertex is","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct MultilayerVertex{T <: Integer} <: AbstractMultilayerVertex{T}\n    node::T        # The node  the vertex represents\n    layer::Symbol  # The layer the vertex belongs to\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"To get the vertices of a Layer or an Interlayer, one may use the Graphs.jl APIs","category":"page"},{"location":"","page":"Home","title":"Home","text":"vertices(multilayergraph.layers[(1,1)])","category":"page"},{"location":"","page":"Home","title":"Home","text":"5-element Vector{MultilayerVertex{Int64}}:\n MultilayerVertex{Int64}(1, :layer_1)\n MultilayerVertex{Int64}(2, :layer_1)\n MultilayerVertex{Int64}(3, :layer_1)\n MultilayerVertex{Int64}(4, :layer_1)\n MultilayerVertex{Int64}(5, :layer_1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"vertices(multilayergraph.interlayers[(1,2)])","category":"page"},{"location":"","page":"Home","title":"Home","text":"10-element Vector{Any}:\n MultilayerVertex{Int64}(1, :layer_1)\n MultilayerVertex{Int64}(2, :layer_1)\n MultilayerVertex{Int64}(3, :layer_1)\n MultilayerVertex{Int64}(4, :layer_1)\n MultilayerVertex{Int64}(5, :layer_1)\n MultilayerVertex{Int64}(1, :layer_2)\n MultilayerVertex{Int64}(2, :layer_2)\n MultilayerVertex{Int64}(3, :layer_2)\n MultilayerVertex{Int64}(4, :layer_2)\n MultilayerVertex{Int64}(5, :layer_2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To get a specific layer of a multilayer graph from its name, one may also write","category":"page"},{"location":"","page":"Home","title":"Home","text":"layer_1 = get_layer(multilayergraph, :layer_1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Same for interlayers","category":"page"},{"location":"","page":"Home","title":"Home","text":"interlayer_2_1 = get_layer(multilayergraph, :interlayer_layer_2_layer_1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Both MultilayerGraph and MultilayerDiGraph fully extend Graphs.jl, so they have access to Graphs.jl API as one would expect, just keeping in mind that vertices are MultilayerVertexs and not subtypes of Integer (MultilayerVertex is actually a subtype of AbstractVertex that this package defines, see Future Developments), and that edges are MultilayerEdges, which subtype AbstractEdge.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some notable examples are","category":"page"},{"location":"","page":"Home","title":"Home","text":"edges(multilayergraph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"34-element Vector{MultilayerEdge}:\n MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(1, :layer_1), MultilayerVertex{Int64}(2, :layer_1), 1)\n MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(1, :layer_1), MultilayerVertex{Int64}(3, :layer_1), 1)\n MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(1, :layer_1), MultilayerVertex{Int64}(4, :layer_1), 1)\n MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(1, :layer_1), MultilayerVertex{Int64}(5, :layer_1), 1)\n MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(2, :layer_1), MultilayerVertex{Int64}(3, :layer_1), 1)\n MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(2, :layer_1), MultilayerVertex{Int64}(5, :layer_1), 1)\n MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(3, :layer_1), MultilayerVertex{Int64}(5, :layer_1), 1)\n MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(1, :layer_2), MultilayerVertex{Int64}(1, :layer_2), 0.7188425521261754)\n MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(2, :layer_2), MultilayerVertex{Int64}(3, :layer_2), 0.9012061650463197)\n MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(2, :layer_2), MultilayerVertex{Int64}(4, :layer_2), 0.6163304419976594)\n MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(3, :layer_2), MultilayerVertex{Int64}(5, :layer_2), 1.0046265072746847)\n MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(1, :layer_3), MultilayerVertex{Int64}(2, :layer_3), 0.2819477742859873)\n MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(2, :layer_3), MultilayerVertex{Int64}(4, :layer_3), 0.40111133874926597)\n MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(3, :layer_3), MultilayerVertex{Int64}(4, :layer_3), 0.9498077050078636)\n MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(1, :layer_3), MultilayerVertex{Int64}(5, :layer_3), 0.9618455695308973)\n ⋮","category":"page"},{"location":"","page":"Home","title":"Home","text":"The implementation of MultilayerEdge is","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct MultilayerEdge{ T <: MultilayerVertex, U <: Union{ <: Real, Nothing}} <: AbstractMultilayerEdge{T} # AbstractMultilayerEdge{T} subtypes AbstractEdge\n    src::T    # The source vertex\n    dst::T    # The destination vertex\n    weight::U # The edge weight. Can be `nothing` to signify an unweighted edge, or a Real\nend","category":"page"},{"location":"#Other-Example-APIs","page":"Home","title":"Other Example APIs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's showcase some other key functionalities.","category":"page"},{"location":"#Get-the-node-type","page":"Home","title":"Get the node type","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"eltype(multilayergraph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Int64","category":"page"},{"location":"#Get-the-edge-type","page":"Home","title":"Get the edge type","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"edgetype(multilayergraph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultilayerEdge{MultilayerVertex{Int64}, Float64}","category":"page"},{"location":"#Check-whether-an-edge-exists","page":"Home","title":"Check whether an edge exists","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"has_edge(multilayergraph, MultilayerVertex(1, :layer_1), MultilayerVertex(4, :layer_2))","category":"page"},{"location":"","page":"Home","title":"Home","text":"false","category":"page"},{"location":"#Remove-an-edge","page":"Home","title":"Remove an edge","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"rem_edge! mimics the behaviour of the analogous function in Graphs.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"rem_edge!(multilayergraph, MultilayerVertex(1, :layer_1), MultilayerVertex(2, :layer_2))","category":"page"},{"location":"","page":"Home","title":"Home","text":"The multilayer doesn't have any edge between MultilayerVertex{Int64}(1, :layer_1) and MultilayerVertex{Int64}(2, :layer_2)\nfalse","category":"page"},{"location":"","page":"Home","title":"Home","text":"The message tells us that the edge was already non existent. In fact, if we check the adjacency_tensor in the corresponding entry, we see that","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayergraph.adjacency_tensor[1,2,1,2]","category":"page"},{"location":"","page":"Home","title":"Home","text":"0.0","category":"page"},{"location":"#Add-an-edge","page":"Home","title":"Add an edge","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We may add an edge using the add_edge! function. Since the interlayer we are adding the edge has an unweighted underlying graph (we will say that the interlayer is unweighted), we have to add an unweighted edge, so we don't specify the weight after the vertices. The adjacency tensor will be updated with a one(U) in the correct position. add_edge! mimics the behaviour of the analogous function in Graphs.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(multilayergraph, MultilayerVertex(1, :layer_1), MultilayerVertex(2, :layer_2))","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"","page":"Home","title":"Home","text":"To add a weighted edge we just need to write","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(multilayergraph,  MultilayerEdge(MultilayerVertex(1, :layer_1), MultilayerVertex(2, :layer_3), 3.14))","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"#Get-the-inneighbors","page":"Home","title":"Get the inneighbors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To get all the inneighbors of a vertex we just need to write","category":"page"},{"location":"","page":"Home","title":"Home","text":"inneighbors(multilayergraph, MultilayerVertex(1, :layer_1))","category":"page"},{"location":"","page":"Home","title":"Home","text":"8-element Vector{MultilayerVertex{Int64}}:\n MultilayerVertex{Int64}(2, :layer_1)\n MultilayerVertex{Int64}(3, :layer_1)\n MultilayerVertex{Int64}(4, :layer_1)\n MultilayerVertex{Int64}(5, :layer_1)\n MultilayerVertex{Int64}(1, :layer_3)\n MultilayerVertex{Int64}(2, :layer_3)\n MultilayerVertex{Int64}(4, :layer_3)\n MultilayerVertex{Int64}(5, :layer_3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"outneighbors would be analogous.","category":"page"},{"location":"#Get-the-global-clustering-coefficient","page":"Home","title":"Get the global clustering coefficient","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"multilayer_global_clustering_coefficient(multilayergraph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"0.12667622867320932","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since our implementation of the global clustering coefficient follows De Domenico et al. (2013) rather than Graphs.jl's implementation, we did not override Graphs.jl's global_clustering_coefficient, which works on MultilayerGraph and MultilayerDiGraph but yields different results. For details, consult ?multilayer_global_clustering_coefficient or read the comments in the source code.","category":"page"},{"location":"#Multilayer-Specific-Functions-and-Analysis","page":"Home","title":"Multilayer-Specific Functions and Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following functions are specific to multilayer graphs or their implementations radically differ from their monoplex counterparts. For more information on every function, please refer to De Domenico et al. (2013) or consult the associated docstrings.","category":"page"},{"location":"#Overlay-Monoplex-Graph","page":"Home","title":"Overlay Monoplex Graph","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Get the overlay monoplex graph: the monoplex graph whose nodes are the nodes of the multilayer graph and the edge between node i and node j has weight equal to the sum of all the weights of the edges between all vertex representations of i and j that belong to the same layer, for all the layers in the multilayer","category":"page"},{"location":"","page":"Home","title":"Home","text":"get_overlay_monoplex_graph(multilayergraph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"{5, 8} undirected simple Int64 graph with Float64 weights","category":"page"},{"location":"#Depth-Weighted-Clustering-Coefficient","page":"Home","title":"Depth-Weighted Clustering Coefficient","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Get the global clustering coefficient where triplets are weighted by how many layers they span","category":"page"},{"location":"","page":"Home","title":"Home","text":"w =  [1/3, 1/3, 1/3]\nmultilayer_weighted_global_clustering_coefficient(multilayergraph,w)","category":"page"},{"location":"","page":"Home","title":"Home","text":"0.12667622867320916","category":"page"},{"location":"","page":"Home","title":"Home","text":"The first component of w is the weight associated to triplets that are contained in one layer, the second component to triplets whose vertices are spread across exactly two layers, the third to triplets whose vertices are spread across exactly three layers. Weights must sum to 1.0. When they are all equal (like in this example), the weighted global clustering coefficient coincides with the global clustering coefficient.","category":"page"},{"location":"#Eigenvector-Centrality","page":"Home","title":"Eigenvector Centrality","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Calculated via an iterative algorithm, its normalization is different from the Graphs.jl implementation. See ?eigenvector_centrality for further details and context.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# The returned values are: the eigenvector centrality and the relative error at each iteration, that is, the summed absolute values of the componentwise differences between the centrality computed at the current iteration minus the centrality computed at the previous iteration.\neig_centrality, errs = eigenvector_centrality(multilayergraph; norm = \"n\", tol = 1e-3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"([0.260450377858897 0.02358226618172732 0.08408641909534659; 0.6517125919818912 0.646849109975291 0.25212976452498587; … ; 0.21160486454350666 0.24850764907380082 0.2809259415084613; 0.5089709123112656 0.27775286552140954 0.22663014660085468], [10.000000000000004, 0.7095737447337795, 0.329314405320397, 0.16256401870083886, 0.07860800793625616, 0.04125218689190476, 0.021191358681432643, 0.011056758224944913, 0.006831972142635288, 0.0035133270128280235, 0.0024675719418019056, 0.0013403531942171656, 0.0009739276503972424])","category":"page"},{"location":"#Modularity","page":"Home","title":"Modularity","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Compute the modularity of the multilayer graph. The signature mimics the Graphs.jl modularity implementation","category":"page"},{"location":"","page":"Home","title":"Home","text":"modularity(multilayergraph,\n          rand([1, 2, 3, 4], length(nodes(multilayergraph)),length(multilayergraph.layers)) # communities\n          )","category":"page"},{"location":"","page":"Home","title":"Home","text":"-0.039890139283044884","category":"page"},{"location":"#Von-Neumann-Entropy","page":"Home","title":"Von Neumann Entropy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Compute the Von Neumann entropy as presented in De Domenico et al. (2013)","category":"page"},{"location":"","page":"Home","title":"Home","text":"von_neumann_entropy(multilayergraph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"3.3980014398404834","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Von Neumann entropy is currently available only for undirected multilayer graphs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Other extended functions are: is_directed, has_vertex, ne, nv, outneighbors, indegree, outdegree, degree, mean_degree, degree_second_moment, degree_variance, nn, nodes.","category":"page"},{"location":"#How-to-Contribute","page":"Home","title":"How to Contribute","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is currently under development and further steps would benefit enormously from the precious feedback of the JuliaGraph people, graph theorists, network scientists and all the users who might have general questions or suggestions. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Therefore feel free to open discussions, issues or PRs. They are very welcome!   ","category":"page"},{"location":"#How-to-Cite","page":"Home","title":"How to Cite","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use this package in your work, please cite this repository using the metadata in CITATION.bib.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"De Domenico et al. (2013) Mathematical Formulation of Multilayer Networks. Physical Review X.","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [MultilayerGraphs]","category":"page"},{"location":"internals/#MultilayerGraphs.AbstractGraphOfGraphs","page":"Internals","title":"MultilayerGraphs.AbstractGraphOfGraphs","text":"abstract type AbstractGraphOfGraphs{T <: AbstractGraph} <: AbstractGraph{T} end\n\nAn abstract type representing a graph of graphs.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.AbstractInterlayer","page":"Internals","title":"MultilayerGraphs.AbstractInterlayer","text":"AbstractInterlayer{T,U,G}\n\nAn abstract type representing a generic Interlayer.\n\nFIELDS\n\nT: the node type;\nU: the adjacency matrix/tensor eltype;\nG: the underlying graph type.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.AbstractLayer","page":"Internals","title":"MultilayerGraphs.AbstractLayer","text":"AbstractLayer{T,U,G}\n\nAn abstract type representing a generic Layer.\n\nFIELDS\n\nT: the node type;\nU: the adjacency matrix/tensor eltype;\nG: the underlying graph type.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.AbstractMultilayerEdge","page":"Internals","title":"MultilayerGraphs.AbstractMultilayerEdge","text":"AbstractMultilayerEdge{T} <: AbstractEdge{T}\n\nAn abstract type representing a MultilayerGraph edge.\n\nIt must have fields: src, dst, weight.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.AbstractMultilayerGraph","page":"Internals","title":"MultilayerGraphs.AbstractMultilayerGraph","text":"AbstractMultilayerGraph{T <: Integer, U <: Real} <: AbstractGraph{T}\n\nAn abstract type for multilayer graphs, it must contain the fields: adjacency_tensor, layers, Interlayers. It is a subtype of AbstractGraph and its concrete subtypes may extend Graphs.jl.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.AbstractMultilayerVertex","page":"Internals","title":"MultilayerGraphs.AbstractMultilayerVertex","text":"AbstractMultilayerVertex{T} <: AbstractVertex{T}\n\nAn abstract type representing an abstract MultilayerGraph vertex.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.AbstractVertex","page":"Internals","title":"MultilayerGraphs.AbstractVertex","text":"AbstractVertex{T}\n\nAn abstract type representing a graph vertex.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.DiGraphOfGraphs","page":"Internals","title":"MultilayerGraphs.DiGraphOfGraphs","text":"mutable struct DiGraphOfGraphs{T} <: AbstractGraphOfGraphs{T}\n\nDefault directed concrete implementation of AbstractGraphOfGraphs.\n\nFIELDS\n\nnodes::OrderedDict{Int64,T}: An OrderedDict that associates graphs (values) to Int64 nodes (keys).\ngraph::SimpleWeightedGraph{Int64,Float64}: The weighted directed graph representing the graph of graphs. Its Int64 nodes are associated to graphs via the nodes field.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.DiGraphOfGraphs-Union{Tuple{T}, Tuple{Vector{T}, Matrix{Float64}}} where T<:Graphs.AbstractGraph","page":"Internals","title":"MultilayerGraphs.DiGraphOfGraphs","text":"DiGraphOfGraphs(graphs::Vector{T}, adjacency_matrix::Matrix{Float64})\n\nOuter constructor for DiGraphOfGraphs.\n\nARGUMENTS\n\ngraphs::Vector{T}: The vector of nodes of the graphs of graphs. Each of them will be assigned to an integer, from 1 to length(graphs), and their order is assumed to be the same as the rows and columns of the adjacency_matrix argument.\nadjacency_matrix::Matrix{Float64}: The adjacency matrix of the graph of graphs. Its (i,j)-element is the weight of the link between graphs[i] and graphs[j].\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.GraphOfGraphs","page":"Internals","title":"MultilayerGraphs.GraphOfGraphs","text":"mutable struct GraphOfGraphs{T} <: AbstractGraphOfGraphs{T}\n\nDefault undirected concrete implementation of AbstractGraphOfGraphs.\n\nFIELDS\n\nnodes::OrderedDict{Int64,T}: An OrderedDict that associates graphs (values) to Int64 nodes (keys).\ngraph::SimpleWeightedGraph{Int64,Float64}: The weighted undirected graph representing the graph of graphs. Its Int64 nodes are associated to graphs via the nodes field.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.GraphOfGraphs-Union{Tuple{T}, Tuple{Vector{T}, Union{LinearAlgebra.Symmetric{Float64, Matrix{Float64}}, Matrix{Float64}}}} where T<:Graphs.AbstractGraph","page":"Internals","title":"MultilayerGraphs.GraphOfGraphs","text":"GraphOfGraphs(graphs::Vector{T}, adjacency_matrix::Matrix{Float64})\n\nOuter constructor for GraphOfGraphs.\n\nARGUMENTS\n\ngraphs::Vector{T}: The vector of nodes of the graphs of graphs. Each of them will be assigned to an integer, from 1 to length(graphs), and their order is assumed to be the same as the rows and columns of the adjacency_matrix argument.\nadjacency_matrix::Matrix{Float64}: The adjacency matrix of the graph of graphs. Its (i,j)-element is the weight of the link between graphs[i] and graphs[j].\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.Interlayer","page":"Internals","title":"MultilayerGraphs.Interlayer","text":"mutable struct Interlayer{G <: AbstractGraph}\n\nRepresents an interlayer in a Multilayer(Di)Graph. \n\nFIELDS\n\nnv::Int64 : the number of nodes;\nname`::Symbol : name of the Interlayer;\nlayer_1::Symbol: name of one of the Layers connected by this Interlayer;\nlayer_2::Symbol: name of one of the Layers connected by this Interlayer;\ngraph_type`::Type{G}: type of the graph underlying the Interlayer;\nedge_list::Tuple{Vararg{ <: MultilayerEdge{MultilayerVertex{T},U} }}: edge list for the Interlayer;\nforbidden_vertices::Vector{MultilayerVertex{T}}: nodes of the MultilayerGraph that are not part of this Interlayer (they will be formally present in the Interlayer but it will be checked that they aren't adjacacent to any other node);\nforbidden_edges::Vector{NTuple{2, MultilayerVertex{T}}}: edges that are required not to exist in this Interlayer.\n\nConstructors\n\nInterlayer(name::Symbol,layer_1::Symbol,layer_2::Symbol, graph::G, forbidden_vertices::Vector{MultilayerVertex{T}}, forbidden_edges::Vector{NTuple{2, MultilayerVertex{T}}}; U::Union{Type{ <: Real}, Nothing} = nothing  ) where { T <: Union{ <: Integer, AbstractVertex}, G <: AbstractGraph{T}}\n\nOverridden inner constructor. Return an Interlayer between layer_1 and layer_2, whose underlying graph is graph. All Layers and Interlayers of a Multilayer(Di)Graph need to formally have the same vertices, but in real applications it may be that some vertices are excluded from som layers. Such vertices should be specified in forbiddes_vertices. Similarly for forbiddes_edges. This constructor (to which all the other eventually fall back to) will check that forbidden_vertices have no neighbors in graph, and that forbidden_edges actually correspond to zero entries in the adjacency matrix of graph. Also check that it is a proper bipartite graph.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{T}, Tuple{Int64, Symbol, Symbol, Symbol, Type{G}, Int64}} where {T<:(Union{AbstractVertex, var\"#s14\"} where var\"#s14\"<:Integer), G<:Graphs.AbstractGraph{T}}","page":"Internals","title":"MultilayerGraphs.Interlayer","text":"Interlayer(nv::Int64, name::Symbol,layer_1::Symbol, layer_2::Symbol, graph_type::Type{G}, ne::Int64, forbidden_vertices::Vector{MultilayerVertex{T}}, forbidden_edges::Vector{NTuple{2, MultilayerVertex{T}}}) where {T <: Union{ <: Integer, AbstractVertex}, G <: AbstractGraph{T}; !IsDirected{G}, IsWeighted{G}}\n\nRandom Interlayer.\n\nARGUMENTS\n\nnv::Int64: number of vertices;\nname::Symbol: name of the Interlayer;\nlayer_1::Symbol: The first Layer it connects;\nlayer_2::Symbol: The second Layer it connects;\ngraph_type::Type{G}: the underlying graph type;\nne::Int64: the number of edges;\nforbidden_vertices::Vector{MultilayerVertex{T}}: list of vertices that are not considered present in the Interlayer;\nforbidden_edges::Vector{NTuple{2, MultilayerVertex{T}}}: list of edges whose existence is a priori excluded from the Interlayer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Int64, Symbol, Symbol, Symbol, Type{G}, Tuple{Vararg{MultilayerEdge{MultilayerVertex{T}, U}}}}} where {T<:(Union{AbstractVertex, var\"#s11\"} where var\"#s11\"<:Integer), U<:Real, G<:Graphs.AbstractGraph{T}}","page":"Internals","title":"MultilayerGraphs.Interlayer","text":"Interlayer(nv::Int64, name::Symbol,layer_1::Symbol, layer_2::Symbol, graph_type::Type{G}, edge_list::Tuple{Vararg{ <: MultilayerEdge{MultilayerVertex{T},U} }}, forbidden_vertices::Vector{MultilayerVertex{T}}, forbidden_edges::Vector{NTuple{2, MultilayerVertex{T}}}) where {T <: Union{ <: Integer, AbstractVertex}, U <: Real, G <: AbstractGraph{T}; IsWeighted{G}}\n\nOuter constructor for Interlayer.  Return an Interlayer between layer_1 and layer_2, whose underlying graph type is graph_type. Edges are given via an edge list edge_list. All Layers and Interlayers of a Multilayer(Di)Graph need to formally have the same vertices, but in real applications it may be that some vertices are excluded from som layers. Such vertices should be specified in forbiddes_vertices. Similarly for forbiddes_edges.\n\nARGUMENTS\n\nnv::Int64 : the number of nodes;\nname`::Symbol : name of the Interlayer;\nlayer_1::Symbol: name of one of the Layers connected by this Interlayer;\nlayer_2::Symbol: name of one of the Layers connected by this Interlayer;\ngraph_type`::Type{G}: type of the graph underlying the Interlayer;\nedge_list::Tuple{Vararg{ <: MultilayerEdge{MultilayerVertex{T},U} }}: edge list for the Interlayer;\nforbidden_vertices::Vector{MultilayerVertex{T}}: nodes of the MultilayerGraph that are not part of this Interlayer (they will be formally present in the Interlayer but it will be checked that they aren't adjacent to any other node);\nforbidden_edges::Vector{NTuple{2, MultilayerVertex{T}}}: edges that are required not to exist in this Interlayer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.IsWeighted","page":"Internals","title":"MultilayerGraphs.IsWeighted","text":"IsWeighted{X}\n\nTrait that discerns between weighted and unweighted graphs.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.Layer","page":"Internals","title":"MultilayerGraphs.Layer","text":"mutable struct Layer{T <: Integer, U <: Real, G <: AbstractGraph{T}} <: AbstractLayer{T,U,G}\n\nRepresents a layer in a Multilayer(Di)Graph. \n\nFIELDS\n\nname::Symbol: the name of the layer;\ngraph::G: underlying graph of the layer;\nforbidden_vertices::Vector{MultilayerVertex{T}}: nodes of the MultilayerGraph that are not part of this Layer (they will be formally present in the Layer but it will be checked that they aren't adjacent to any other node);\nforbidden_edges::Vector{NTuple{2, MultilayerVertex{T}}}: edges that are required not to exist in this Layer.\n\nCONSTRUCTORS\n\nLayer(name::Symbol, graph::G, forbidden_vertices::Tuple{Vararg{T}}, forbidden_edges::Tuple{Vararg{NTuple{2, T}}};  U::Union{Type{ <: Real}, Nothing}  = nothing ) where {T,G <: AbstractGraph{T}}\n\nOverridden inner constructor. Return an Layer whose underlying graph is graph. All Layers and Layers of a Multilayer(Di)Graph need to formally have the same nodes, but in real applications it may be that some vertices are excluded from some layers. Such vertices should be specified in forbiddes_vertices. Similarly for forbiddes_edges. This constructor (to which all the other eventually fall back to) will check that forbidden_vertices have no neighbors in graph, and that forbidden_edges actually correspond to zero entries in the adjacency matrix of graph. \n\nLayer{T <: Integer, U <: Real, G <: AbstractGraph{T}} <: AbstractLayer{T,U,G}\n\nIncomplete initialization, used to write type-stable functions\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{Symbol, G}} where G<:Graphs.AbstractGraph","page":"Internals","title":"MultilayerGraphs.Layer","text":"Layer(name::Symbol, graph::G; U::Union{Type{ <: Real}, Nothing} = nothing) where {G <: AbstractGraph}\n\nReturn a Layer with name name and graph graph with no forbidden nodes or edges.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{T}, Tuple{Int64, Symbol, Type{G}, Int64}} where {T<:(Union{AbstractVertex, var\"#s16\"} where var\"#s16\"<:Integer), G<:Graphs.AbstractGraph{T}}","page":"Internals","title":"MultilayerGraphs.Layer","text":"Layer(nv::Int64, name::Symbol, graph_type::Type{G}, ne::Int64; U::Union{Type{ <: Real},Nothing} = nothing)  where {T <: Union{ <: Integer, AbstractVertex}, G <: AbstractGraph{T}}\n\nRandom Layer.\n\nARGUMENTS\n\nnv::Int64: number of vertices;\nname::Symbol: name of the layer;\ngraph_type::Type{G}: the underlying graph type;\nne::Int64: the number of edges;\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.MultilayerDiGraph","page":"Internals","title":"MultilayerGraphs.MultilayerDiGraph","text":"MultilayerDiGraph{T, U} <: AbstractMultilayerDiGraph{T,U}\n\nA concrete type that can represent a general directed multilayer graph.\n\nFIELDS\n\nadjacency_tensor::Array{U, 4}: the 4-dimensional tensor that encodes all (weighted) connections within the graph. adjacency_tensor[1,2,3,4] encodes the strength of the (directed or undirected) link between node 1 in layer 3 and node 2 in layer 4.\nlayers::OrderedDict{ Tuple{Int64,Int64}, Layer{T,U,G}}: the ordered dictionary containing all the layers of the multilayer graph. Their underlying graphs must be all directed.\ninterlayers::OrderedDict{ Tuple{Int64,Int64}, Interlayer{T,U}}: the ordered dictionary containing all the interlayers of the multilayer graph. Their underlying graphs must be all directed.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.MultilayerDiGraph-Tuple{Int64, Int64, Int64, Int64, Vector{DataType}}","page":"Internals","title":"MultilayerGraphs.MultilayerDiGraph","text":"MultilayerDiGraph(num_layers::Int64, n_nodes::Int64, min_edges::Int64, max_edges::Int64, graph_type::Type{<: AbstractGraph})\n\nReturn a random MultilayerDiGraph with num_layers layers, n_nodes nodes and each Layer and Interlayer has a random number of edges between min_edges and max_edges. Layers and Interlayers have parametric type graph_type.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.MultilayerDiGraph-Tuple{Int64, Type{<:Number}, Type{<:Number}}","page":"Internals","title":"MultilayerGraphs.MultilayerDiGraph","text":"MultilayerDiGraph(n_nodes::Int64, T::Type{ <: Number}, U::Type{ <: Number} )\n\nReturn a MultilayerDiGraph with n_nodes of type T nodes and an adjacency tensor eltype U. Use this constructor and then add Layers and Interlayers via the add_layer! and add_interlayer! methods.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.MultilayerDiGraph-Union{Tuple{U}, Tuple{T}, Tuple{Vector{<:Layer{T, U, G} where G<:Graphs.AbstractGraph{T}}, Vector{<:Interlayer{T, U, G} where G<:Graphs.AbstractGraph{T}}}} where {T, U}","page":"Internals","title":"MultilayerGraphs.MultilayerDiGraph","text":"MultilayerDiGraph(layers::Vector{ <: Layer{T,U }}, specified_interlayers::Vector{ <: Interlayer{T,U}};  default_interlayer::String  = \"multiplex\") where {T, U}\n\nConstruct a MultilayerDiGraph with layers given by layers. The interlayers will be constructed by default according to default_interlayer (only \"multiplex\" is allowed), except for those specified in specified_interlayers.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.MultilayerDiGraph-Union{Tuple{Vector{<:Layer{T, U, G} where G<:Graphs.AbstractGraph{T}}}, Tuple{U}, Tuple{T}} where {T, U}","page":"Internals","title":"MultilayerGraphs.MultilayerDiGraph","text":"MultilayerDiGraph(layers::Vector{ <: Layer{T,U}};  default_interlayer::String  = \"multiplex\") where {T,U}\n\nConstruct a MultilayerDiGraph with layers layers and all interlayers of type default_interlayer (only \"multiplex\" is allowed).\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.MultilayerEdge","page":"Internals","title":"MultilayerGraphs.MultilayerEdge","text":"struct MultilayerEdge{ T <: MultilayerVertex, U <: Union{ <: Real, Nothing}} <: AbstractMultilayerEdge{T}\n\nDefault concrete subtype of AbstractMultilayerEdge.\n\nFIELDS\n\nsrc::T: the source vertex of the edge ;\ndst::T: the destination vertex of the edge;\nweight::U: the edge weight.\n\nCONSTRUCTORS\n\nMultilayerEdge(src::T, dst::T, weight::U) where { T <: MultilayerVertex, U <: Union{ <: Real, Nothing}}\n\nDefault constructor.\n\nMultilayerEdge(src::T, dst::T) where {T <: MultilayerVertex}\n\nUnweighted edge.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.MultilayerGraph","page":"Internals","title":"MultilayerGraphs.MultilayerGraph","text":"MultilayerGraph{T, U, G <: AbstractGraph{T}} <: AbstractMultilayerGraph{T,U}\n\nA concrete type that can represent a general multilayer graph.\n\nFIELDS\n\nadjacency_tensor::Array{U, 4}: the 4-dimensional tensor that encodes all (weighted) connections within the graph. adjacency_tensor[1,2,3,4] encodes the strength of the (directed or undirected) link between node 1 in layer 3 and node 2 in layer 4.\nlayers::OrderedDict{ Tuple{Int64,Int64}, Layer{T,U,G}}: the ordered dictionary containing all the layers of the multilayer graph. Their underlying graphs must be all undirected.\ninterlayers::OrderedDict{ Tuple{Int64,Int64}, Interlayer{T,U}}: the ordered dictionary containing all the interlayers of the multilayer graph. Their underlying graphs must be all undirected.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.MultilayerGraph-Tuple{Int64, Int64, Int64, Int64, Vector{DataType}}","page":"Internals","title":"MultilayerGraphs.MultilayerGraph","text":"MultilayerGraph(num_layers::Int64, n_nodes::Int64, min_edges::Int64, max_edges::Int64, graph_type::Type{<: AbstractGraph})\n\nReturn a random MultilayerGraph with num_layers layers, n_nodes nodes and each Layer and Interlayer has a random number of edges between min_edges and max_edges. Layers and Interlayers have parametric type graph_type.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.MultilayerGraph-Tuple{Int64, Type{<:Number}, Type{<:Number}}","page":"Internals","title":"MultilayerGraphs.MultilayerGraph","text":"MultilayerGraph(n_nodes::Int64, T::Type{ <: Number}, U::Type{ <: Number} )\n\nReturn a MultilayerGraph with n_nodes of type T nodes and an adjacency tensor eltype U. Use this constructor and then add Layers and Interlayers via the add_layer! and add_interlayer! methods.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.MultilayerGraph-Union{Tuple{U}, Tuple{T}, Tuple{Vector{<:Layer{T, U, G} where G<:Graphs.AbstractGraph{T}}, Vector{<:Interlayer{T, U, G} where G<:Graphs.AbstractGraph{T}}}} where {T, U}","page":"Internals","title":"MultilayerGraphs.MultilayerGraph","text":"MultilayerGraph(layers::Vector{ <: Layer{T,U }}, specified_interlayers::Vector{ <: Interlayer{T,U}};  default_interlayer::String  = \"multiplex\") where {T, U}\n\nConstruct a MultilayerDiGraph with layers given by layers. The interlayers will be constructed by default according to default_interlayer (only \"multiplex\" is allowed), except for those specified in specified_interlayers.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.MultilayerGraph-Union{Tuple{Vector{<:Layer{T, U, G} where G<:Graphs.AbstractGraph{T}}}, Tuple{U}, Tuple{T}} where {T, U}","page":"Internals","title":"MultilayerGraphs.MultilayerGraph","text":"MultilayerGraph(layers::Vector{ <: Layer{T,U}};  default_interlayer::String  = \"multiplex\") where {T,U}\n\nConstruct a MultilayerDiGraph with layers layers and all interlayers of type default_interlayer (only \"multiplex\" is allowed).\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.MultilayerVertex","page":"Internals","title":"MultilayerGraphs.MultilayerVertex","text":"MultilayerVertex{T <: Integer} <: AbstractMultilayerVertex{T}\n\nA struct representing a vertex of a MultilayerGraph.\n\nFIELDS\n\nvertex::T : the node that the MultilayerVertex represents;\nlayer::Symbol:  the layer the MultilayerVertex belongs to.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.δ","page":"Internals","title":"MultilayerGraphs.δ","text":"mutable struct δ{T} <: AbstractVector{T}\n\nThe kronecker delta.\n\nFIELDS\n\nN::Int64: the number of dimensions;\nrepresentation::Matrix{Int64}: the matrix representing the kronecker delta;\nT: the return type when called ad δ[i,j].\n\nCONSTRUCTORS\n\nδ{T}(N::Int64) where {T <: Number}\n\nInner constructor that only requires N and the eltype.\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.δ-Tuple{Int64}","page":"Internals","title":"MultilayerGraphs.δ","text":"δ(N::Int64)\n\nOuter constructor that only requires N\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.δ_1","page":"Internals","title":"MultilayerGraphs.δ_1","text":"struct δ_1{T<: Number}\n\nThe δ_1 from De Domenico et al. (2013). Evaluate it via the notation [i,j].\n\nFIELDS\n\nN:Int64: the dimensionality of δ_1;\nT: the return type.\n\nCONSTRUCTORS\n\nδ_1{T<: Number}(N::Int64)\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.δ_2","page":"Internals","title":"MultilayerGraphs.δ_2","text":"struct δ_2{T<: Number}\n\nThe δ_2 from De Domenico et al. (2013). Evaluate it via the notation [i,j].\n\nFIELDS\n\nN:Int64: the dimensionality of δ_2;\nT: the return type.\n\nCONSTRUCTORS\n\nδ_2{T<: Number}(N::Int64)\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.δ_3","page":"Internals","title":"MultilayerGraphs.δ_3","text":"struct δ_3{T<: Number}\n\nThe δ_3 from De Domenico et al. (2013). Evaluate it via the notation [i,j].\n\nFIELDS\n\nN:Int64: the dimensionality of δ_3;\nT: the return type.\n\nCONSTRUCTORS\n\nδ_3{T<: Number}(N::Int64)\n\n\n\n\n\n","category":"type"},{"location":"internals/#MultilayerGraphs.δ_Ω","page":"Internals","title":"MultilayerGraphs.δ_Ω","text":"δ_Ω{T} <: AbstractVector{T}\n\nStruct that represents the δ_Ω defined in De Domenico et al. (2013).\n\nFIELDS\n\nδ_1::δ_1{T}: Instance of δ_1;\nδ_2::δ_2{T}: Instance of δ_2;\nδ_3::δ_3{T}: Instance of δ_3;\nN::Int64  : Maximum index (number of layers);\nrepresentation::Array{Int64,4}: Multidimensional-array representation of δ_Ω.\n\n\n\n\n\n","category":"type"},{"location":"internals/#SimpleWeightedGraphs.SimpleWeightedDiGraph-Tuple{Integer, Integer}","page":"Internals","title":"SimpleWeightedGraphs.SimpleWeightedDiGraph","text":"SimpleWeightedDiGraph(n_vertices::Integer, n_edges::Integer; T::Type = Int64, U::Type = Float64)\n\nRandom  SimpleWeightedDiGraph with n_vertices vertices and n_edges edges, vertex type T and adjacency matrix eltype U. Edge weights are uniformly extracted between 0 and 1. \n\n\n\n\n\n","category":"method"},{"location":"internals/#SimpleWeightedGraphs.SimpleWeightedDiGraph-Union{Tuple{T}, Tuple{Integer, Integer}} where T","page":"Internals","title":"SimpleWeightedGraphs.SimpleWeightedDiGraph","text":"SimpleWeightedGraphs.SimpleWeightedDiGraph{T}(n_vertices::Integer, n_edges::Integer; U::Type = Float64) where {T}\n\nRandom  SimpleWeightedDiGraph with n_vertices vertices and n_edges edges, vertex type T and adjacency matrix eltype U. Edge weights are uniformly extracted between 0 and 1. \n\n\n\n\n\n","category":"method"},{"location":"internals/#SimpleWeightedGraphs.SimpleWeightedDiGraph-Union{Tuple{U}, Tuple{T}, Tuple{Integer, Integer}} where {T, U}","page":"Internals","title":"SimpleWeightedGraphs.SimpleWeightedDiGraph","text":"SimpleWeightedDiGraph{T,U}(n_vertices::Integer, n_edges::Integer)\n\nRandom  SimpleWeightedDiGraph with n_vertices vertices and n_edges edges, vertex type T and adjacency matrix eltype U. Edge weights are uniformly extracted between 0 and 1. \n\n\n\n\n\n","category":"method"},{"location":"internals/#SimpleWeightedGraphs.SimpleWeightedGraph-Tuple{Integer, Integer}","page":"Internals","title":"SimpleWeightedGraphs.SimpleWeightedGraph","text":"SimpleWeightedGraph(n_vertices::Integer, n_edges::Integer; T::Type = Int64, U::Type = Float64)\n\nRandom  SimpleWeightedGraph with n_vertices vertices and n_edges edges, vertex type T and adjacency matrix eltype U. Edge weights are uniformly extracted between 0 and 1. \n\n\n\n\n\n","category":"method"},{"location":"internals/#SimpleWeightedGraphs.SimpleWeightedGraph-Union{Tuple{T}, Tuple{Integer, Integer}} where T","page":"Internals","title":"SimpleWeightedGraphs.SimpleWeightedGraph","text":"SimpleWeightedGraph{T}(n_vertices::Integer, n_edges::Integer; U::Type = Float64) where { T }\n\nRandom  SimpleWeightedGraph with n_vertices vertices and n_edges edges, vertex type T and adjacency matrix eltype U. Edge weights are uniformly extracted between 0 and 1. \n\n\n\n\n\n","category":"method"},{"location":"internals/#SimpleWeightedGraphs.SimpleWeightedGraph-Union{Tuple{U}, Tuple{T}, Tuple{Integer, Integer}} where {T, U}","page":"Internals","title":"SimpleWeightedGraphs.SimpleWeightedGraph","text":"SimpleWeightedGraph{T,U}(n_vertices::Integer, n_edges::Integer) where { T, U }\n\nRandom  SimpleWeightedGraph with n_vertices vertices and n_edges edges, vertex type T and adjacency matrix eltype U. Edge weights are uniformly extracted between 0 and 1. \n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.:==-Tuple{AbstractMultilayerGraph, AbstractMultilayerGraph}","page":"Internals","title":"Base.:==","text":"Base.(==)(x::AbstractMultilayerGraph, y::AbstractMultilayerGraph)\n\nOverload equality for AbstractMultilayerGraphs.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.:==-Tuple{Interlayer, Interlayer}","page":"Internals","title":"Base.:==","text":"Base.(==)(x::Interlayer, y::Interlayer)\n\nOverload equality for Interlayers.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.:==-Tuple{Layer, Layer}","page":"Internals","title":"Base.:==","text":"Base.(==)(x::Layer, y::Layer)\n\nOverload equality for Layers.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.eltype-Tuple{In} where In<:Interlayer","page":"Internals","title":"Base.eltype","text":"Base.eltype(interlayer::In) where { In <: Interlayer}\n\nReturn the vertex type of interlayer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.eltype-Tuple{L} where L<:Layer","page":"Internals","title":"Base.eltype","text":"Base.eltype(layer::L) where { L <: Layer}\n\nReturn the vertex type of layer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.eltype-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M<:AbstractMultilayerGraph{T, U}}","page":"Internals","title":"Base.eltype","text":"Base.eltype(mg::M) where {M <: AbstractMultilayerGraph}\n\nReturn the vertex type of mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.getindex-Union{Tuple{O}, Tuple{O, Int64}} where O<:OrderedCollections.OrderedDict","page":"Internals","title":"Base.getindex","text":"getindex(od::O, key::Int64) where {O <: OrderedDict}\n\nReturn the keyth pair of od, following od's order.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.getindex-Union{Tuple{T}, Tuple{MultilayerGraphs.δ{T}, Int64}} where T","page":"Internals","title":"Base.getindex","text":"getindex(d::δ{T}, i::Int) where T\n\nThe getindex called by OMEinsum\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.getproperty-Union{Tuple{In}, Tuple{In, Symbol}} where In<:Interlayer","page":"Internals","title":"Base.getproperty","text":"Base.getproperty(interlayer::In, f::Symbol) where { In <: Interlayer}\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.getproperty-Union{Tuple{L}, Tuple{L, Symbol}} where L<:Layer","page":"Internals","title":"Base.getproperty","text":"Base.getproperty(layer::L, f::Symbol) where { L <: layer}\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.getproperty-Union{Tuple{M}, Tuple{M, Symbol}} where M<:AbstractMultilayerGraph","page":"Internals","title":"Base.getproperty","text":"Base.getproperty(mg::M, f::Symbol) where { M <: AbstractMultilayerGraph }\n\n\n\n\n\n","category":"method"},{"location":"internals/#Base.size-Tuple{MultilayerGraphs.δ}","page":"Internals","title":"Base.size","text":"size(d::δ)\n\nOverride required by OMEinsum\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.LinAlg.adjacency_matrix-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G<:Graphs.AbstractGraph{T}, In<:Interlayer{T, U, G}}","page":"Internals","title":"Graphs.LinAlg.adjacency_matrix","text":"adjacency_matrix(interlayer::In) where { T,U, G <: AbstractGraph{T}, In <:Interlayer{T,U,G}}\n\nReturn the adjacency matrix of interlayer.graph, with the eltype converted to U.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.LinAlg.adjacency_matrix-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G<:Graphs.AbstractGraph{T}, L<:Layer{T, U, G}}","page":"Internals","title":"Graphs.LinAlg.adjacency_matrix","text":"adjacency_matrix(layer::L) where { T,U, G <: AbstractGraph{T}, L <:Layer{T,U,G}}\n\nReturn the adjacency matrix of layer.graph, with the eltype converted to U.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, E}} where {T, U, G, In<:Interlayer{T, U, G}, E<:MultilayerEdge{MultilayerVertex{T}, Nothing}}","page":"Internals","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(interlayer::In, me::E) where {T,U,G, In <: Interlayer{T,U,G}, E <: MultilayerEdge{MultilayerVertex{T},Nothing}}\n\nAdd unweighted edge me to interlayer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, E}} where {T, U<:Real, G, In<:Interlayer{T, U, G}, E<:MultilayerEdge{MultilayerVertex{T}, U}}","page":"Internals","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(interlayer::In, me::E) where {T,U <: Real,G, In <: Interlayer{T,U,G}, E <: MultilayerEdge{MultilayerVertex{T},U}}\n\nAdd unweighted edge me to interlayer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, E}} where {T, U, G<:Graphs.AbstractGraph{T}, L<:Layer{T, U, G}, E<:MultilayerEdge{MultilayerVertex{T}, Nothing}}","page":"Internals","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(layer::L, me::E) where {T,U,G<: AbstractGraph{T}, L <: Layer{T,U,G}, E <: MultilayerEdge{MultilayerVertex{T},Nothing}; !IsWeighted{G}}\n\nAdd unweighted edge me to layer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, E}} where {T, U<:Real, G<:Graphs.AbstractGraph{T}, L<:Layer{T, U, G}, E<:MultilayerEdge{MultilayerVertex{T}, U}}","page":"Internals","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(layer::L, me::E) where {T,U <: Real,G <: AbstractGraph{T} , L <: Layer{T,U,G}, E <: MultilayerEdge{MultilayerVertex{T},U}; IsWeighted{G}}\n\nAdd unweighted edge me to layer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U, M<:MultilayerDiGraph{T, U}, E<:MultilayerEdge{MultilayerVertex{T}, Nothing}}","page":"Internals","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(mg::M, me::E) where { T, U, M <: MultilayerDiGraph{T,U}, E <: MultilayerEdge{MultilayerVertex{T},Nothing}}\n\nAdd unweighted edge me to mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U, M<:MultilayerGraph{T, U}, E<:MultilayerEdge{MultilayerVertex{T}, Nothing}}","page":"Internals","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(mg::M, me::E) where { T, U, M <: MultilayerGraph{T,U}, E <: MultilayerEdge{MultilayerVertex{T},Nothing}}\n\nAdd unweighted edge me to mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U<:Real, M<:MultilayerDiGraph{T, U}, E<:MultilayerEdge{MultilayerVertex{T}, U}}","page":"Internals","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(mg::M, me::E) where { T, U <: Real, M <: MultilayerDiGraph{T,U}, E <: MultilayerEdge{MultilayerVertex{T},U}}\n\nAdd weighted edge me to mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U<:Real, M<:MultilayerGraph{T, U}, E<:MultilayerEdge{MultilayerVertex{T}, U}}","page":"Internals","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(mg::M, me::E) where { T, U <: Real, M <: MultilayerGraph{T,U}, E <: MultilayerEdge{MultilayerVertex{T},U}}\n\nAdd weighted edge me to mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{IsWeighted{G}}, In, V, V, U}} where {T, U<:Real, G<:Graphs.AbstractGraph{T}, In<:Interlayer{T, U, G}, V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(interlayer::In,src::V, dst::V, weight::U) where { T, U <: Real, G <: AbstractGraph{T}, In <: Interlayer{T,U,G}, V <: MultilayerVertex{T}; IsWeighted{G}}\n\nAdd edge from src to dst with weight weight to interlayer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{SimpleTraits.Not{IsWeighted{G}}}, In, V, V}} where {T, U<:Real, G<:Graphs.AbstractGraph{T}, In<:Interlayer{T, U, G}, V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(interlayer::In,src::V, dst::V) where { T, U <: Real, G <: AbstractGraph{T}, In <: Interlayer{T,U,G}, V <: MultilayerVertex{T}; !IsWeighted{G}}\n\nAdd edge from src to dst with weight weight to interlayer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{IsWeighted{G}}, L, V, V, U}} where {T, U<:Real, G<:Graphs.AbstractGraph{T}, L<:Layer{T, U, G}, V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(layer::L,src::V, dst::V, weight::U) where { T, U <: Real, G <: AbstractGraph{T}, L <: Layer{T,U,G}, V <: MultilayerVertex{T}; IsWeighted{G}}\n\nAdd edge from src to dst with weight weight to layer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{SimpleTraits.Not{IsWeighted{G}}}, L, V, V}} where {T, U<:Real, G<:Graphs.AbstractGraph{T}, L<:Layer{T, U, G}, V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(layer::L, src::V, dst::V) where { T, U <: Real, G <: AbstractGraph{T}, L <: Layer{T,U,G}, V <: MultilayerVertex{T}; !IsWeighted{G}}\n\nAdd edge from src to dst with weight weight to layer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V, U}} where {T, U<:Real, M<:MultilayerDiGraph{T, U}, V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(mg::M, src::V, dst::V, weight::U) where { T, U <: Real, M <: MultilayerDiGraph{T,U}, V <: MultilayerVertex{T}}\n\nAdd edge from src to dst with weight weight to mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V, U}} where {T, U<:Real, M<:MultilayerGraph{T, U}, V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(mg::M, src::V, dst::V, weight::U) where { T, U <: Real, M <: MultilayerGraph{T,U}, V <: MultilayerVertex{T}}\n\nAdd edge from src to dst with weight weight to mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U<:Real, M<:MultilayerDiGraph{T, U}, V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(mg::M, src::V, dst::V, weight::U) where { T, U <: Real, M <: MultilayerDiGraph{T,U}, V <: MultilayerVertex{T}}\n\nAdd edge from src to dst with weight one(T) to mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U<:Real, M<:MultilayerGraph{T, U}, V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(mg::M, src::V, dst::V, weight::U) where { T, U <: Real, M <: MultilayerGraph{T,U}, V <: MultilayerVertex{T}}\n\nAdd edge from src to dst with weight one(U) to mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.rem_edge!-Union{Tuple{V}, Tuple{In}, Tuple{U}, Tuple{T}, Tuple{In, V, V}} where {T, U, In<:(Interlayer{T, U, G} where G<:Graphs.AbstractGraph{T}), V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.SimpleGraphs.rem_edge!","text":"rem_edge!(interlayer::In, src::V, dst::V) where { T, U, In <: Interlayer{T,U}, V <: MultilayerVertex{T}}\n\nRemove edge from src to dst in interlayer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.rem_edge!-Union{Tuple{V}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, V, V}} where {T, U, G<:Graphs.AbstractGraph{T}, L<:Layer{T, U, G}, V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.SimpleGraphs.rem_edge!","text":"rem_edge!(layer::L, src::V, dst::V) where { T, U, G<: AbstractGraph{T}, L <:Layer{T,U,G}, V <: MultilayerVertex{T}}\n\nRemove edge from src to dst in layer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.rem_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U, M<:MultilayerDiGraph{T, U}, V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.SimpleGraphs.rem_edge!","text":"rem_edge!(mg::M, src::V, dst::V) where { T, U, M <: MultilayerDiGraph{T,U}, V <: MultilayerVertex{T}}\n\nRemove edge from src to dst in mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.SimpleGraphs.rem_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U, M<:MultilayerGraph{T, U}, V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.SimpleGraphs.rem_edge!","text":"rem_edge!(mg::M, V1::V, V2::V) where { T, U, M <: MultilayerGraph{T,U}, V <: MultilayerVertex{T}}\n\nRemove edge from src to dst in mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.degree-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, AbstractVector{V}}} where {T, M<:(AbstractMultilayerGraph{T}), V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.degree","text":"degree(mg::M, v::V) where {T, M <: AbstractMultilayerGraph{T, <: Real}, V <: MultilayerVertex{T}}\n\nGet the degree of vertices vs in mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.dst-Tuple{AbstractMultilayerEdge}","page":"Internals","title":"Graphs.dst","text":"dst(e::AbstractMultilayerEdge)\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.edges-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G<:Graphs.AbstractGraph{T}, In<:Interlayer{T, U, G}}","page":"Internals","title":"Graphs.edges","text":"Graphs.edges(interlayer::In) where {T,U,G <: AbstractGraph{T}, In <: Interlayer{T,U,G}}\n\nReturn an iterator over all the edges of interlayer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.edges-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G<:Graphs.AbstractGraph{T}, L<:Layer{T, U, G}}","page":"Internals","title":"Graphs.edges","text":"Graphs.edges(layer::L) where {T,U,G <: AbstractGraph{T}, L <: Layer{T,U,G}}\n\nReturn an iterator over all the edges of layer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.edges-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M<:AbstractMultilayerGraph{T, U}}","page":"Internals","title":"Graphs.edges","text":"edges(mg::M) where {M <: AbstractMultilayerDiGraph}\n\nReturn an iterator over all the edges of mg. The iterators first loops over all layers' edges (in the order they are given in mg.layers), then over all interlayers' edges (in the order they are given in mg.interlayers).\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.edgetype-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, In<:Interlayer{T, U, G}}","page":"Internals","title":"Graphs.edgetype","text":"edgetype(interlayer::In) where {T,U,G,In <: Interlayer{T,U,G} }\n\nReturn the edge type for interlayer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.edgetype-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, L<:Layer{T, U, G}}","page":"Internals","title":"Graphs.edgetype","text":"edgetype(layer::L) where {T,U,G,L <: Layer{T,U,G} }\n\nReturn the edge type for layer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.edgetype-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M<:AbstractMultilayerGraph{T, U}}","page":"Internals","title":"Graphs.edgetype","text":"edgetype(mg::M) where {M <: AbstractMultilayerGraph}\n\nReturn the edge type for mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.eigenvector_centrality-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M<:AbstractMultilayerGraph{T, U}}","page":"Internals","title":"Graphs.eigenvector_centrality","text":"eigenvector_centrality(mg::M; norm::String = \"1\", tol::Float64 = 1e-6, maxiter::Int64 = 2000) where {T, U, M <: AbstractMultilayerGraph{T, U}}\n\nCalculate the eigenvector centrality of mg via an iterative algorithm. The norm parameter may be \"1\" or \"n\",  and respectively the eigenvector centrality will be normalized to 1 or further divided by the number of nodes of mg. The tol parameter terminates the approximation when two consecutive iteration differ by no more than  tol. The maxiters parameter terminates the algorithm when it goes beyond maxiters iterations.\n\nThe returned values are: the eigenvector centrality and the relative error at each algorithm iteration, that is, the summed absolute values of the componentwise differences between the centrality computed at the current iteration minus the centrality computed at the previous iteration.\n\nNote: in the limit case of a monoplex graph, this function outputs a eigenvector centrality vector that is a multiple of the one outputted by Graphs.jl's eigenvector_centrality. It is currently under investigation.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.has_edge-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}, MultilayerVertex{T}}} where {T, U, G, In<:Interlayer{T, U, G}}","page":"Internals","title":"Graphs.has_edge","text":"has_edge(interlayer::In, s::MultilayerVertex{T}, d::MultilayerVertex{T}) where { T,U,G, In <: Interlayer{T,U,G}}\n\nReturn true if there is an edge between s and d, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.has_edge-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{Graphs.IsDirected{G}}, In, MultilayerVertex{T}, MultilayerVertex{T}, U}} where {T, U, G, In<:Interlayer{T, U, G}}","page":"Internals","title":"Graphs.has_edge","text":"has_edge(interlayer::In,  s::MultilayerVertex{T}, d::MultilayerVertex{T}, weight::U) where { T,U,G, In <: Interlayer{T,U,G}; IsDirected{G}\n\nReturn true if there is an edge between s and d with weight weight, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.has_edge-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{SimpleTraits.Not{Graphs.IsDirected{G}}}, In, MultilayerVertex{T}, MultilayerVertex{T}, U}} where {T, U, G, In<:Interlayer{T, U, G}}","page":"Internals","title":"Graphs.has_edge","text":"has_edge(interlayer::In,  s::MultilayerVertex{T}, d::MultilayerVertex{T}, weight::U) where { T,U,G, In <: Interlayer{T,U,G}; !IsDirected{G}}\n\nReturn `true` if there is an edge between `s` and `d` with weight `weight`, `false` otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.has_edge-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, MultilayerVertex{T}, MultilayerVertex{T}}} where {T, U, G, L<:Layer{T, U, G}}","page":"Internals","title":"Graphs.has_edge","text":"has_edge(layer::L, s::MultilayerVertex{T}, d::MultilayerVertex{T}) where { T,U,G, L <: Layer{T,U,G}}\n\nReturn true if there is an edge between s and d, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.has_edge-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{Graphs.IsDirected{G}}, L, MultilayerVertex{T}, MultilayerVertex{T}, U}} where {T, U, G, L<:Layer{T, U, G}}","page":"Internals","title":"Graphs.has_edge","text":"has_edge(layer::L,  s::MultilayerVertex{T}, d::MultilayerVertex{T}, weight::U) where { T,U,G, L <: Layer{T,U,G}; IsDirected{G}}\n\nReturn true if there is an edge between s and d with weight weight, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.has_edge-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Type{SimpleTraits.Not{Graphs.IsDirected{G}}}, L, MultilayerVertex{T}, MultilayerVertex{T}, U}} where {T, U, G, L<:Layer{T, U, G}}","page":"Internals","title":"Graphs.has_edge","text":"has_edge(layer::L,  s::MultilayerVertex{T}, d::MultilayerVertex{T}, weight::U) where { T,U,G, L <: Layer{T,U,G}; IsDirected{G}}\n\nReturn true if there is an edge between s and d with weight weight, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.has_edge-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U, M<:AbstractMultilayerGraph{T, U}, V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.has_edge","text":"has_edge(mg::M,s::T,d::T) where {M <: AbstractMultilayerGraph{T} } where { T <: Integer}\n\nReturn true if there is an edge between s and d, false otherwise. In case s and d belong to two different layers, but the link is found only in one of the two corresponding interlayers between them, throws an error.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.has_vertex-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In<:Interlayer{T, U, G}}","page":"Internals","title":"Graphs.has_vertex","text":"has_vertex(interlayer::In, v::MultilayerVertex{T}) where { T,U,G, In <: Interlayer{T,U,G}}\n\nReturn true if v is a vertex of interlayer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.has_vertex-Union{Tuple{L}, Tuple{L, Integer}} where L<:Layer","page":"Internals","title":"Graphs.has_vertex","text":"has_vertex(layer::L, v::Integer) where { L <: Layer}\n\nReturn true if v is a vertex of layer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.has_vertex-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, V}} where {T, M<:(AbstractMultilayerGraph{T}), V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.has_vertex","text":"has_vertex(mg::M, v::T) where {M <: AbstractMultilayerGraph{T} } where { T <: Integer}\n\nReturn true if v is a vertex of mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.indegree-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, AbstractVector{V}}} where {T, M<:(AbstractMultilayerGraph{T}), V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.indegree","text":"indegree(mg::M, vs::AbstractVector{V} = vertices(mg)) where {T,M <: AbstractMultilayerGraph{T, <: Real}, V <: MultilayerVertex{T}}\n\nGet the vector of indegrees of vertices vs in mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.indegree-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, V}} where {T, M<:(AbstractMultilayerGraph{T}), V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.indegree","text":"indegree(mg::M, v::V) where {T, M <: AbstractMultilayerGraph{T, <: Real}, V <: MultilayerVertex{T}}\n\nGet the indegree of vertex v in mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.inneighbors-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In<:Interlayer{T, U, G}}","page":"Internals","title":"Graphs.inneighbors","text":"inneighbors(interlayer::In, mv::MultilayerVertex{T}) where {T,U,G, In <: Interlayer{T,U,G}}\n\nReturn the list of inneighbors of v within interlayer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.inneighbors-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, MultilayerVertex{T}}} where {T, U, G, L<:Layer{T, U, G}}","page":"Internals","title":"Graphs.inneighbors","text":"inneighbors(layer::L, mv::MultilayerVertex{T}) where {T,U,G, L <: Layer{T,U,G}}\n\nReturn the list of inneighbors of v within layer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.inneighbors-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, V}} where {T, M<:(AbstractMultilayerGraph{T}), V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.inneighbors","text":"inneighbors(mg::M, v::T) where {M <: AbstractMultilayerGraph{T} } where { T <: Integer}\n\nReturn the list of inneighbors of v within mg, looping first over all layers (in the order they are given in mg.layers), then over all interlayers (in the order they are given in mg.interlayers).\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.is_directed-Tuple{In} where In<:Interlayer","page":"Internals","title":"Graphs.is_directed","text":"is_directed(interlayer::In) where { In <: Interlayer}\n\nReturns true if interlayer is directed, false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.is_directed-Tuple{L} where L<:Layer","page":"Internals","title":"Graphs.is_directed","text":"is_directed(layer::L) where { L <: Layer}\n\nReturns true if layer is directed, false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.is_directed-Tuple{M} where M<:(Type{<:MultilayerDiGraph})","page":"Internals","title":"Graphs.is_directed","text":"is_directed(mg::M) where { M <: Type{ <: MultilayerDiGraph}}\n\nReturns true if mg is directed, false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.is_directed-Tuple{M} where M<:(Type{<:MultilayerGraph})","page":"Internals","title":"Graphs.is_directed","text":"is_directed(m::M) where { M <: Type{ <: MultilayerGraph}}\n\nReturns true if m is directed, false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.is_directed-Tuple{M} where M<:MultilayerDiGraph","page":"Internals","title":"Graphs.is_directed","text":"is_directed(mg::M) where { M <: MultilayerDiGraph}\n\nReturns true if mg is directed, false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.is_directed-Tuple{M} where M<:MultilayerGraph","page":"Internals","title":"Graphs.is_directed","text":"is_directed(m::M) where { M <: MultilayerGraph}\n\nReturns true if m is directed, false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.is_directed-Union{Tuple{Type{In}}, Tuple{In}} where In<:Interlayer","page":"Internals","title":"Graphs.is_directed","text":"is_directed(interlayer_type::Type{In}) where {In <: Interlayer}\n\nReturns true if interlayer_type is directed, false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.is_directed-Union{Tuple{Type{L}}, Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, L<:Layer{T, U, G}}","page":"Internals","title":"Graphs.is_directed","text":"is_directed(::Type{L}) where {T,U,G,L <: Layer{T,U,G}}\n\nReturns true if layer_type is directed, false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.modularity-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, Matrix{Int64}}} where {T, U, M<:AbstractMultilayerGraph{T, U}}","page":"Internals","title":"Graphs.modularity","text":"modularity(mg::M, c::Matrix{Int64}; null_model::Union{String,Array{U,4}} = \"degree\") where {T, U, M <: AbstractMultilayerGraph{T,U}}\n\nCalculate the modularity of mg, as shown in De Domenico et al. (2013).\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.ne-Tuple{In} where In<:Interlayer","page":"Internals","title":"Graphs.ne","text":"ne(interlayer::In) where { In <: Interlayer}\n\nReturn the number of edges in interlayer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.ne-Tuple{L} where L<:Layer","page":"Internals","title":"Graphs.ne","text":"ne(layer::L) where { L <: Layer}\n\nReturn the number of edges in layer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.ne-Tuple{M} where M<:AbstractMultilayerGraph","page":"Internals","title":"Graphs.ne","text":"ne(mg::M) where {M <: AbstractMultilayerGraph }\n\nReturn the number of edges in mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.neighbors-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, V}} where {T, M<:(AbstractMultilayerGraph{T}), V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.neighbors","text":"neighbors(mg::M, v::V) where {T, M <: AbstractMultilayerGraph{T, <: Real}, V <: MultilayerVertex{T}}\n\nGet the neighbors of vertices vs in mg. Reduces to outneighbors for both directed and undirected multilayer graphs.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.nv-Tuple{In} where In<:Interlayer","page":"Internals","title":"Graphs.nv","text":"nv(interlayer::In) where { In <: Interlayer}\n\nReturn the number of vertices in interlayer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.nv-Tuple{L} where L<:Layer","page":"Internals","title":"Graphs.nv","text":"nv(layer::L) where { L <: Layer}\n\nReturn the number of vertices in layer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.nv-Tuple{M} where M<:AbstractMultilayerGraph","page":"Internals","title":"Graphs.nv","text":"nv(mg::M) where {M <: AbstractMultilayerGraph }\n\nReturn the number of vertices in mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.outdegree-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, AbstractVector{V}}} where {T, M<:(AbstractMultilayerGraph{T}), V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.outdegree","text":"outdegree(mg::M, vs::AbstractVector{V} = vertices(mg)) where {T,M <: AbstractMultilayerGraph{T, <: Real}, V <: MultilayerVertex{T}} \n\nGet the vector of outdegrees of vertices vs in mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.outdegree-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, V}} where {T, M<:(AbstractMultilayerGraph{T}), V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.outdegree","text":"outdegree(mg::M, v::V) where {T, M <: AbstractMultilayerGraph{T, <: Real}, V <: MultilayerVertex{T}}\n\nGet the outdegree of vertex v in mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.outneighbors-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{In, MultilayerVertex{T}}} where {T, U, G, In<:Interlayer{T, U, G}}","page":"Internals","title":"Graphs.outneighbors","text":"outneighbors(interlayer::In, v::T) where {In <: Interlayer{T} } where { T <: Integer}\n\nReturn the list of outneighbors of v within interlayer, looping first over all layers (in the order they are given in interlayer.layers), then over all interlayers (in the order they are given in interlayer.interlayers).\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.outneighbors-Union{Tuple{L}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{L, MultilayerVertex{T}}} where {T, U, G, L<:Layer{T, U, G}}","page":"Internals","title":"Graphs.outneighbors","text":"outneighbors(layer::L, mv::MultilayerVertex{T}) where {T,U,G, L <: Layer{T,U,G}} =\n\nReturn the list of outneighbors of v within layer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.outneighbors-Union{Tuple{V}, Tuple{M}, Tuple{T}, Tuple{M, V}} where {T, M<:(AbstractMultilayerGraph{T}), V<:MultilayerVertex{T}}","page":"Internals","title":"Graphs.outneighbors","text":"outneighbors(mg::M, v::T) where {M <: AbstractMultilayerGraph{T} } where { T <: Integer}\n\nReturn the list of outneighbors of v within mg, looping first over all layers (in the order they are given in mg.layers), then over all interlayers (in the order they are given in mg.interlayers).\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.vertices-Tuple{In} where In<:Interlayer","page":"Internals","title":"Graphs.vertices","text":"vertices(interlayer::In) where {In <: Interlayer{ <: Integer, <: AbstractSimpleGraph}}\n\nReturn the collection of the vertices of interlayer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.vertices-Tuple{L} where L<:Layer","page":"Internals","title":"Graphs.vertices","text":"vertices(layer::L) where { L <: Layer}\n\nReturn the collection of the vertices of layer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Graphs.vertices-Tuple{M} where M<:AbstractMultilayerGraph","page":"Internals","title":"Graphs.vertices","text":"vertices(mg::M) where {M <: AbstractMultilayerGraph{ <: Integer, <: AbstractSimpleGraph}}\n\nReturn the collection of the vertices of mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs._add_layer!-Union{Tuple{H}, Tuple{L}, Tuple{G}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, M<:AbstractMultilayerGraph{T, U}, G<:Graphs.AbstractGraph{T}, L<:Layer{T, U, G}, H<:(Type{<:Graphs.AbstractGraph{T}})}","page":"Internals","title":"MultilayerGraphs._add_layer!","text":"_add_layer!(mg::M,new_layer::L; new_default_interlayers_type::H) where { T, U, G <: AbstractGraph{T}, H <: AbstractGraph{T}, M <: AbstractMultilayerGraph{T, U}, L <: Layer{T,U,G}\n\nInternal function. It is called by the add_layer! API functions, which needs to specify the default interlayer graph type (SimpleGraph for undirected multilayer graphs, SimpleDiGraph for directed multilayer graphs).\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs._specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G<:Graphs.AbstractGraph{T}, M<:AbstractMultilayerGraph{T, U}, In<:Interlayer{T, U, G}}","page":"Internals","title":"MultilayerGraphs._specify_interlayer!","text":"_specify_interlayer!(mg::M, new_interlayer::In; symmetric_interlayer_name::String) where { T, U, G <: AbstractGraph{T}, M <: AbstractMultilayerGraph{T, U}, In <: Interlayer{T,U,G}}\n\nInternal function. It is called by the specify_interlayer! API functions.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.add_layer!-Union{Tuple{L}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, G<:Graphs.AbstractGraph{T}, M<:MultilayerDiGraph{T, U}, L<:Layer{T, U, G}}","page":"Internals","title":"MultilayerGraphs.add_layer!","text":"add_layer!(mg::M,layer::L; interlayers_type = \"multiplex\") where { T, undef, M <: MultilayerDiGraph{T, G, U}, L <: Layer{T,U,G}}\n\nAdd layer layer to mg. Also add Interlayers of type interlayers_type (can only be \"multiplex\") between the new layer and all the other ones. \n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.add_layer!-Union{Tuple{L}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, G<:Graphs.AbstractGraph{T}, M<:MultilayerGraph{T, U}, L<:Layer{T, U, G}}","page":"Internals","title":"MultilayerGraphs.add_layer!","text":"add_layer!(mg::M,layer::L; interlayers_type = \"multiplex\") where { T, U, G<: AbstractGraph{T}, M <: MultilayerGraph{T, U}, L <: Layer{T,U,G}}\n\nAdd layer layer to mg. Also add Interlayers of type interlayers_type (can only be \"multiplex\") between the new layer and all the other ones. \n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.adjm_eltype-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M<:AbstractMultilayerGraph{T, U}}","page":"Internals","title":"MultilayerGraphs.adjm_eltype","text":"adjm_eltype(mg::M) where {M <: AbstractMultilayerGraph}\n\nReturn the vertex type of mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.check_unique-Tuple{Union{Missing, Tuple, Vector}}","page":"Internals","title":"MultilayerGraphs.check_unique","text":"check_unique(vec::Union{Missing, <: Vector, <: Tuple})\n\nReturn true if all elements in vec are unique or if ismissing(vec), else return false.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.degree_second_moment-Tuple{M} where M<:AbstractMultilayerGraph","page":"Internals","title":"MultilayerGraphs.degree_second_moment","text":"degree_second_moment(mg::M) where { M <: AbstractMultilayerGraph}\n\nCalculate the second moment of the degree sequence of mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.degree_variance-Tuple{M} where M<:AbstractMultilayerGraph","page":"Internals","title":"MultilayerGraphs.degree_variance","text":"degree_variance(mg::M) where { M <: AbstractMultilayerGraph}\n\nReturn the variance of the degree sequence of mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.find_trunc_dim","page":"Internals","title":"MultilayerGraphs.find_trunc_dim","text":"Finds the dimension to which v should be truncated, and the error caused in this truncation. See documentation for tensorsvd for the meaning of the different arguments.\n\n\n\n\n\n","category":"function"},{"location":"internals/#MultilayerGraphs.format_trunc_chis-Tuple{Any, Any, Any}","page":"Internals","title":"MultilayerGraphs.format_trunc_chis","text":"Format the bond dimensions listed in chis to a standard format.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.get_common_type-Tuple{Vector{<:DataType}}","page":"Internals","title":"MultilayerGraphs.get_common_type","text":"get_common_type(types::Vector{<: DataType})\n\nReturns the minimum common supertype of types.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.get_concrete_subtypes-Tuple{Type}","page":"Internals","title":"MultilayerGraphs.get_concrete_subtypes","text":"get_concrete_subtypes(type::Type)\n\nReturn an array of all concrete subtypes of type (which should be abstract).\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.get_diagonal_adjacency_tensor-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T","page":"Internals","title":"MultilayerGraphs.get_diagonal_adjacency_tensor","text":"get_diagonal_adjacency_tensor(arr,dims)\n\nReturns a tensor whose size is dims and has arr on the diagonal.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.get_diagonal_elements-Union{Tuple{Array{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Internals","title":"MultilayerGraphs.get_diagonal_elements","text":"get_diagonal_elements(arr::Array{T,N}) where {T,N}\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.get_graph_of_layers-Tuple{M} where M<:MultilayerDiGraph","page":"Internals","title":"MultilayerGraphs.get_graph_of_layers","text":"get_graph_of_layers(mg::M) where {M <: MultilayerDiGraph}\n\nGet a DiGraphOfGraph of the layers of mg. the weight of each edge between layers are obtained by summing all edge weights in the corresponding interlayer. See De Domenico et al. (2013).\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.get_graph_of_layers-Tuple{M} where M<:MultilayerGraph","page":"Internals","title":"MultilayerGraphs.get_graph_of_layers","text":"get_graph_of_layers(mg::M) where {M <: MultilayerGraph}\n\nGet a DiGraphOfGraph of the layers of mg. the weight of each edge between layers are obtained by summing all edge weights in the corresponding interlayer. See De Domenico et al. (2013).\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.get_interlayer-Union{Tuple{M}, Tuple{M, Symbol, Symbol}} where M<:AbstractMultilayerGraph","page":"Internals","title":"MultilayerGraphs.get_interlayer","text":"get_interlayer(mg::M, layer_1::Symbol, layer_2::Symbol) where {M <: AbstractMultilayerGraph}\n\nReturn (idxs_cart,interlayer) where interlayer is the Interlayer between layer_1 and layer_2 and idxs_cart is the CartesianIndex such that mg.adjacency_tensor[:,:,idxs_cart] is the adjacency matrix of interlayer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.get_layer-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, Symbol}} where {T, U, M<:AbstractMultilayerGraph{T, U}}","page":"Internals","title":"MultilayerGraphs.get_layer","text":"get_layer(mg::M, layer_name::Symbol) where {T, U, M <: AbstractMultilayerGraph{T, U}}\n\nReturn (idxs_cart,layer) where layer_name is the name of the Layer being queried and idxs_cart is the CartesianIndex such that mg.adjacency_tensor[:,:,idxs_cart] is the adjacency matrix of such layer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.get_oom-Tuple{Number}","page":"Internals","title":"MultilayerGraphs.get_oom","text":"get_oom(x::Number)\n\nGet the order of magnitude of x.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.get_overlay_monoplex_graph-Tuple{M} where M<:MultilayerDiGraph","page":"Internals","title":"MultilayerGraphs.get_overlay_monoplex_graph","text":"get_overlay_monoplex_graph(mg::M) where {M<: MultilayerDiGraph}\n\nGet overlay monoplex graph (i.e. the graph that has the same nodes as mg but the link between node i and j has weight equal to the sum of all edges weights between the various vertices representing i and j in mg, accounting for both layers and interlayers). See De Domenico et al. (2013).\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.get_overlay_monoplex_graph-Tuple{M} where M<:MultilayerGraph","page":"Internals","title":"MultilayerGraphs.get_overlay_monoplex_graph","text":"get_overlay_monoplex_graph(mg::M) where {M<: MultilayerGraph}\n\nGet overlay monoplex graph (i.e. the graph that has the same nodes as mg but the link between node i and j has weight equal to the sum of all edges weights between the various vertices representing i and j in mg, accounting for both layers and interlayers). See De Domenico et al. (2013).\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.get_projected_monoplex_graph-Tuple{M} where M<:MultilayerDiGraph","page":"Internals","title":"MultilayerGraphs.get_projected_monoplex_graph","text":"get_projected_monoplex_graph(mg::M) where {M<: MultilayerDiGraph}\n\nGet projected monoplex graph (i.e. the graph that as the same nodes as mg but the link between node i and j has weight equal to the sum of all edges weights between the various vertices representing i and j in mg, accounting for both layers and interlayers). See De Domenico et al. (2013).\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.get_projected_monoplex_graph-Tuple{M} where M<:MultilayerGraph","page":"Internals","title":"MultilayerGraphs.get_projected_monoplex_graph","text":"get_projected_monoplex_graph(mg::M) where {M<: MultilayerGraph}\n\nGet projected monoplex graph (i.e. that graph that as the same nodes as mg but the link between node i and j has weight equal to the sum of all edges weights between the various vertices representing i and j in mg, accounting for both layers and interlayers). See De Domenico et al. (2013).\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.get_subgraph-Union{Tuple{M}, Tuple{M, Vararg{Symbol}}} where M<:AbstractMultilayerGraph","page":"Internals","title":"MultilayerGraphs.get_subgraph","text":"get_subgraph(mg::M, names...) where {M <: AbstractMultilayerGraph}\n\nIf length(names) == 1, then this is equivalent to calling get_layer(mg,names[1]) else if length(names) == 2, this is equivalent to calling get_interlayer(mg,names[1],names[2]). Throws an ErrorException in all other cases. \n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.get_symmetric_interlayer-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, In<:Interlayer{T, U, G}}","page":"Internals","title":"MultilayerGraphs.get_symmetric_interlayer","text":"get_symmetric_interlayer(interlayer::In; symmetric_interlayer_name::String) where{T,U,G, In <: Interlayer{T,U,G}}\n\nReturn the Interlayer corresponding to interlayer where layer_1 and layer_2 are swapped. Its name will be symmetric_interlayer_name (defaults to interlayer_(interlayer.layer_2)_(interlayer.layer_1) ).\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.is_weighted-Tuple{G} where G<:Graphs.AbstractGraph","page":"Internals","title":"MultilayerGraphs.is_weighted","text":"is_weighted(g::G) where { G <: AbstractGraph}\n\nCheck whether g is weighted.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.isapproxsymmetric-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Integer","page":"Internals","title":"MultilayerGraphs.isapproxsymmetric","text":"isapproxsymmetric(A::Matrix{T}) where {T <: Real }\n\nCheck whether A is symmetric (within zero(T)).\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.isapproxsymmetric-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Real","page":"Internals","title":"MultilayerGraphs.isapproxsymmetric","text":"isapproxsymmetric(A::Matrix{T}) where {T <: Real }\n\n\"Check whether A is approximately symmetric (within eps(T)).\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.iscompletelyinitialized-Tuple{Any}","page":"Internals","title":"MultilayerGraphs.iscompletelyinitialized","text":"iscompletelyinitialized(obj::Any)\n\nCheck whether obj is completely initialized.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.mean_degree-Tuple{M} where M<:AbstractMultilayerGraph","page":"Internals","title":"MultilayerGraphs.mean_degree","text":"mean_degree(mg::M) where { M <: AbstractMultilayerGraph}\n\nReturn the mean of the degree sequence of mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.multilayer_global_clustering_coefficient-Union{Tuple{M}, Tuple{M, Union{Float64, Symbol}}} where M<:AbstractMultilayerGraph","page":"Internals","title":"MultilayerGraphs.multilayer_global_clustering_coefficient","text":"multilayer_clustering_coefficient(mg::M, norm_factor::Union{Float64, Symbol} = :max) where {M <: AbstractMultilayerGraph}\n\nReturn the complete multilayer global clustering coefficient, equal to the ratio of realized triplets over all possible triplets, including those whose every or some edges belong to interlayers, normalized by norm_factor. If norm_factor == :max, then the ratio is normalized by maximum(mg.adjacency_tensor). This function overrides Graphs.jl's global_clustering_coefficient, since the latter does not consider cliques where two nodes are the same node but in different layers/interlayers. See De Domenico et al. (2013).\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.multilayer_kronecker_delta-Tuple{NTuple{4, Int64}}","page":"Internals","title":"MultilayerGraphs.multilayer_kronecker_delta","text":"multilayer_kronecker_delta(dims...)\n\nReturns a 4 dimensional kronecker delta with size equal to dims.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.multilayer_weighted_global_clustering_coefficient-Union{Tuple{M}, Tuple{M, Vector{Float64}}, Tuple{M, Vector{Float64}, Union{Float64, Symbol}}} where M<:AbstractMultilayerGraph","page":"Internals","title":"MultilayerGraphs.multilayer_weighted_global_clustering_coefficient","text":"multilayer_weighted_global_clustering_coefficient(mg::M, norm_factor::Union{Float64, Symbol} = :max) where {M <: AbstractMultilayerGraph}\n\nReturn the complete multilayer global clustering coefficient, equal to the ratio of realized triplets over all possible triplets, including those whose every or some edges belong to interlayers, normalized by norm_factor. Each triplets contributes for w[1] if all of its vertices are in one layer, w[2] if its vertices span two layers, and w[3] if they span 3 layers. If norm_factor == :max, then the ratio is normalized by maximum(mg.adjacency_tensor). This function overrides Graphs.jl's global_clustering_coefficient, since the latter does not consider cliques where two nodes are the same node but in different layers/interlayers. See De Domenico et al. (2013).\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.multiplex_interlayer-Union{Tuple{G}, Tuple{T}, Tuple{Int64, Symbol, Symbol, Symbol, Type{G}}} where {T<:(Union{AbstractVertex, var\"#s14\"} where var\"#s14\"<:Integer), G<:Graphs.AbstractGraph{T}}","page":"Internals","title":"MultilayerGraphs.multiplex_interlayer","text":"multiplex_interlayer(nv::Int64, name::Symbol,layer_1::Symbol, layer_2::Symbol, graph_type::Type{G}; forbidden_vertices::Vector{MultilayerVertex{T}}, forbidden_edges::Vector{NTuple{2, MultilayerVertex{T}}}) where {T <: Union{ <: Integer, AbstractVertex}, G <: AbstractGraph{T};  IsWeighted{G}}\n\nReturn an Interlayer{T,U,G} that has edges only between vertices that represent the same node.\n\nARGUMENTS\n\nnv::Int64: number of vertices;\nname::Symbol: name of the Interlayer;\nlayer_1::Symbol: The first Layer it connects;\nlayer_2::Symbol: The second Layer it connects;\ngraph_type::Type{G}: the underlying graph type;\nU::Type = Float64: the eltype of the adjacency matrix of the Interlayer. Note: it doesn't have to coincide with the underlying graph's adjacency matrix eltype, since right now there is no guarantee that all Graphs.jl's extension will allow the user to set such eltype on new graph types.\nforbidden_vertices::Vector{MultilayerVertex{T}}: list of vertices that are not considered present in the Interlayer;\nforbidden_edges::Vector{NTuple{2, MultilayerVertex{T}}}: list of edges whose existence is a priori excluded from the Interlayer.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.nIn-Tuple{M} where M<:AbstractMultilayerGraph","page":"Internals","title":"MultilayerGraphs.nIn","text":"nIn(mg::M) where {M <: AbstractMultilayerGraph }\n\nReturn the number of interlayers in mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.nl-Tuple{M} where M<:AbstractMultilayerGraph","page":"Internals","title":"MultilayerGraphs.nl","text":"nl(mg::M) where {M <: AbstractMultilayerGraph }\n\nReturn the number of layers in mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.nn-Tuple{M} where M<:AbstractMultilayerGraph","page":"Internals","title":"MultilayerGraphs.nn","text":"nn(mg::M) where {M <: AbstractMultilayerGraph }\n\nReturn the number of nodes in mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.nodes-Tuple{M} where M<:AbstractMultilayerGraph","page":"Internals","title":"MultilayerGraphs.nodes","text":"nodes(mg::M) where {M <: AbstractMultilayerGraph}\n\nReturn the nodes of the AbstractMultilayerGraph mg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.overlay_clustering_coefficient-Union{Tuple{M}, Tuple{M, Union{Float64, Symbol}}} where M<:AbstractMultilayerGraph","page":"Internals","title":"MultilayerGraphs.overlay_clustering_coefficient","text":"overlay_clustering_coefficient(mg::M, norm_factor::Union{Float64, Symbol} = :max) where {M <: AbstractMultilayerGraph}\n\nReturn the overlay clustering coefficient as calculated in De Domenico et al. (2013).\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G<:Graphs.AbstractGraph{T}, M<:MultilayerDiGraph{T, U}, In<:Interlayer{T, U, G}}","page":"Internals","title":"MultilayerGraphs.specify_interlayer!","text":"specify_interlayer!(mg::M, new_interlayer::In; symmetric_interlayer_name::Symbol) where { T, U, G<: AbstractGraph{T}, M <: MultilayerDiGraph{T, U}, In <: Interlayer{T,G}; IsDirected{M}}\n\nSpecify the interlayer new_interlayer as part of mg. The underlying graph of new_interlayer must be directed.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G<:Graphs.AbstractGraph{T}, M<:MultilayerGraph{T, U}, In<:Interlayer{T, U, G}}","page":"Internals","title":"MultilayerGraphs.specify_interlayer!","text":"specify_interlayer!(mg::M, new_interlayer::In; symmetric_interlayer_name::String) where { T, U, G<: AbstractGraph{T}, M <: MultilayerGraph{T, U}, In <: Interlayer{T,U,G}}\n\nSpecify the interlayer new_interlayer as part of mg. The underlying graph of new_interlayer must be undirected.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.specify_interlayer!-Union{Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, Symbol, Symbol, G}} where {T, U, G<:Graphs.AbstractGraph{T}, M<:MultilayerDiGraph{T, U}}","page":"Internals","title":"MultilayerGraphs.specify_interlayer!","text":"specify_interlayer!(mg::M, layer_1::Symbol, layer_2::Symbol, graph::G; new_interlayer_name::Symbol, symmetric_interlayer_name::Symbol ,  forbidden_vertices::Tuple{Vararg{MultilayerVertex{T}}}, forbidden_edges::Tuple{Vararg{NTuple{2, MultilayerVertex{T}}}} ) where { T, U, G<: AbstractGraph{T}, M <: MultilayerDiGraph{T,U}}\n\nSpecify an interlayer which is represented by graph between layer_1 and layer_2. The Interlayer's name can be specified via new_interlayer_name, as the name of its corresponding Interlayer between layer_2 and layer_1 (via the symmetric_interlayer_name) which is the same graph just with the adjacency matrix reordered.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.src-Tuple{AbstractMultilayerEdge}","page":"Internals","title":"MultilayerGraphs.src","text":"src(e::AbstractMultilayerEdge)\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.tensoreig-Tuple{Any, Any, Any}","page":"Internals","title":"MultilayerGraphs.tensoreig","text":"tensoreig(A, a, b; chis=nothing, eps=0,\n          return_error=false, print_error=false,\n          break_degenerate=false, degeneracy_eps=1e-6,\n          norm_type=:frobenius, hermitian=false)\n\nFinds the \"right\" eigenvectors and eigenvalues of A. The indices of A are permuted so that the indices listed in the Array/Tuple a are on the \"left\" side and indices listed in b are on the \"right\".  The resulting tensor is then reshaped to a matrix, and eig is called on this matrix to get the vector of eigenvalues E and matrix of eigenvectors U. Finally, U is reshaped to a tensor that has as its last index the one that enumerates the eigenvectors and the indices in a as its first indices.\n\nTruncation and error printing work as with tensorsvd.\n\nNote that no iterative techniques are used, which means that choosing to truncate provides no performance benefits: All the eigenvalues are computed in any case.\n\nThe keyword argument hermitian (false by default) tells the algorithm whether the reshaped matrix is Hermitian or not. If hermitian=true, then A = Udiagm(E)U' up to the truncation error.\n\nOutput is E, U, and possibly error, if return_error=true. Here E is a vector of eigenvalues values and U[:,...,:,k] is the kth eigenvector.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.tensorsplit-Tuple","page":"Internals","title":"MultilayerGraphs.tensorsplit","text":"tensorsplit(A, a, b; kwargs...)\n\nCalls tensorsvd with the arguments given to it to decompose the given tensor A with indices a on one side and indices b on the other.  It then splits the diagonal matrix of singular values into two with a square root and multiplies these weights into the isometric tensors.  Thus tensorsplit ends up splitting A into two parts, which are then returned, possibly together with auxiliary data such as a truncation error. If the keyword argument hermitian=true, an eigenvalue decomposition is used in stead of an SVD. All the keyword arguments are passed to either tensorsvd or tensoreig.\n\nSee tensorsvd and tensoreig for further documentation.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.tensorsvd-Tuple{Any, Any, Any}","page":"Internals","title":"MultilayerGraphs.tensorsvd","text":"tensorsvd(A, a, b;\n          chis=nothing, eps=0,\n          return_error=false, print_error=false,\n          break_degenerate=false, degeneracy_eps=1e-6,\n          norm_type=:frobenius)\n\nSingular valued decomposes a tensor A. The indices of A are permuted so that the indices listed in the Array/Tuple a are on the \"left\" side and indices listed in b are on the \"right\".  The resulting tensor is then reshaped to a matrix, and this matrix is SVDed into Udiagm(S)Vt. Finally, the unitary matrices U and Vt are reshaped to tensors so that they have a new index coming from the SVD, for U as the last index and for Vt as the first, and U has indices a as its first indices and V has indices b as its last indices.\n\nIf eps>0 then the SVD may be truncated if the relative error can be kept below eps. For this purpose different dimensions to truncate to can be tried, and these dimensions should be listed in chis. If chis is nothing (the default) then the full range of possible dimensions is tried. If breakdegenerate=false (the default) then the truncation never cuts between degenerate singular values. degeneracyeps controls how close the values need to be to be considered degenerate.\n\nnorm_type specifies the norm used to measure the error. This defaults to :frobenius, which means that the error measured is the Frobenius norm of the difference between A and the decomposition, divided by the Frobenius norm of A.  This is the same thing as the 2-norm of the singular values that are truncated out, divided by the 2-norm of all the singular values. The other option is :trace, in which case a 1-norm is used instead.\n\nIf print_error=true the truncation error is printed. The default is false.\n\nIf return_error=true then the truncation error is also returned. The default is false.\n\nNote that no iterative techniques are used, which means choosing to truncate provides no performance benefits: The full SVD is computed in any case.\n\nOutput is U, S, Vt, and possibly error. Here S is a vector of singular values and U and Vt are isometric tensors (unitary if the matrix that is SVDed is square and there is no truncation) such that  Udiag(S)Vt = A, up to truncation errors.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.to_matrix-Tuple{Any, Any, Any}","page":"Internals","title":"MultilayerGraphs.to_matrix","text":"Transpose A so that the indices listed in a are on the left and the indices listed in b on the right, and reshape A into a matrix.\n\na and b should be arrays of Integers that together include the numbers from 1 to ndims(A). Alternatively they can be just individual Integers, if only one index is left on one side.\n\nIf returntensorshape is true (by default it's not) return, in addition to the matrix, the shape of the tensor after the transpose but before the reshape.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.von_neumann_entropy-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M<:MultilayerGraph{T, U}}","page":"Internals","title":"MultilayerGraphs.von_neumann_entropy","text":"von_neumann_entropy(mg::M) where {T,U,  M <: MultilayerGraph{T, U}}\n\nCompute the Von Neumann entropy of mg, according to De Domenico et al. (2013). Only for undirected multilayer graphs.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MultilayerGraphs.weight-Tuple{AbstractMultilayerEdge}","page":"Internals","title":"MultilayerGraphs.weight","text":"weight(e::AbstractMultilayerEdge)\n\n\n\n\n\n","category":"method"}]
}
