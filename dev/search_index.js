var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MultilayerGraphs","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div style=\"width:100%; height:150px;border-width:4px;border-style:solid;padding-top:25px;\n        border-color:#000;border-radius:10px;text-align:center;background-color:#B3D8FF;\n        color:#000\">\n    <h3 style=\"color: black;\">Star us on GitHub!</h3>\n    <a class=\"github-button\" href=\"https://github.com/InPhyT/MultilayerGraphs.jl\" data-icon=\"octicon-star\" data-size=\"large\" data-show-count=\"true\" aria-label=\"Star InPhyT/MultilayerGraphs.jl on GitHub\" style=\"margin:auto\">Star</a>\n    <script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n</div>","category":"page"},{"location":"#MultilayerGraphs.jl","page":"Home","title":"MultilayerGraphs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraphs.jl is a Julia package for the construction, manipulation and analysis of multilayer graphs extending Graphs.jl.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraphs.jl implements the mathematical formulation of multilayer graphs proposed by De Domenico et al. (2013). It mainly revolves around two custom types, MultilayerGraph and MultilayerDiGraph, encoding undirected and directed multilayer graphs respectively. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Roughly speaking, a multilayer graph is a collection of graphs, called layers, whose vertices are representations of the same set of nodes endowed with a relational structure provided by the interlayer: the bipartite graph whose vertices are those of any two consecutive layers and whose edges are those between nodes of the two consecutive layers. See below for the distinction between node and vertex.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraph and MultilayerDiGraph are fully-fledged Graphs.jl extensions. Both structs are designed so that their layers and interlayers can be of any type (as long as they are Graphs.jl extensions themselves) and they need not be all of the same type. It is anyway required that all layers and interlayers of MultilayerGraph and MultilayerDiGraph are respectively undirected and directed. Directedness is checked via the IsDirected trait defined in Graphs.jl adopting SimpleTraits.jl. Since the layers' and interlayers' graph types don't need to be the same, multilayer graph types are considered weighted graphs by default, and thus are assigned the trait IsWeighted.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Press ] in the Julia REPL and then","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/InPhyT/MultilayerGraphs.jl","category":"page"},{"location":"#Tutorial","page":"Home","title":"Tutorial","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here we illustrate how to define, handle and analyse a MultilayerGraph (the directed version is completely analogous).","category":"page"},{"location":"#Layers-and-Interlayers","page":"Home","title":"Layers and Interlayers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's import some necessary packages","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Import necessary dependencies\nusing Graphs, SimpleWeightedGraphs, MultilayerGraphs","category":"page"},{"location":"","page":"Home","title":"Home","text":"We define some methods and constants that will prove useful later in the tutorial (you may come back to these later when they get used)","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Set the number of nodes, minimum and maximum number of edges for random graphs\nconst n_nodes   = 5\nconst min_edges = n_nodes\nconst max_edges = 10\n\n# Define methods generating random graphs\nget_SimpleGraph()   = SimpleGraph(n_nodes, rand(min_edges:max_edges))   # Undirected graph\nget_SimpleDiGraph() = SimpleDiGraph(n_nodes, rand(min_edges:max_edges)) # Directed graph\n\n# Define variables for random weighted graphs\nconst simpleweightedgraph_sources      = 1:n_nodes\nconst simpleweightedgraph_destinations = rand(1:n_nodes, n_nodes)\nconst simpleweightedgraph_weights      = rand(n_nodes)\n\n# Define methods generating random weighted graphs\nget_SimpleWeightedGraph()   = SimpleWeightedGraph(simpleweightedgraph_sources, rand(1:n_nodes, n_nodes), rand(n_nodes))    # Undirected graph\nget_SimpleWeightedDiGraph() = SimpleWeightedDiGraph(simpleweightedgraph_sources, rand(1:n_nodes, n_nodes), rand(n_nodes))  # Directed graph","category":"page"},{"location":"","page":"Home","title":"Home","text":"We proceed by constructing a layer (see Layer)","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Construct a layer \nlayer = Layer(:layer_1, SimpleGraph(n_nodes, rand(min_edges:max_edges)); U = Float64)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Layer has a name (here :layer_1), an underlying graph (SimpleGraph(n_nodes, rand(min_edges:max_edges))) and an adjacency matrix eltype U. To correctly specify a multilayer graph all layers and interlayers must have the same U, otherwise the adjacency tensor would be poorly specified. Notice that U does not need to coincide with the eltype of the adjacency matrix of the underlying graph. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"As far as we know, there is no way to set it explicitly for all Graphs.jl extensions, nor it is required for extensions to implement such feature, so our package converts to U the eltype of Layers and Interlayers adjacency matrices every time they are invoked","category":"page"},{"location":"","page":"Home","title":"Home","text":"adjacency_matrix(layers[1])","category":"page"},{"location":"","page":"Home","title":"Home","text":"5×5 SparseMatrixCSC{Float64, Int64} with 16 stored entries:\n  ⋅   1.0   ⋅   1.0  1.0\n 1.0   ⋅   1.0  1.0   ⋅\n  ⋅   1.0   ⋅   1.0  1.0\n 1.0  1.0  1.0   ⋅   1.0\n 1.0   ⋅   1.0  1.0   ⋅","category":"page"},{"location":"","page":"Home","title":"Home","text":"We may define more Layers for future use","category":"page"},{"location":"","page":"Home","title":"Home","text":"layers = [\n            Layer(:layer_1, get_SimpleGraph(); U = Float64),\n            Layer(:layer_2, get_SimpleWeightedGraph(); U = Float64),\n            Layer(:layer_3, get_SimpleWeightedGraph(); U = Float64),\n         ]","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are other constructors for the Layer struct you may want to consult via ?Layer.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We similarly define an interlayer (see Interlayer)","category":"page"},{"location":"","page":"Home","title":"Home","text":"interlayer = Interlayer(n_nodes, :interlayer_layer_1_layer_2 , :layer_1, :layer_2, SimpleGraph{Int64}, rand(min_edges:max_edges); U = Float64)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here we used a constructor that returns a random Interlayer. Its arguments are the number of nodes n_nodes, the name of the Interlayer interlayer_layer_1_layer_2, the name of the Layers that it connects (:layer_1 and :layer_2), the underlying graph type SimpleGraph{Int64}, and the number of edges rand(min_edges:max_edges) and the adjacency matrix eltype again need to be specified (although it may be left blank and the constructor will default to eltype(adjacency_matrix(SimpleGraph{Int64}))).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The adjacency matrix of an Interlayer is that of a bipartite graph","category":"page"},{"location":"","page":"Home","title":"Home","text":"adjacency_matrix(interlayer)","category":"page"},{"location":"","page":"Home","title":"Home","text":"10×10 SparseMatrixCSC{Float64, Int64} with 18 stored entries:\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0\n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅   1.0  1.0   ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0  1.0   ⋅    ⋅   1.0\n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅ \n  ⋅   1.0  1.0  1.0  1.0   ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n 1.0   ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ ","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is a 4 block matrix where the first n_nodes rows and columns refer to :layer_1's vertices, while the last n_nodes rows and columns refer to :layer_2's vertices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We may define more Interlayers for future use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"interlayers = [ \n                Interlayer(n_nodes, :interlayer_layer_1_layer_2, :layer_1, :layer_2, SimpleGraph{Int64}, rand(min_edges:max_edges); U = Float64), \n                Interlayer(n_nodes, :interlayer_layer_1_layer_3, :layer_1, :layer_3, SimpleWeightedGraph{Int64,Float64}, rand(min_edges:max_edges)) \n              ]","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are other constructors for the Interlayer struct you may want to consult via ?Interlayer.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Layers and Interlayers and complete extensions of Graphs.jl, so all methods in Graphs.jl should just work. The explicitly extended methods are edges, eltype, edgetype, has_edge, has_vertex, inneighbors, ne, nv, outneighbors, vertices, is_directed, add_edge!, rem_edge!.","category":"page"},{"location":"#Instantiation-and-Handling-of-MultilayerGraph","page":"Home","title":"Instantiation and Handling of MultilayerGraph","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We can define a MultilayerGraph by specifying its layers and interlayers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayergraph = MultilayerGraph(layers, interlayers; default_interlayer = \"multiplex\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraph{Int64, Float64}([0.0 1.0 … 1.0 1.0; 1.0 0.0 … 0.0 1.0; … ; 1.0 0.0 … 0.0 0.0; 1.0 1.0 … 0.0 0.0;;; 0.0 0.0 … 0.0 0.0; 0.0 1.0 …],...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is not important that the interlayers array does not contain all the interlayers needed to specify the multilayer graph: the unspecified interlayers are automatically generated according to the default_interlayer argument. Right now only the \"multiplex\" value is supported, and will generate interlayers that have edges between pair of vertices of the two layers that represent the same node.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Notice that in the output the signature of MultilayerGraph has two parametric types, namely MultilayerGraph{Int64, Float64}. The first is referred to the node type, that just as in every Graphs.jl extension it is a subtype of Integer. The second parameter is instead the eltype of the equivalent of the adjacency matrix for multilayer graphs: the adjacency tensor (see below for more).","category":"page"},{"location":"","page":"Home","title":"Home","text":"You may also specify random MultilayerGraph","category":"page"},{"location":"","page":"Home","title":"Home","text":"random_multilayergraph = MultilayerGraph( 3,         # Number of layers\n                                          n_nodes,   # Number of nodes\n                                          min_edges, # Minimum number of edges in each layer/interlayer\n                                          max_edges, # Maximum number of edges in each layer/interlayer\n                                          [\n                                             SimpleGraph{Int64},\n                                             SimpleWeightedGraph{Int64, Float64},\n                                          ]          # The set of graph types to random draw from when constructing layers and interlayers\n                                        )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, one may add layers and interlayers calling the add_layer! and specify_interlayer! functions respectively, perhaps starting with an empty multilayer graph created with the constructor:","category":"page"},{"location":"","page":"Home","title":"Home","text":"empty_multilayergraph  = MultilayerGraph( n_nodes, # Number of nodes\n                                          Int64,   # Node type\n                                          Float64  # Adjacency tensor's eltype, see below\n                                        )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's explore some properties of the MultilayerGraph struct. ","category":"page"},{"location":"#Layers","page":"Home","title":"Layers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is an OrderedDict where the keys are the layers' indexes within the multilayer graph and the values are the actual Layers","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayergraph.layers","category":"page"},{"location":"","page":"Home","title":"Home","text":"OrderedDict{Tuple{Int64, Int64}, Layer{Int64, U, G} where {U<:Real, G<:AbstractGraph{Int64}}} with 3 entries:\n  (1, 1) => Layer{Int64, Float64, SimpleGraph{Int64}}(:layer_1, SimpleGraph{Int64}(5, [[2, 4], [1, 3, 4], [2], [1, 2, 5], [4]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}}[])\n  (2, 2) => Layer{Int64, Float64, SimpleWeightedGraph{Int64, Float64}}(:layer_2, {5, 4} undirected simple Int64 graph with Float64 weights, MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}}[])\n  (3, 3) => Layer{Int64, Float64, SimpleWeightedGraph{Int64, Float64}}(:layer_3, {5, 4} undirected simple Int64 graph with Float64 weights, MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}}[])","category":"page"},{"location":"#Interlayers","page":"Home","title":"Interlayers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is an OrderedDict where each key is the pair of indexes of the layers that the corresponding value, i.e. the interlayer, connects within the multilayer graph","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayergraph.interlayers","category":"page"},{"location":"","page":"Home","title":"Home","text":"OrderedDict{Tuple{Int64, Int64}, Interlayer{Int64, U, G} where {U<:Real, G<:AbstractGraph{Int64}}} with 6 entries:\n  (2, 1) => Interlayer{Int64, Float64, SimpleGraph{Int64}}(:interlayer_layer_2_layer_1, :layer_2, :layer_1, SimpleGraph{Int64}(9, [[7, 8, 9, 10], [9], [7], [7], [6, 9], [5], [1, 3, 4], [1], [1, 2, 5], [1]]), MultilayerVertex{Int64}[], Tuple{MultilayerVerte…  \n  (1, 2) => Interlayer{Int64, Float64, SimpleGraph{Int64}}(:interlayer_layer_1_layer_2, :layer_1, :layer_2, SimpleGraph{Int64}(9, [[10], [6, 8, 9], [6], [6, 7, 10], [6], [2, 3, 4, 5], [4], [2], [2], [1, 4]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64},…  \n  (3, 1) => Interlayer{Int64, Float64, SimpleWeightedGraph{Int64, Float64}}(:interlayer_layer_3_layer_1, :layer_3, :layer_1, {10, 7} undirected simple Int64 graph with Float64 weights, MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVer…  \n  (1, 3) => Interlayer{Int64, Float64, SimpleWeightedGraph{Int64, Float64}}(:interlayer_layer_1_layer_3, :layer_1, :layer_3, {10, 4} undirected simple Int64 graph with Float64 weights, MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}…  \n  (3, 2) => Interlayer{Int64, Float64, SimpleGraph{Int64}}(:interlayer_layer_3_layer_2, :layer_3, :layer_2, SimpleGraph{Int64}(5, [[6], [7], [8], [9], [10], [1], [2], [3], [4], [5]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVert…  \n  (2, 3) => Interlayer{Int64, Float64, SimpleGraph{Int64}}(:interlayer_layer_2_layer_3, :layer_2, :layer_3, SimpleGraph{Int64}(5, [[6], [7], [8], [9], [10], [1], [2], [3], [4], [5]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVert…","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the (1,2) interlayer (i.e. the interlayer between layer (1,1) and layer (2,2)) is very similar to interlayer (2,1), but not identical: its adjacency matrix rows and columns are reordered. One may get interlayer (2,1) from interlayer (1,2) (i.e. one may get the symmetric interlayer of (1,2)) as follows","category":"page"},{"location":"","page":"Home","title":"Home","text":"symmetric_interlayer = get_symmetric_interlayer(multilayergraph.interlayers[(1,2)])\nsymmetric_interlayer == multilayergraph.interlayers[(2,1)] ","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"","page":"Home","title":"Home","text":"You may access individual layers and interlayers with the \"dot\" notation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayergraph.layer_1","category":"page"},{"location":"","page":"Home","title":"Home","text":"Layer{Int64, Float64, SimpleGraph{Int64}}(:layer_1, SimpleGraph{Int64}(7, [[2, 3, 4, 5], [1, 4], [1, 5], [1, 2, 5], [1, 3, 4]]), MultilayerVertex{Int64}[], Tuple{MultilayerVertex{Int64}, MultilayerVertex{Int64}}[])","category":"page"},{"location":"#Adjacency-Tensor","page":"Home","title":"Adjacency Tensor","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The adjacency tensor is a 4-dimensional array","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayergraph.adjacency_tensor","category":"page"},{"location":"","page":"Home","title":"Home","text":"5×5×3×3 Array{Float64, 4}:\n...","category":"page"},{"location":"","page":"Home","title":"Home","text":"The adjacency tensor is a 4-dimensional array. To understand its indexing, consider the following example","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayergraph.adjacency_tensor[1,5,2,3]","category":"page"},{"location":"","page":"Home","title":"Home","text":"0.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"This means that there is an edge of zero weight between the vertex representing node 1 in layer 5 and the vertex representing node 2 in layer 3. It is a good time to note the difference between nodes and vertices. In the context of multilayer graphs, the vertices of every layer and interlayer represent the same set of nodes. That is, vertex 1 in layer (1,1) represents the same node as vertex 1 in layer (2,2) and so on. To make this distinction clearer the package implements the MultilayerVertex type, that represents vertices within the multilayer graph. The implementation of MultilayerVertex is","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct MultilayerVertex{T <: Integer} <: AbstractMultilayerVertex{T}\n    node::T        # The node  the vertex represents\n    layer::Symbol  # The layer the vertex belongs to\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"To get the vertices of a Layer or an Interlayer, one may use Graphs.jl APIs","category":"page"},{"location":"","page":"Home","title":"Home","text":"vertices(multilayergraph.layers[(1,1)])","category":"page"},{"location":"","page":"Home","title":"Home","text":"5-element Vector{MultilayerVertex{Int64}}:\n MultilayerVertex{Int64}(1, :layer_1)\n MultilayerVertex{Int64}(2, :layer_1)\n MultilayerVertex{Int64}(3, :layer_1)\n MultilayerVertex{Int64}(4, :layer_1)\n MultilayerVertex{Int64}(5, :layer_1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"vertices(multilayergraph.interlayers[(1,2)])","category":"page"},{"location":"","page":"Home","title":"Home","text":"10-element Vector{Any}:\n MultilayerVertex{Int64}(1, :layer_1)\n MultilayerVertex{Int64}(2, :layer_1)\n MultilayerVertex{Int64}(3, :layer_1)\n MultilayerVertex{Int64}(4, :layer_1)\n MultilayerVertex{Int64}(5, :layer_1)\n MultilayerVertex{Int64}(1, :layer_2)\n MultilayerVertex{Int64}(2, :layer_2)\n MultilayerVertex{Int64}(3, :layer_2)\n MultilayerVertex{Int64}(4, :layer_2)\n MultilayerVertex{Int64}(5, :layer_2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To get a specific layer of a multilayer graph from its name, one may also write","category":"page"},{"location":"","page":"Home","title":"Home","text":"layer_1 = get_layer(multilayergraph, :layer_1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Same for interlayers","category":"page"},{"location":"","page":"Home","title":"Home","text":"interlayer_2_1 = get_layer(multilayergraph, :interlayer_layer_2_layer_1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Both MultilayerGraph and MultilayerDiGraph fully extend Graphs.jl, so they have access to Graphs.jl API as one would expect, just keeping in mind that vertices are MultilayerVertexs and not subtypes of Integer (MultilayerVertex is actually a subtype of AbstractVertex that this package defines, see Future Developments), and that edges are MultilayerEdges, which actually subtypes AbstractEdge.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some notable examples are","category":"page"},{"location":"","page":"Home","title":"Home","text":"edges(multilayergraph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"34-element Vector{MultilayerEdge}:\n MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(1, :layer_1), MultilayerVertex{Int64}(2, :layer_1), 1)\n MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(1, :layer_1), MultilayerVertex{Int64}(3, :layer_1), 1)\n MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(1, :layer_1), MultilayerVertex{Int64}(4, :layer_1), 1)\n MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(1, :layer_1), MultilayerVertex{Int64}(5, :layer_1), 1)\n MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(2, :layer_1), MultilayerVertex{Int64}(3, :layer_1), 1)\n MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(2, :layer_1), MultilayerVertex{Int64}(5, :layer_1), 1)\n MultilayerEdge{MultilayerVertex{Int64}, Int64}(MultilayerVertex{Int64}(3, :layer_1), MultilayerVertex{Int64}(5, :layer_1), 1)\n MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(1, :layer_2), MultilayerVertex{Int64}(1, :layer_2), 0.7188425521261754)\n MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(2, :layer_2), MultilayerVertex{Int64}(3, :layer_2), 0.9012061650463197) \n MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(2, :layer_2), MultilayerVertex{Int64}(4, :layer_2), 0.6163304419976594) \n MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(3, :layer_2), MultilayerVertex{Int64}(5, :layer_2), 1.0046265072746847) \n MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(1, :layer_3), MultilayerVertex{Int64}(2, :layer_3), 0.2819477742859873) \n MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(2, :layer_3), MultilayerVertex{Int64}(4, :layer_3), 0.40111133874926597)\n MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(3, :layer_3), MultilayerVertex{Int64}(4, :layer_3), 0.9498077050078636) \n MultilayerEdge{MultilayerVertex{Int64}, Float64}(MultilayerVertex{Int64}(1, :layer_3), MultilayerVertex{Int64}(5, :layer_3), 0.9618455695308973) \n ⋮","category":"page"},{"location":"","page":"Home","title":"Home","text":"The implementation of MultilayerEdge is","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct MultilayerEdge{ T <: MultilayerVertex, U <: Union{ <: Real, Nothing}} <: AbstractMultilayerEdge{T} # AbstractMultilayerEdge{T} subtypes AbstractEdge \n    src::T    # The source vertex\n    dst::T    # The destination vertex\n    weight::U # The edge weight. Can be `nothing` to signify an unweighted edge, or a Real\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"#### Other Example APIs","category":"page"},{"location":"","page":"Home","title":"Home","text":"##### Get the node type","category":"page"},{"location":"","page":"Home","title":"Home","text":"eltype(multilayergraph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Int64","category":"page"},{"location":"#Get-the-edge-type","page":"Home","title":"Get the edge type","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"edgetype(multilayergraph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultilayerEdge{MultilayerVertex{Int64}, Float64}","category":"page"},{"location":"#Check-whether-an-edge-exists","page":"Home","title":"Check whether an edge exists","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"has_edge(multilayergraph, MultilayerVertex(1, :layer_1), MultilayerVertex(4, :layer_2))","category":"page"},{"location":"","page":"Home","title":"Home","text":"false","category":"page"},{"location":"","page":"Home","title":"Home","text":"##### Remove an edge","category":"page"},{"location":"","page":"Home","title":"Home","text":"rem_edge! mimics the behaviour of the analogous function in Graphs.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"rem_edge!(multilayergraph, MultilayerVertex(1, :layer_1), MultilayerVertex(2, :layer_2))","category":"page"},{"location":"","page":"Home","title":"Home","text":"The multilayer doesn't have any edge between MultilayerVertex{Int64}(1, :layer_1) and MultilayerVertex{Int64}(2, :layer_2)\nfalse","category":"page"},{"location":"","page":"Home","title":"Home","text":"The message tells us that the edge was already non existent. In fact, if we check the adjacency_tensor in the corresponding entry, we see that","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayergraph.adjacency_tensor[1,2,1,2]","category":"page"},{"location":"","page":"Home","title":"Home","text":"0.0","category":"page"},{"location":"#Add-an-edge","page":"Home","title":"Add an edge","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We may add an edge using the add_edge! function. Since the interlayer we are adding the edge has an unweighted underlying graph (we will say that the interlayer is unweighted), we have to add an unweighted edge, so we don't specify many weights after the vertices. The adjacency tensor will be updated with a one(U) in the correct position. add_edge! mimics the behaviour of the analogous function in Graphs.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(multilayergraph, MultilayerVertex(1, :layer_1), MultilayerVertex(2, :layer_2))","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"","page":"Home","title":"Home","text":"To add a weighted edge we just need to write","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(multilayergraph,  MultilayerEdge(MultilayerVertex(1, :layer_1), MultilayerVertex(2, :layer_3), 3.14))","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"#Get-the-inneighbors","page":"Home","title":"Get the inneighbors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To get all the inneighbors of a vertex we just need to write ","category":"page"},{"location":"","page":"Home","title":"Home","text":"inneighbors(multilayergraph, MultilayerVertex(1, :layer_1))","category":"page"},{"location":"","page":"Home","title":"Home","text":"8-element Vector{MultilayerVertex{Int64}}:\n MultilayerVertex{Int64}(2, :layer_1)\n MultilayerVertex{Int64}(3, :layer_1)\n MultilayerVertex{Int64}(4, :layer_1)\n MultilayerVertex{Int64}(5, :layer_1)\n MultilayerVertex{Int64}(1, :layer_3)\n MultilayerVertex{Int64}(2, :layer_3)\n MultilayerVertex{Int64}(4, :layer_3)\n MultilayerVertex{Int64}(5, :layer_3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"outneighbors would be analogous.","category":"page"},{"location":"","page":"Home","title":"Home","text":"##### Get the global clustering coefficient","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayer_global_clustering_coefficient(multilayergraph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"0.12667622867320932","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since our implementation of the global clustering coefficient follows De Domenico et al. (2013) rather than Graphs.jl's implementation, we did not override Graphs.jl's global_clustering_coefficient, which works on MultilayerGraph and MultilayerDiGraph but yields different results. For details, consult ?multilayer_global_clustering_coefficient or read the comments in the source code.","category":"page"},{"location":"#Multilayer-Specific-Functions-and-Analysis","page":"Home","title":"Multilayer-Specific Functions and Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following functions are specific to multilayer graphs or their implementations radically differ from their monoplex counterparts. For more information on every function, please refer to De Domenico et al. (2013) or consult the associated docstrings.","category":"page"},{"location":"#Overlay-Monoplex-Graph","page":"Home","title":"Overlay Monoplex Graph","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Get the overlay monoplex graph: the monoplex graph whose nodes are the nodes of the multilayer graph and the edge between node i and node j has weight equal to the sum of all the weights of the edges between all vertex representations of i and j that belong to the same layer, for all the layers in the multilayer","category":"page"},{"location":"","page":"Home","title":"Home","text":"get_overlay_monoplex_graph(multilayergraph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"{5, 8} undirected simple Int64 graph with Float64 weights","category":"page"},{"location":"#Depth-Weighted-Clustering-Coefficient","page":"Home","title":"Depth-Weighted Clustering Coefficient","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Get the global clustering coefficient where triplets are weighted by how many layers they span","category":"page"},{"location":"","page":"Home","title":"Home","text":"w =  [1/3, 1/3, 1/3] \nmultilayer_weighted_global_clustering_coefficient(multilayergraph,w)","category":"page"},{"location":"","page":"Home","title":"Home","text":"0.12667622867320916","category":"page"},{"location":"","page":"Home","title":"Home","text":"The first component of w is the weight associated to triplets that are contained in one layer, the second component to triplets whose vertices are spread across exactly two layers, the third to triplets whose vertices are spread across exactly three layers. Weights must sum to `1.0 . When they are all equal (like in this example), the weighted global clustering coefficient coincides with the global clustering coefficient. ","category":"page"},{"location":"#Eigenvector-Centrality","page":"Home","title":"Eigenvector Centrality","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Calculated via an iterative algorithm, its normalization is different from the Graphs.jl implementation. See ?eigenvector_centrality for further details and context.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# The returned values are: the eigenvector centrality and the relative error at each iteration, that is, the summed absolute values of the componentwise differences between the centrality computed at the current iteration minus the centrality computed at the previous iteration.\neig_centrality, errs = eigenvector_centrality(multilayergraph; norm = \"n\", tol = 1e-3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"([0.260450377858897 0.02358226618172732 0.08408641909534659; 0.6517125919818912 0.646849109975291 0.25212976452498587; … ; 0.21160486454350666 0.24850764907380082 0.2809259415084613; 0.5089709123112656 0.27775286552140954 0.22663014660085468], [10.000000000000004, 0.7095737447337795, 0.329314405320397, 0.16256401870083886, 0.07860800793625616, 0.04125218689190476, 0.021191358681432643, 0.011056758224944913, 0.006831972142635288, 0.0035133270128280235, 0.0024675719418019056, 0.0013403531942171656, 0.0009739276503972424])","category":"page"},{"location":"#Modularity","page":"Home","title":"Modularity","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Compute the modularity of the multilayer graph. The signature mimics the Graphs.jl modularity implementation","category":"page"},{"location":"","page":"Home","title":"Home","text":"modularity(multilayergraph,\n          rand([1, 2, 3, 4], length(nodes(multilayergraph)),length(multilayergraph.layers)) # communities\n          )","category":"page"},{"location":"","page":"Home","title":"Home","text":"-0.039890139283044884","category":"page"},{"location":"#Von-Neumann-Entropy","page":"Home","title":"Von Neumann Entropy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Compute the Von Neumann entropy as presented in De Domenico et al. (2013).","category":"page"},{"location":"","page":"Home","title":"Home","text":"von_neumann_entropy(multilayergraph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"3.3980014398404834","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Von Neumann entropy is currently available only for undirected multilayer graphs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Other extended functions are: is_directed, has_vertex, ne, nv, outneighbors, indegree, outdegree, degree, mean_degree, degree_second_moment, degree_variance, nn, nodes.","category":"page"},{"location":"#How-to-Contribute","page":"Home","title":"How to Contribute","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you wish to change or add some functionality, please file an issue. ","category":"page"},{"location":"#How-to-Cite","page":"Home","title":"How to Cite","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use this package in your work, please cite this repository using the metadata in CITATION.bib.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"De Domenico et al. (2013) Mathematical Formulation of Multilayer Networks. Physical Review X","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [MultilayerGraphs]","category":"page"}]
}
