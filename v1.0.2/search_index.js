var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MultilayerGraphs","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div style=\"width:100%; height:150px;border-width:4px;border-style:solid;padding-top:25px;\n        border-color:#000;border-radius:10px;text-align:center;background-color:#B3D8FF;\n        color:#000\">\n    <h3 style=\"color: black;\">Star us on GitHub!</h3>\n    <a class=\"github-button\" href=\"https://github.com/JuliaGraphs/MultilayerGraphs.jl\" data-icon=\"octicon-star\" data-size=\"large\" data-show-count=\"true\" aria-label=\"Star JuliaGraphs/MultilayerGraphs.jl on GitHub\" style=\"margin:auto\">Star</a>\n    <script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n</div>","category":"page"},{"location":"#MultilayerGraphs.jl","page":"Home","title":"MultilayerGraphs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraphs.jl is a Julia package for the creation, manipulation and analysis of the structure, dynamics and functions of multilayer graphs extending Graphs.jl.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraphs.jl provides an implementation of the mathematical formulation of multilayer graphs as proposed by De Domenico et al. (2013) and incorporates insights from Kivelä et al. (2014) and Bianconi (2018). The package focuses on two custom types, MultilayerGraph and MultilayerDiGraph, which represent undirected and directed multilayer graphs, respectively.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A multilayer graph is composed of layers, i.e. graphs whose vertices represent the same set of nodes (not all nodes need to be represented in every layer), and interlayers, i.e. the bipartite graphs that connect vertices in two different layers. Vertices in a multilayer graph are represented using the MultilayerVertex struct, while nodes are represented using the Node struct.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraph and MultilayerDiGraph are fully-fledged Graphs.jl extensions. Both structs are designed to allow for layers and interlayers of any type (as long as they are Graphs.jl extensions themselves) and to permit layers and interlayers of different types. However, it is required that all layers and interlayers in MultilayerGraph are undirected, and all layers and interlayers in MultilayerDiGraph are directed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultilayerGraph and MultilayerDiGraph support the specification of vertex and edge metadata, provided that the underlying layer or interlayer also supports metadata.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation is organized as follows: you will find a comprehensive Tutorial below, complemented by an API page. The API page is organized in two sections: the End-User section lists all the methods intended for the user who does not need to write code that is also compatible with other libraries in the Graphs.jl's ecosystem, while the Developer section contains methods that allow MultilayerGraphs.jl to be used as any package that extend Graphs.jl . Bot section are further stratified by topic. The tutorial below will be focused on the end-used experience, as developer methods often have very similar signature and will be better addressed in a future developer-oriented guide, should the community manifest the need of it.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Press ] in the Julia REPL and then","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MultilayerGraphs","category":"page"},{"location":"#Tutorial","page":"Home","title":"Tutorial","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here we illustrate how to define, handle and analyse a MultilayerGraph (the directed version is completely analogous).","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Revise\nusing StatsBase, Distributions\nusing Graphs, SimpleWeightedGraphs, MetaGraphs, SimpleValueGraphs\nusing MultilayerGraphs","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define some constants that will prove useful later in the tutorial:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Set the minimum and maximum number of all_nodes and edges for random graphs\nconst vertextype   = Int64\nconst _weighttype  = Float64\nconst min_vertices = 5\nconst max_vertices = 7\nconst min_edges    = 1\nconst max_edges    = max_vertices*(max_vertices-1)\nconst n_nodes      = max_vertices","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next we define nodes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# The constructor for nodes (which are immutable) only requires a name (`id`) for the node\nconst all_nodes = [Node(\"node_$i\") for i in 1:n_nodes]","category":"page"},{"location":"","page":"Home","title":"Home","text":"7-element Vector{Node}:\n Node(\"node_1\")\n Node(\"node_2\")\n Node(\"node_3\")\n Node(\"node_4\")\n Node(\"node_5\")\n Node(\"node_6\")\n Node(\"node_7\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"You may access (but not modify) the id of a Node via the id function. And construct MultilayerVertexs from these nodes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"## Convert nodes to multilayer vertices without metadata\nconst multilayervertices = MV.(all_nodes)\n## Convert nodes multilayer vertices with metadata\nconst multilayervertices_meta  = [MV(node, (\"I'm node $(node.id)\",)) for node in all_nodes]","category":"page"},{"location":"","page":"Home","title":"Home","text":"7-element Vector{MultilayerVertex{nothing}}:\n MV(Node(\"node_1\"), :nothing, (\"I'm node node_1\",))\n MV(Node(\"node_2\"), :nothing, (\"I'm node node_2\",))\n MV(Node(\"node_3\"), :nothing, (\"I'm node node_3\",))\n MV(Node(\"node_4\"), :nothing, (\"I'm node node_4\",))\n MV(Node(\"node_5\"), :nothing, (\"I'm node node_5\",))\n MV(Node(\"node_6\"), :nothing, (\"I'm node node_6\",))\n MV(Node(\"node_7\"), :nothing, (\"I'm node node_7\",))","category":"page"},{"location":"","page":"Home","title":"Home","text":"This conversion from Nodes to MultilayerVertexs is performed since it is logical to add vertices to a graph, not nodes, and also for consistency reasons with the ecosystem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Printing a MultilayerVertex returns:","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayervertices_meta[1]","category":"page"},{"location":"","page":"Home","title":"Home","text":"MV(Node(\"node_1\"), :nothing, (\"I'm node node_1\",))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Where MV is an alias for MultilayerVertex. The first field is the Node being represented (accessible via the node function), the second the (name of) the layer the vertex is represented in (accessible via the layer function, here it is set to nothing, since these vertices are yet to be assigned), and the metadata associated to the vertex (accessible via the metadata function, no metadata are currently represented via an empty NamedTuple). MultilayerVertex metadata can be represented via a Tuple or a NamedTuple (see below for examples). For a complete list of methods applicable to MultilayerVertices, plese refer to the Vertices of the API.","category":"page"},{"location":"#Layers","page":"Home","title":"Layers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As said before, to define a multilayer graph we need to specify its layers and interlayers. Layers and the individual graphs that make up multilayer graphs. We proceed by constructing a Layer using the constructor that randomly specifies the edges:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Layer(\n    name::Symbol,                                                 # The name of the layer\n    vertices::Vector{ <: MultilayerVertex},                       # The `MultilayerVertex`s of the Layer\n    ne::Int64,                                                    # The number of edges of the Layer\n    null_graph::G,                                                # The Layer's underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.\n    weighttype::Type{U};                                          # The type of the `MultilayerEdge` weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the `MultilayerGraph`s will always be weighted)\n    default_vertex_metadata::Function = mv -> NamedTuple(),       # Function that takes a `MultilayerVertex` and returns a `Tuple` or a `NamedTuple` containing the vertex metadata. defaults to `mv -> NamedTuple()`;\n    default_edge_weight::Function = (src, dst) -> nothing,        #  Function that takes a pair of `MultilayerVertex`s and returns an edge weight of type `weighttype` or `nothing` (which is compatible with unweighted underlying graphs and corresponds to `one(weighttype)` for weighted underlying graphs). Defaults to `(src, dst) -> nothing`;\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(), # Function that takes a pair of `MultilayerVertex`s and  returns a `Tuple` or a `NamedTuple` containing the edge metadata, that will be called when `add_edge!(mg,src,dst, args...; kwargs...)` is called without the `metadata` keyword argument, and when generating the edges in this constructor. Defaults to  `(src, dst) -> NamedTuple()`;\n    allow_self_loops::Bool = false                                # whether to allow self loops to be generated or not. Defaults to `false`.\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Layer is considered \"weighted\" if its underlying graph (null_graph argument) has been given the IsWeighted trait (traits throughout this package are implemented via SimpleTraits.jl, just like Graphs.jl does). Since one may at any moment add a new weighted Layer to a MultilayerGraph (see below for details), the latter is always considered a \"weighted graph\", so it is given the IsWeighted trait. Thus, all Layers and Interlayers (collectively named \"subgraphs\" hereafter) must specify their weighttype as the last argument of their constructor, so the user may debug their weight matrices (weights(subgraph::AbstractSubGraph)) immediately after construction. As better specified below, all subgraphs that are meant to be part of the same MultilayerGraph must have the same weighttype.   ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Before instantiating Layers, we define an utility function to ease randomization:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Utility function that returns a random number of vertices and edges each time it is called:\nfunction rand_nv_ne_layer(min_vertices, max_vertices)\n    _nv = rand(min_vertices:max_vertices)\n    _ne = rand(1:(_nv*(_nv-1)) ÷ 2 )\n    return (_nv,_ne)\nend\n\n# Utility function that returns two vertices of a Layer that are not adjacent.\nfunction _get_srcmv_dstmv_layer(layer::Layer)\n\n    mvs = get_bare_mv.(collect(mv_vertices(layer)))\n\n    src_mv = nothing    \n    _collection = []\n\n    while isempty(_collection)\n        src_mv = rand(mvs)\n        _collection = setdiff(Set(mvs), Set(vcat(get_bare_mv.(mv_outneighbors(layer, src_mv)), src_mv ) ) )  \n    end\n\n    dst_mv = get_bare_mv(rand(_collection))\n\n    return mvs, src_mv, dst_mv\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"We are now are ready to define some Layers. Every type of graph from the Graphs.jl ecosystem may underlie a Layer (or an Interlayer). We will construct a few of them, each time with a different number of vertices and edges.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# An unweighted simple layer:\n_nv, _ne  = rand_nv_ne_layer(min_vertices,max_vertices)\nlayer_sg = Layer(   :layer_sg,\n                    sample(multilayervertices, _nv, replace = false),\n                    _ne,\n                    SimpleGraph{vertextype}(),\n                    _weighttype\n)\n\n# A weighted `Layer`\n_nv, _ne  = rand_nv_ne_layer(min_vertices,max_vertices)\nlayer_swg = Layer(  :layer_swg,\n                    sample(multilayervertices, _nv, replace = false),\n                    _ne,\n                    SimpleWeightedGraph{vertextype, _weighttype}(),\n                    _weighttype;\n                    default_edge_weight = (src,dst) -> rand()\n)\n# A `Layer` with an underlying `MetaGraph`:\n_nv, _ne = rand_nv_ne_layer(min_vertices,max_vertices)\nlayer_mg = Layer(   :layer_mg,\n                    sample(multilayervertices_meta, _nv, replace = false),\n                    _ne,\n                    MetaGraph{vertextype, _weighttype}(),\n                    _weighttype;\n                    default_edge_metadata = (src,dst) -> (from_to = \"from_$(src)_to_$(dst)\",)\n)\n# `Layer` with an underlying `ValGraph` from `SimpleValueGraphs.jl`\n_nv, _ne = rand_nv_ne_layer(min_vertices,max_vertices)\nlayer_vg = Layer(   :layer_vg,\n                    sample(multilayervertices_meta, _nv, replace = false),\n                    _ne,\n                    MultilayerGraphs.ValGraph{vertextype}(;edgeval_types=(Float64, String, ),\n                                            edgeval_init=(s, d) -> (s+d, \"hi\"),\n                                            vertexval_types=(String,),\n                                            vertexval_init=v -> (\"$v\",),),\n                    _weighttype;\n                    default_edge_metadata = (src,dst) -> (rand(), \"from_$(src)_to_$(dst)\",),\n                    default_vertex_metadata = mv -> (\"This metadata had been generated via the default_vertex_metadata method\",)\n)\n\n# Collect all layers in an ordered list. Order will be recorded when instantiating the multilayer graph.\nlayers = [layer_sg, layer_swg, layer_mg, layer_vg]","category":"page"},{"location":"","page":"Home","title":"Home","text":"The API that inspects and modifies Layers will be shown below together with that of Interlayers, since they are usually the same.  There are of course other constructors that you may discover by typing ?Layer in the console.","category":"page"},{"location":"#Interlayers","page":"Home","title":"Interlayers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Now we turn to defining Interlayers. Interlayers are the graphs containing all the edges between vertices is two distinct layers. As before, we need an utility to ease randomization:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Utilities for Interlayer\n## Utility function that returns two vertices of an Interlayer that are not adjacent.\nfunction _get_srcmv_dstmv_interlayer(interlayer::Interlayer)\n\n    mvs = get_bare_mv.(collect(mv_vertices(interlayer)))\n\n    src_mv = nothing    \n    _collection = []\n\n    while isempty(_collection)\n        src_mv = rand(mvs)\n        _collection = setdiff(Set(mvs), Set(vcat(get_bare_mv.(mv_outneighbors(interlayer, src_mv)), src_mv, get_bare_mv.(mv_vertices( eval(src_mv.layer) ))) ) )  \n    end\n\n    dst_mv = get_bare_mv(rand(_collection))\n\n    return mvs, src_mv, dst_mv\nend\n\n## Utility function that returns a random number edges between its arguments `layer_1` and `layer_2`:\nfunction rand_ne_interlayer(layer_1, layer_2)\n    _nv = nv(layer_1) + nv(layer_2)\n    _ne = rand(_nv:(_nv*(_nv-1)) ÷ 2 )\n    return _ne\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"An Interlayer is constructed by passing its name, the two Layers it should connect, and the other parameters just like the Layer's constructor. The random constructor reads:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Interlayer(\n    layer_1::Layer{T,U},                                                 # One of the two layers connected by the Interlayer\n    layer_2::Layer{T,U},                                                 # One of the two layers connected by the Interlayer  \n    ne::Int64,                                                           # The number of edges of the Interlayer\n    null_graph::G;                                                       # the Interlayer's underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.\n    default_edge_weight::Function = (x,y) -> nothing,                    # Function that takes a pair of `MultilayerVertex`s and returns an edge weight of type `weighttype` or `nothing` (which is compatible with unweighted underlying graphs and corresponds to `one(weighttype)` for weighted underlying graphs). Defaults to `(src, dst) -> nothing`;\n    default_edge_metadata::Function = (x,y) -> NamedTuple(),             # Function that takes a pair of `MultilayerVertex`s and  returns a `Tuple` or a `NamedTuple` containing the edge metadata, that will be called when `add_edge!(mg,src,dst, args...; kwargs...)` is called without the `metadata` keyword argument, and when generating the edges in this constructor. Defaults to  `(src, dst) -> NamedTuple()`;\n    name::Symbol = Symbol(\"interlayer_$(layer_1.name)_$(layer_2.name)\"), # The name of the Interlayer. Defaults to Symbol(\"interlayer_(layer_1.name)_(layer_2.name)\");\n    transfer_vertex_metadata::Bool = false                               # if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don't support metadata or that pose limitations to it may result in errors.;\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We will build a few of random Interlayers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Define the random undirected simple Interlayer\n_ne = rand_ne_interlayer(layer_sg, layer_swg)\ninterlayer_sg_swg = Interlayer( layer_sg,                  # The first layer to be connected\n                                layer_swg,                 # The second layer to be connected\n                                _ne,                       # The number of edges to randomly generate\n                                SimpleGraph{vertextype}(), # The underlying graph, passed as a null graph\n                                name = :random_interlayer  # The name of the interlayer. We will be able to access it as a property of the multilayer graph via its name. This kwarg's default value is given by a combination of the two layers' names.\n)\n# Define a weighted `Interlayer`\n_ne = rand_ne_interlayer(layer_swg, layer_mg)\ninterlayer_swg_mg = Interlayer( layer_swg,\n                                layer_mg,\n                                _ne,\n                                SimpleWeightedGraph{vertextype, _weighttype}();\n                                default_edge_weight = (x,y) -> rand() # Arguments follow the same rules as in Layer\n)\n# Define an `Interlayer` with an underlying `MetaGraph`\n_ne = rand_ne_interlayer(layer_mg, layer_vg)\ninterlayer_mg_vg = Interlayer(  layer_mg,\n                                layer_vg,\n                                _ne,\n                                MetaGraph{vertextype, _weighttype}();\n                                default_edge_metadata = (x,y) -> (mymetadata = rand(),),\n                                transfer_vertex_metadata = true # This boolean kwarg controls whether vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don't support metadata or that pose limitations to it may result in errors.\n)\n# Define an `Interlayer` with an underlying `ValGraph` from `SimpleValueGraphs.jl`, with diagonal couplings only:\ninterlayer_multiplex_sg_mg = multiplex_interlayer(  layer_sg,\n                                                    layer_mg,\n                                                    ValGraph{vertextype}(; edgeval_types=(from_to = String,), edgeval_init=(s, d) -> (from_to = \"from_$(s)_to_$(d)\"));\n                                                    default_edge_metadata = (x,y) -> (from_to = \"from_$(src)_to_$(dst)\",)\n)\n# Finally, An `Interlayer` with no couplings (an \"empty\" interlayer):\ninterlayer_empty_sg_vg = empty_interlayer(  layer_sg,\n                                            layer_vg,\n                                            SimpleGraph{vertextype}()\n)\n\n# Collect all interlayers. Even though the list is ordered, order will not matter when instantiating the multilayer graph.\ninterlayers = [interlayer_sg_swg, interlayer_swg_mg, interlayer_mg_vg, interlayer_multiplex_sg_mg, interlayer_empty_sg_vg]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next, we explore the API associated to modify and analyze Layers and Interlayers.","category":"page"},{"location":"#Subgraphs-API","page":"Home","title":"Subgraphs API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"API for  Layers and Interlayers (collectively, \"subgraphs\") are very similar, so we will just show them for the Layer case, pointing out differences to the Interlayer scenario whenever they occur.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Subgraphs extend the Graphs.jl's interface, so one may expect every method from Graphs.jl to apply. Anyway, the output and signature is slightly different and thus worth pointing out below.","category":"page"},{"location":"#[Nodes](@ref-nodes_tut_subg)","page":"Home","title":"Nodes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"One may retrieve the Nodes that a Layer represents via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"layer_sg_nodes = nodes(layer_sg)","category":"page"},{"location":"","page":"Home","title":"Home","text":"6-element Vector{Node}:\n Node(\"node_2\")\n Node(\"node_3\")\n Node(\"node_4\")\n Node(\"node_6\")\n Node(\"node_5\")\n Node(\"node_7\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The same would be for Interlayers. In this case, the union of the set of nodes represented by the two layers the interlayer connects is returned:","category":"page"},{"location":"","page":"Home","title":"Home","text":"interlayer_sg_swg_nodes  = nodes(interlayer_sg_swg)","category":"page"},{"location":"","page":"Home","title":"Home","text":"7-element Vector{Node}:\n Node(\"node_2\")\n Node(\"node_3\")\n Node(\"node_4\")\n Node(\"node_6\")\n Node(\"node_5\")\n Node(\"node_7\")\n Node(\"node_1\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"One may check for the existence of a node within a layer (or interlayer) via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"has_node(layer_sg, layer_sg_nodes[1])","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"#[Vertices](@ref-vertices_tut_subg)","page":"Home","title":"Vertices","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"One may retrieve the MultilayerVertexs of a layer by calling:","category":"page"},{"location":"","page":"Home","title":"Home","text":"layer_sg_vertices = mv_vertices(layer_sg)","category":"page"},{"location":"","page":"Home","title":"Home","text":"6-element Vector{MultilayerVertex{:layer_sg}}:\n MV(Node(\"node_2\"), :layer_sg, NamedTuple())\n MV(Node(\"node_3\"), :layer_sg, NamedTuple())\n MV(Node(\"node_4\"), :layer_sg, NamedTuple())\n MV(Node(\"node_6\"), :layer_sg, NamedTuple())\n MV(Node(\"node_5\"), :layer_sg, NamedTuple())\n MV(Node(\"node_7\"), :layer_sg, NamedTuple())","category":"page"},{"location":"","page":"Home","title":"Home","text":"While vertices with metadata would look like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mv_vertices(layer_mg)","category":"page"},{"location":"","page":"Home","title":"Home","text":"6-element Vector{MultilayerVertex{:layer_mg}}:\n MV(Node(\"node_7\"), :layer_mg, (var\"1\" = \"I'm node node_7\",))\n MV(Node(\"node_6\"), :layer_mg, (var\"1\" = \"I'm node node_6\",))\n MV(Node(\"node_2\"), :layer_mg, (var\"1\" = \"I'm node node_2\",))\n MV(Node(\"node_4\"), :layer_mg, (var\"1\" = \"I'm node node_4\",))\n MV(Node(\"node_1\"), :layer_mg, (var\"1\" = \"I'm node node_1\",))\n MV(Node(\"node_5\"), :layer_mg, (var\"1\" = \"I'm node node_5\",))","category":"page"},{"location":"","page":"Home","title":"Home","text":"The vertices of an interlayer are the union of the sets of vertices of the two layers it connects:","category":"page"},{"location":"","page":"Home","title":"Home","text":"interlayer_sg_swg_vertices = mv_vertices(interlayer_sg_swg)","category":"page"},{"location":"","page":"Home","title":"Home","text":"11-element Vector{MultilayerVertex}:\n MV(Node(\"node_2\"), :layer_sg, NamedTuple())\n MV(Node(\"node_3\"), :layer_sg, NamedTuple())\n MV(Node(\"node_4\"), :layer_sg, NamedTuple())\n MV(Node(\"node_6\"), :layer_sg, NamedTuple())\n MV(Node(\"node_5\"), :layer_sg, NamedTuple())\n MV(Node(\"node_7\"), :layer_sg, NamedTuple())\n MV(Node(\"node_1\"), :layer_swg, NamedTuple())\n MV(Node(\"node_4\"), :layer_swg, NamedTuple())\n MV(Node(\"node_5\"), :layer_swg, NamedTuple())\n MV(Node(\"node_2\"), :layer_swg, NamedTuple())\n MV(Node(\"node_3\"), :layer_swg, NamedTuple())","category":"page"},{"location":"","page":"Home","title":"Home","text":"The vertices(subgraph::AbstractSubGraph) command would return an internal representation of the MultilayerVertexs. This method, together with others, serves to make MultilayerGraphs.jl compatible with the Graphs.jl ecosystem, but it is not meant to be called by the end user. It is, anyway, thought to be used by developers who wish to interface their packages with MultilayerGraphs.jl just as with other packages of the Graphs.jl ecosystem: as said above, a developer-oriented guide will be compiled if there is the need, although docstrings are already completed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To add a vertex, simply use add_vertex!. Let us define a vertex with metadata to add. Since nodes may not be represented more than once in layers, we have to define a new node too:","category":"page"},{"location":"","page":"Home","title":"Home","text":"new_node     = Node(\"missing_node\")\nnew_metadata = (meta = \"my_metadata\",)\nnew_vertex   = MV(new_node, new_metadata)","category":"page"},{"location":"","page":"Home","title":"Home","text":"MV(Node(\"missing_node\"), :nothing, (meta = \"my_metadata\",))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course, to be able to add a vertex with metadata to a layer, one must make sure that the underlying graph supports vertex-level metadata. Should one try to add a vertex with metadata different from an empty NamedTuple (i.e. no metadata) to a layer whose underlying graph does not support metadata, a warning is issued and the metadata are discarded.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thus, if we consider a layer whose underlying graph is a MetaGraph, the following three syntaxes would be equivalent.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The standard interface:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_vertex!(layer_mg, new_vertex)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The uniform interface. This signature has one keyword argument, metadata:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_vertex!(layer_mg, new_node, metadata = new_metadata)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The transparent interface. After you pass to add_vertex the Layer and the Node you wish to add, you  may pass the same args and kwargs  that you would pass to the add_vertex! dispatch that acts on the underlying graph (after the graph argument). This is a way to let the user directly exploit the API of the underlying graph package, which could be useful for two reasons:\nThey may be more convenient;\nThey should work even if we are not able to integrate the standard and the uniform interface with a particular Graphs.jl's extension.\nHere is an example on how to use it:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_vertex!(layer_mg, new_node, Dict(pairs(new_metadata)))","category":"page"},{"location":"","page":"Home","title":"Home","text":"where Dict(pairs(new_metadata)) is exactly what you would pass to the add_vertex! method that acts on MetaGraphs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"metagraph = MetaGraph()\nadd_vertex!(metagraph,  Dict(pairs(new_metadata))) # true","category":"page"},{"location":"","page":"Home","title":"Home","text":"If an underlying graph has an add_vertex! interface whose signature overlaps with that of the uniform interface, the uniform interface will be prevail.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If, using the transparent interface, one does not specify any metadata, the default_vertex_metadata function passed to the Layer's constructor is called to provide metadata to the vertex (type ?Layer in the REPL for more information).","category":"page"},{"location":"","page":"Home","title":"Home","text":"To remove the vertex, simply do:","category":"page"},{"location":"","page":"Home","title":"Home","text":"rem_vertex!(layer_sg, new_vertex) # Returns true if succeeds","category":"page"},{"location":"","page":"Home","title":"Home","text":"To extract metadata:","category":"page"},{"location":"","page":"Home","title":"Home","text":"get_metadata(layer_mg, MV(new_node))","category":"page"},{"location":"","page":"Home","title":"Home","text":"By design, one may not add nor remove vertices to Interlayers.","category":"page"},{"location":"#[Edges](@ref-edges_tut_subg)","page":"Home","title":"Edges","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The edge type for multilayer graphs (and thus for this subgraphs) is MultilayerEdge, which has a type parameter corresponding to the chosen weight type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"edgetype(layer_sg)","category":"page"},{"location":"","page":"Home","title":"Home","text":"MultilayerEdge{Float64}","category":"page"},{"location":"","page":"Home","title":"Home","text":"The MultilayerEdges of an unweighted simple layer are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"collect(edges(layer_sg))","category":"page"},{"location":"","page":"Home","title":"Home","text":"9-element Vector{MultilayerEdge{Float64}}:\n ME(MV(Node(\"node_2\"), :layer_sg, NamedTuple()) --> MV(Node(\"node_4\"), :layer_sg, NamedTuple()),\tweight = 1.0,\tmetadata = NamedTuple())\n ME(MV(Node(\"node_2\"), :layer_sg, NamedTuple()) --> MV(Node(\"node_6\"), :layer_sg, NamedTuple()),\tweight = 1.0,\tmetadata = NamedTuple())\n ME(MV(Node(\"node_2\"), :layer_sg, NamedTuple()) --> MV(Node(\"node_5\"), :layer_sg, NamedTuple()),\tweight = 1.0,\tmetadata = NamedTuple())\n ME(MV(Node(\"node_3\"), :layer_sg, NamedTuple()) --> MV(Node(\"node_4\"), :layer_sg, NamedTuple()),\tweight = 1.0,\tmetadata = NamedTuple())\n ME(MV(Node(\"node_3\"), :layer_sg, NamedTuple()) --> MV(Node(\"node_6\"), :layer_sg, NamedTuple()),\tweight = 1.0,\tmetadata = NamedTuple())\n ME(MV(Node(\"node_4\"), :layer_sg, NamedTuple()) --> MV(Node(\"node_6\"), :layer_sg, NamedTuple()),\tweight = 1.0,\tmetadata = NamedTuple())\n ME(MV(Node(\"node_4\"), :layer_sg, NamedTuple()) --> MV(Node(\"node_5\"), :layer_sg, NamedTuple()),\tweight = 1.0,\tmetadata = NamedTuple())\n ME(MV(Node(\"node_6\"), :layer_sg, NamedTuple()) --> MV(Node(\"node_5\"), :layer_sg, NamedTuple()),\tweight = 1.0,\tmetadata = NamedTuple())\n ME(MV(Node(\"node_6\"), :layer_sg, NamedTuple()) --> MV(Node(\"node_7\"), :layer_sg, NamedTuple()),\tweight = 1.0,\tmetadata = NamedTuple())","category":"page"},{"location":"","page":"Home","title":"Home","text":"Where ME is a shorthand for MultilayerEdge. Besides the two vertices connected, each MultilayerEdge carries the information about its weight and metadata. For unweighted subgraphs, the weight is just one(weighttype) and for non-meta subgraphs the metadata are an empty NamedTuples. See ?MultilayerEdge for additional information, or refer to the Edges to discover more methods related to MultilayerEdgess.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The add_edge function has the standard, uniform and transparent interfaces too. To understand how they work, let's define a weighted edge:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Define a weighted edge for the layer_swg\n## Define the weight\n_weight = rand()\n## Select two non-adjacent vertices in layer_swg\n_, src_w, dst_w  = _get_srcmv_dstmv_layer(layer_swg)\n## Construct a weighted MultilayerEdge\nme_w = ME(src_w, dst_w, _weight) # ME is an alias for MultilayerEdge","category":"page"},{"location":"","page":"Home","title":"Home","text":"ME(MV(Node(\"node_4\"), :layer_swg, NamedTuple()) --> MV(Node(\"node_1\"), :layer_swg, NamedTuple()),\tweight = 0.6369546116248217,\tmetadata = NamedTuple())","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course, to be able to add a weighted edge to a subgraph, one must make sure that the underlying graph supports edge weights. Should one try to add a weight different from one(weighttype) or nothing to an edge of a subgraph whose underlying graph does not support edge weights, a warning is issued and the weight is discarded.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thus, if we consider a layer whose underlying graph is a SimpleWeightedGraph, the following three syntaxes would be equivalent.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The standard interface:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(layer_swg, me_w)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The uniform interface. This signature has two keyword arguments, weight and metadata that could be used exclusively (if, respectively, the underlying graph is weighted or supports edge-level metadata) or in combination (if the underlying graph supports both edge weights and edge-level metadata):","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(layer_swg, src_w, dst_w, weight = _weight)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The transparent interface. After you pass to add_edge! the Layer and the two vertices you wish to connect, you  may pass the same args and kwargs  that you would pass to the add_edge! dispatch that acts on the underlying graph (after the graph and vertices arguments). This is done for the same reasons explained above. Here is an example on how to use it:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(layer_swg, src_w, dst_w, _weight)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where _weight is exactly what you would pass to the add_edge! method that acts on SimpleWeightedGraph after:","category":"page"},{"location":"","page":"Home","title":"Home","text":"simpleweightedgraph = SimpleWeightedGraph(5, 0)\nadd_edge!(simpleweightedgraph, 1, 2, _weight)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If an underlying graph has an add_edge! interface whose signature overlaps with that of the uniform interface, the uniform interface will prevail.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If, using the transparent interface, one does not specify any weight or (inclusively) metadata keyword argument, the default_edge_weight or (inclusively) the default_edge_metadata function passed to the subgraph's constructor will be called to provide weight or metadata to the edge (type ?Layer in the REPL for more information).","category":"page"},{"location":"","page":"Home","title":"Home","text":"To remove the edge, simply do:","category":"page"},{"location":"","page":"Home","title":"Home","text":"rem_edge!(layer_swg, src_w, dst_w) # Returns true if succeeds","category":"page"},{"location":"","page":"Home","title":"Home","text":"To extract weight:","category":"page"},{"location":"","page":"Home","title":"Home","text":"get_weight(layer_swg, src_w, dst_w)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For an edge with metadata, it would be analogous. Let's define an edge with metadata:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Define an edge with metadata for the layer_mg\n## Define the metadata\n_metadata  = (meta = \"mymetadata\",)\n## Select two non-adjacent vertices in layer_mg\n_, src_m, dst_m  = _get_srcmv_dstmv_layer(layer_mg)\n## Construct a MultilayerEdge with metadata\nme_m = ME(src_m, dst_m, _metadata)","category":"page"},{"location":"","page":"Home","title":"Home","text":"ME(MV(Node(\"node_6\"), :layer_mg, NamedTuple()) --> MV(Node(\"node_5\"), :layer_mg, NamedTuple()),\tweight = nothing,\tmetadata = (meta = \"mymetadata\",))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then the following three signatures would be equivalent:","category":"page"},{"location":"","page":"Home","title":"Home","text":"standard interface:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(layer_mg, me_m)","category":"page"},{"location":"","page":"Home","title":"Home","text":"uniform interface:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(layer_mg, src_m, dst_m, metadata = _metadata)","category":"page"},{"location":"","page":"Home","title":"Home","text":"transparent interface","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(layer_mg, src_m, dst_m, Dict(pairs(_metadata)))","category":"page"},{"location":"","page":"Home","title":"Home","text":"To extract metadata:","category":"page"},{"location":"","page":"Home","title":"Home","text":"get_metadata(layer_mg, src_m, dst_m)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the layer_swg, the following three signatures would be equivalent:","category":"page"},{"location":"","page":"Home","title":"Home","text":"standard interface:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(layer_swg, me_w)","category":"page"},{"location":"","page":"Home","title":"Home","text":"uniform interface:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(layer_swg, src_w, dst_w, weight = _weight)","category":"page"},{"location":"","page":"Home","title":"Home","text":"transparent interface","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_edge!(layer_swg, src_w, dst_w, _weight)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The uniform interface of add_edge! works so that the user may specify the keyword weight and/or the keyword metadata. If an underlying subgraph has a transparent interface whose signature overlaps with that of the uniform interface, the uniform interface will be prevail.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The edge may be removed via","category":"page"},{"location":"","page":"Home","title":"Home","text":"rem_edge!(layer_swg, src_w, dst_w)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A complete list of methods relating to subgraphs can be found here.","category":"page"},{"location":"#Multilayer-Graphs","page":"Home","title":"Multilayer Graphs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Given all the Layers and the Interlayers, let's instantiate a multilayer graph as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"multilayergraph = MultilayerGraph(  layers,                                                 # The (ordered) list of layers the multilayer graph will have\n                                    interlayers;                                            # The list of interlayers specified by the user. Note that the user does not need to specify all interlayers, as the unspecified ones will be automatically constructed using the indications given by the `default_interlayers_null_graph` and `default_interlayers_structure` keywords.\n                                    default_interlayers_null_graph = SimpleGraph{vertextype}(), # Sets the underlying graph for the interlayers that are to be automatically specified.  Defaults to `SimpleGraph{T}()`. See the `Layer` constructors for more information.\n                                    default_interlayers_structure = \"multiplex\" # Sets the structure of the interlayers that are to be automatically specified. May be \"multiplex\" for diagonally coupled interlayers, or \"empty\" for empty interlayers (no edges).  \"multiplex\". See the `Interlayer` constructors for more information.\n);","category":"page"},{"location":"","page":"Home","title":"Home","text":"Keep in mind that Multilayer(Di)Graph only supports uniform and standard interface for both add_vertex! and add_edge!.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As already stated, a MultilayerGraph is an object made of Layers and Interlayers whose collections of vertices each represents a subset of the set of nodes, here being the variable nodes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Adding a Node to a MultilayerGraph will enable its Layers  (and thus its Interlayers) to represent it i.e. you will be able to add MultilayerVertexs that represent that Node to the multilayer graph.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Another constructor allows for a limited configuration model-like specification. It allows to generate a multilayer graph with a specific degree distribution. Since edges are created according to the provided distribution, it is necessary that the layers and interlayers specified are empty (i.e. they have no edges). Notice that layers and interlayers whose underlying graph is a SimpleWeighted(Di)Graph may not be used until this PR is merged.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is used as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# The configuration model-like constructor will be responsible for creating the edges, so we need to provide it with empty layers and interlayers.\n# To create empty layers and interlayers, we will empty the above subgraphs, and, for compatobility reasons, we'll remove the ones having a `SimpleWeightedGraph`s. These lines are not necessary to comprehend the tutorial, they may be skipped. Just know that the variables `empty_layers` and `empty_interlayers` are two lists of, respectively, empty layers and interlayers that do not have `SimpleWeightedGraph`s as their underlying graphs\n\nempty_layers =  deepcopy([layer for layer in layers if !(layer.graph isa SimpleWeightedGraphs.AbstractSimpleWeightedGraph)])\n\nempty_layers_names = name.(empty_layers)\n\nempty_interlayers =  deepcopy([interlayer for interlayer in interlayers if all(in.(interlayer.layers_names, Ref(empty_layers_names))) && !(interlayer.graph isa SimpleWeightedGraphs.AbstractSimpleWeightedGraph) ])\n\nfor layer in empty_layers\n    for edge in edges(layer)\n        rem_edge!(layer, edge)\n    end\nend\n\nfor interlayer in empty_interlayers\n    for edge in edges(interlayer)\n        rem_edge!(interlayer, edge)\n    end\nend\n\n# Construct a multilayer graph that has a normal degree distribution. The support of the distribution must be positive, since negative degrees are not possible\nconfiguration_multilayergraph = MultilayerGraph(empty_layers, empty_interlayers, truncated(Normal(10), 0.0, 20.0));","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that this is not an implementation of a fully-fledged configuration model, which would require to be able to specify a degree distribution for every dimension of multiplexity. Please refer to Future Developments.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There is a similar constructor for MultilayerDiGraph which requires both the indegree distribution and the outdegree distribution. Anyway due to current performance limitations in the graph realization algorithms, it is suggested to provide two \"similar\" distributions (similar mean or location parameter, similar variance or shape parameter), in order not to incur in lengthy computational times.  ","category":"page"},{"location":"#[Nodes](@ref-nodes_tut_multig)","page":"Home","title":"Nodes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You may add a node via add_node:","category":"page"},{"location":"","page":"Home","title":"Home","text":"new_node = Node(\"new_node\")\nadd_node!(multilayergraph, new_node) # Return true if succeeds","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now one may add vertices that represent that node, e.g.:","category":"page"},{"location":"","page":"Home","title":"Home","text":"new_vertex = MV(new_node, :layer_sg)\nadd_vertex!(multilayergraph, new_vertex)","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"","page":"Home","title":"Home","text":"And remove the node via rem_node!:","category":"page"},{"location":"","page":"Home","title":"Home","text":"rem_node!(multilayergraph, new_node) # Return true if succeeds","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"#Modifying-edge-weight-and-metadata-and-vertex-metadata","page":"Home","title":"Modifying edge weight and metadata and vertex metadata","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"One may modify the weight of the edge of a multilayer graph via the set_weight! function. The call will succeed only if the edge that is acted upon exists and belongs to a weighted subgraph:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# This will succeed\nrandom_weighted_edge = rand(collect(edges(multilayergraph.layer_swg)))\nset_weight!(multilayergraph, src(random_weighted_edge), dst(random_weighted_edge), rand())","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"","page":"Home","title":"Home","text":"# This will not succeed\nrandom_unweighted_edge = rand(collect(edges(multilayergraph.layer_sg)))\nset_weight!(multilayergraph, src(random_unweighted_edge), dst(random_unweighted_edge), rand())","category":"page"},{"location":"","page":"Home","title":"Home","text":"false","category":"page"},{"location":"","page":"Home","title":"Home","text":"Equivalent arguments can be made for set_metadata! (both vertex and edge dispatches).","category":"page"},{"location":"#Adding,-Removing,-Modifying-and-Accessing-layers-and-interlayers","page":"Home","title":"Adding, Removing, Modifying and Accessing layers and interlayers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"One may of course add layers on the fly:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Instantiate a new Layer\n_nv, _ne = rand_nv_ne_layer(min_vertices,max_vertices)\nnew_layer = Layer(  :new_layer,\n                    sample(multilayervertices, _nv, replace = false),\n                    _ne,\n                    SimpleGraph{vertextype}(),\n                    _weighttype\n)\n\n# Add the Layer\nadd_layer!(\n            multilayergraph,                                # the `Multilayer(Di)Graph` which the new layer will be added to;\n            new_layer;                                      # the new `Layer` to add to the `multilayergraph`\n            default_interlayers_null_graph = SimpleGraph{vertextype}(), # upon addition of a new `Layer`, all the `Interlayer`s between the new and the existing `Layer`s are immediately created. This keyword argument specifies their `null_graph` See the `Layer` constructor for more information. Defaults to `SimpleGraph{T}()`\n            default_interlayers_structure = \"empty\"         # The structure of the `Interlayer`s created by default. May either be \"multiplex\" to have diagonally-coupled only interlayers, or \"empty\" for empty interlayers. Defaults to \"multiplex\".\n)\n\n# Check that the new layer now exists within the multilayer graph\nhas_layer(multilayergraph, :new_layer)","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"","page":"Home","title":"Home","text":"The add_layer! function will automatically instantiate all the Interlayers between the newly added Layer and the Layers already present in the multilayer graph.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you wish to manually specify an interlayer, just do:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Instantiate a new Interlayer. Notice that its name will be given by default as\n_ne = rand_ne_interlayer(layer_sg, new_layer)\nnew_interlayer = Interlayer(    layer_sg,                \n                                new_layer,               \n                                _ne,                     \n                                SimpleGraph{vertextype}(),\n                                name = :new_interlayer\n)\n\n# Modify an existing interlayer with the latter i.e. specify the latter interlayer:\nspecify_interlayer!( multilayergraph,\n                     new_interlayer)\n\n# Now the interlayer between `layer_sg` and `new_layer` is `new_interlayer`","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"","page":"Home","title":"Home","text":"Suppose that, after some modifications of multilayergraph, you would like to inspect a particular slice (or subgraph) of it (i.e. a Layer or an Interlayer). You may use both layers and interlayers names as properties of the multilayer graph itself.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Get a layer by name\nmultilayergraph.new_layer","category":"page"},{"location":"","page":"Home","title":"Home","text":"Layer{Int64, Float64, SimpleGraph{Int64}}(LayerDescriptor{Int64, Float64, SimpleGraph{Int64}}(:new_layer, SimpleGraph{Int64}(0, Vector{Int64}[]), MultilayerGraphs.var\"#54#60\"(), MultilayerGraphs.var\"#55#61\"(), MultilayerGraphs.var\"#56#62\"()), SimpleGraph{Int64}(10, [[3, 5, 7], [4, 5, 6], [1, 6], [2, 7], [1, 2, 6], [2, 3, 5, 7], [1, 4, 6]]), Bijection{Int64,MultilayerVertex{:new_layer}} (with 7 pairs))","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Get an Interlayer by name\nmultilayergraph.new_interlayer","category":"page"},{"location":"","page":"Home","title":"Home","text":"Interlayer{Int64, Float64, SimpleGraph{Int64}}(InterlayerDescriptor{Int64, Float64, SimpleGraph{Int64}}(:new_interlayer, :layer_sg, :new_layer, SimpleGraph{Int64}(0, Vector{Int64}[]), MultilayerGraphs.var\"#92#96\"(), MultilayerGraphs.var\"#93#97\"(), false), SimpleGraph{Int64}(19, [[7, 12], [7, 8, 10, 11, 13], [7, 10], [7, 13], [7, 9, 11, 13], [7, 8, 12, 13], [1, 2, 3, 4, 5, 6], [2, 6], [5], [2, 3], [2, 5], [1, 6], [2, 4, 5, 6]]), Bijection{Int64,MultilayerVertex} (with 13 pairs))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Interlayers may also be accessed by remembering the names of the Layers they connect:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Get an Interlayer from the names of the two layers that it connects\nget_interlayer(multilayergraph, :new_layer, :layer_sg )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Interlayer{Int64, Float64, SimpleGraph{Int64}}(InterlayerDescriptor{Int64, Float64, SimpleGraph{Int64}}(:new_interlayer_rev, :new_layer, :layer_sg, SimpleGraph{Int64}(0, Vector{Int64}[]), MultilayerGraphs.var\"#92#96\"(), MultilayerGraphs.var\"#93#97\"(), false), SimpleGraph{Int64}(19, [[8, 9, 10, 11, 12, 13], [9, 13], [12], [9, 10], [9, 12], [8, 13], [9, 11, 12, 13], [1, 6], [1, 2, 4, 5, 7], [1, 4], [1, 7], [1, 3, 5, 7], [1, 2, 6, 7]]), Bijection{Int64,MultilayerVertex} (with 13 pairs))","category":"page"},{"location":"","page":"Home","title":"Home","text":"NB: Although the interlayer from an arbitrary layer_1 to layer_2 is the same mathematical object as the interlayer from layer_2 to layer_1, their representations as Interlayers differ in the internals, and most notably in the order of the vertices. The Interlayer from layer_1 to layer_2 orders its vertices so that the MultilayerVertexs of layer_1 (in the order they were in layer_1 when the Interlayer was instantiated) come before the MultilayerVertexs of layer_2 (in the order they were in layer_2 when the Interlayer was instantiated).","category":"page"},{"location":"","page":"Home","title":"Home","text":"When calling get_interlayer(multilayergraph, :layer_1, :layer_2) it is returned the Interlayer from layer_1 to layer_2. If the Interlayer from layer_2 to layer_1 was manually specified or automatically generated during  during the instantiation of the multilayer graph with name, say, \"some_interlayer\", then the returned Interlayer will be named \"some_interlayer_rev\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"To remove a layer:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Remove the layer. This will also remove all the interlayers associated to it.\nrem_layer!( multilayergraph,\n            :new_layer;\n            remove_nodes = false # Whether to also remove all nodes represented in the to-be-removed layer from the multilayer graph\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"true","category":"page"},{"location":"","page":"Home","title":"Home","text":"Visit the multilayer graph subsection of the edn-user APIs to discover more useful methods.","category":"page"},{"location":"#Weight/Adjacency-Tensor,-Metadata-Tensor-and-Supra-Weight/Adjacency-Matrix","page":"Home","title":"Weight/Adjacency Tensor, Metadata Tensor and Supra Weight/Adjacency Matrix","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"One may extract the weight tensor of a multilayergraph via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"wgt = weight_tensor(multilayergraph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"WeightTensor{Float64}([0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0;;; 0.0 1.0 … 0.0 0.0; 1.0 1.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 1.0 … 1.0 0.0;;; 1.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 1.0 0.0; 0.0 0.0 … 0.0 0.0;;; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0;;;; 0.0 1.0 … 0.0 0.0; 1.0 1.0 … 0.0 1.0; … ; 0.0 0.0 … 0.0 1.0; 0.0 0.0 … 0.0 0.0;;; 0.0 0.9828581516714545 … 0.0 0.7736606234481569; 0.9828581516714545 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.7736606234481569 0.0 … 0.0 0.0;;; 0.19989407135094706 0.0 … 0.0 0.16650315003660054; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.6643136923736794 … 0.0 0.0; 0.40879510776523964 0.7458197468092816 … 0.0 0.0;;; 1.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 1.0;;;; 1.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 1.0 0.0; 0.0 0.0 … 0.0 0.0;;; 0.19989407135094706 0.0 … 0.0 0.40879510776523964; 0.0 0.0 … 0.6643136923736794 0.7458197468092816; … ; 0.0 0.0 … 0.0 0.0; 0.16650315003660054 0.0 … 0.0 0.0;;; 0.0 0.0 … 0.0 1.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 1.0 0.0 … 0.0 0.0;;; 1.0 0.0 … 1.0 1.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 1.0 0.0; 0.0 0.0 … 1.0 1.0;;;; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0;;; 1.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 1.0;;; 1.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 1.0 0.0 … 1.0 1.0; 1.0 0.0 … 0.0 1.0;;; 0.0 0.0 … 1.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 1.0 0.0 … 0.0 1.0; 0.0 0.0 … 1.0 0.0], [:layer_sg, :layer_swg, :layer_mg, :layer_vg], Bijection{Int64,Node} (with 7 pairs))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that wgt is an object of type WeightTensor. You may access its array representation using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"array(wgt)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also, you may index it using MultilayerVertexs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Get two random vertices from the MultilayerGraph\nmv1, mv2 = rand(mv_vertices(multilayergraph), 2)\n\n# Get the strength of the edge between them (0 for no edge):\nwgt[mv1, mv2]","category":"page"},{"location":"","page":"Home","title":"Home","text":"0.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similarly, there is a MetadataTensor, that may be created via metadata_tensor(multilayergraph)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package also exports a SupraWeightMatrix which is a supra (weighted) adjacency matrix with the same indexing functionality as above. You may instantiate it via supra_weight_matrix(multilayergraph).","category":"page"},{"location":"#Multilayer-specific-analytical-tools","page":"Home","title":"Multilayer-specific analytical tools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Read a complete list of analytical methods exclusive to multilayer graphs in the dedicated API section (here \"exclusive\" means that wither those methods do not exists for standard graphs, or that they had to be reimplemented and so may present some caveats). Refer to their docstrings for more information.","category":"page"},{"location":"#Compatibility-with-Agents.jl","page":"Home","title":"Compatibility with Agents.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multilayer(Di)Graphs may be used as an argument to GraphSpace in Agents.jl. A complete compatibility example may be found in this test.","category":"page"},{"location":"#Future-Developments","page":"Home","title":"Future Developments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Implement more general configuration models / graph generators;\nImplement graph of layers;\nImplement projected monoplex and overlay graphs;\nImplement more default multilayer graphs (e.g. multiplex graphs).","category":"page"},{"location":"#How-to-Contribute","page":"Home","title":"How to Contribute","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The ongoing development of this package would greatly benefit from the valuable feedback of the esteemed members of the JuliaGraph community, as well as from graph theorists, network scientists, and any users who may have general questions or suggestions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We therefore encourage you to participate in discussions, raise issues, or submit pull requests. Your contributions are most welcome!","category":"page"},{"location":"#How-to-Cite","page":"Home","title":"How to Cite","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you utilize this package in your project, please consider citing this repository using the citation information provided in CITATION.bib. This will help to give appropriate credit to the contributors and support the continued development of the package.","category":"page"},{"location":"#Announcements","page":"Home","title":"Announcements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package and its features were announced on the following platforms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Discourse\nForem\nTwitter","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"De Domenico et al. (2013) Mathematical Formulation of Multilayer Networks. Physical Review X;\nKivelä et al. (2014) Multilayer networks. Journal of Complex Networks;\nBianconi (2018) Multilayer Networks: Structure and Function. Oxford University Press.","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"This page provides a list of exported methods organized by topic and audience. Methods that act on vertices, edges, and layers are grouped together. Some methods are intended for developers who want to use the Graphs.jl library as part of their code, while others are meant for end-users.","category":"page"},{"location":"API/#End-User","page":"API","title":"End-User","text":"","category":"section"},{"location":"API/#nodes_eu","page":"API","title":"Nodes","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Node\nid","category":"page"},{"location":"API/#MultilayerGraphs.Node","page":"API","title":"MultilayerGraphs.Node","text":"struct Node <: AbstractNode\n\nA custom concrete type representing a node of a multilayer graph.\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.id","page":"API","title":"MultilayerGraphs.id","text":"id(n::Node)\n\nReturn the id of n.\n\n\n\n\n\n","category":"function"},{"location":"API/#vertices_eu","page":"API","title":"Vertices","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"eltype\nMultilayerVertex\nMV\nnode\nlayer\nmetadata(mv::MultilayerVertex)\nMissingVertex","category":"page"},{"location":"API/#Base.eltype","page":"API","title":"Base.eltype","text":"Base.eltype(subgraph::AbstractSubGraph)\n\nReturn the vertex type of subgraph.\n\n\n\n\n\neltype(::M) where {T,M<:AbstractMultilayerGraph{T}}\n\nReturn the vertex type of mg.\n\n\n\n\n\n","category":"function"},{"location":"API/#MultilayerGraphs.MultilayerVertex","page":"API","title":"MultilayerGraphs.MultilayerVertex","text":"MultilayerVertex{N <: Integer} <: AbstractMultilayerVertex{N}\n\nA struct representing a vertex of a MultilayerGraph.\n\nFIELDS\n\nnode::Node: the Node that the MultilayerVertex represents;\nlayer::Union{Nothing, Symbol}: the name of the Layer the MultilayerVertex lies in;\nmetadata::Union{<: NamedTuple, <: Tuple}: the metadata associated to this MultilayerVertex.\n\nCONSTRUCTORS\n\nMultilayerVertex(node::Node, layer::Union{Nothing, Symbol},  metadata::Union{<: NamedTuple, <: Tuple})\n\nConstructs a MultilayerVertex representing Node node in Layer with metadata metadata.\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.MV","page":"API","title":"MultilayerGraphs.MV","text":"MV\n\nAlias for MultilayerVertex\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.node","page":"API","title":"MultilayerGraphs.node","text":"node(mv::MultilayerVertex)\n\nReturns the Node represented by mv.\n\n\n\n\n\n","category":"function"},{"location":"API/#MultilayerGraphs.layer","page":"API","title":"MultilayerGraphs.layer","text":"layer(mv::MultilayerVertex)\n\nReturn the name of the layer which the MultilayerVertex belongs to.\n\n\n\n\n\n","category":"function"},{"location":"API/#MultilayerGraphs.metadata-Tuple{MultilayerVertex}","page":"API","title":"MultilayerGraphs.metadata","text":"metadata(mv::MultilayerVertex)\n\nReturn the metadata associated to mv.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.MissingVertex","page":"API","title":"MultilayerGraphs.MissingVertex","text":"MissingVertex\n\nA mutable struct that acts as a placeholder for a vertex that is missing in a Layer. It is mutable so that it may be added more than once to the Bijections struct from Bijections.jl.\n\n\n\n\n\n","category":"type"},{"location":"API/#edges_eu","page":"API","title":"Edges","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"MultilayerEdge\nME\nweight(e::AbstractMultilayerEdge)\nmetadata(e::AbstractMultilayerEdge)","category":"page"},{"location":"API/#MultilayerGraphs.MultilayerEdge","page":"API","title":"MultilayerGraphs.MultilayerEdge","text":"struct MultilayerEdge{ T <: MultilayerVertex, U <: Union{ <: Real, Nothing}} <: AbstractMultilayerEdge{T}\n\nDefault concrete subtype of AbstractMultilayerEdge.\n\nFIELDS\n\nsrc::T: the source vertex of the edge;\ndst::T: the destination vertex of the edge;\nweight::U: the edge weight.\n\nCONSTRUCTORS\n\nMultilayerEdge(src::T, dst::T, weight::U) where { T <: MultilayerVertex, U <: Union{ <: Real, Nothing}}\n\nDefault constructor.\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.ME","page":"API","title":"MultilayerGraphs.ME","text":"ME\n\nShorter alias for MultilayerEdge.\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.weight-Tuple{AbstractMultilayerEdge}","page":"API","title":"MultilayerGraphs.weight","text":"weight(e::AbstractMultilayerEdge)\n\nReturn the weight of e.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.metadata-Tuple{AbstractMultilayerEdge}","page":"API","title":"MultilayerGraphs.metadata","text":"metadata(e::AbstractMultilayerEdge)\n\nReturn the metadata of e.\n\n\n\n\n\n","category":"method"},{"location":"API/#subgraphs_eu","page":"API","title":"Subgraphs","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Layer{T <: Integer, U <: Real, G <: AbstractGraph{T}}\nLayer(name::Symbol, vertices::Vector{<: MultilayerVertex}, edge_list::Vector{ <: MultilayerEdge}, null_graph::G, weighttype::Type{U};  default_vertex_metadata::Function = mv -> NamedTuple(), default_edge_weight::Function = (src, dst) -> one(U), default_edge_metadata::Function = (src, dst) -> NamedTuple()) where {T <: Integer, U <: Real,  G <: AbstractGraph{T}}\n\nLayer(\n    name::Symbol,\n    vertices::Vector{ <: MultilayerVertex},\n    ne::Int64,\n    null_graph::G,\n    weighttype::Type{U};\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_weight::Function = (src, dst) -> nothing,\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    allow_self_loops::Bool = false\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nhas_node(layer::Layer, n::Node)\nadd_vertex!(layer::Layer, mv::MultilayerVertex)\nadd_vertex!(layer::L, n::Node, args...; kwargs...) where {T, L <: Layer{T}} \nrem_vertex!(layer::Layer, mv::MultilayerVertex)\nrem_vertex!(layer::Layer, n::Node)\n\nInterlayer{T<:Integer,U<:Real,G<:AbstractGraph{T}}\nInterlayer(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    null_graph::G,\n    edge_list::Vector{ <: MultilayerEdge{<: Union{U, Nothing}}};\n    default_edge_weight::Function = (x,y) -> nothing,\n    default_edge_metadata::Function = (x,y) -> NamedTuple(),\n    transfer_vertex_metadata::Bool = false,\n    name::Symbol = Symbol(\"interlayer_$(layer_1.name)_$(layer_2.name)\")\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\n\nInterlayer(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    ne::Int64,\n    null_graph::G;\n    default_edge_weight::Function = (x,y) -> nothing,\n    default_edge_metadata::Function = (x,y) -> NamedTuple(),\n    name::Symbol = Symbol(\"interlayer_$(layer_1.name)_$(layer_2.name)\"),\n    transfer_vertex_metadata::Bool = false\n) where {T<:Integer, U <: Union{Nothing, <: Real},  G<:AbstractGraph{T}}\n\n\nmultiplex_interlayer(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    null_graph::G;\n    default_edge_weight::Function = (x,y) -> nothing,\n    default_edge_metadata::Function = (x,y) -> NamedTuple(),\n    transfer_vertex_metadata::Bool = false,\n    name::Symbol = Symbol(\"interlayer_$(layer_1.name)_$(layer_2.name)\")\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\n\nempty_interlayer(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    null_graph::G;\n    default_edge_weight::Function = (x,y) -> nothing,\n    default_edge_metadata::Function = (x,y) -> NamedTuple(),\n    name::Symbol = Symbol(\"interlayer_$(layer_1.name)_$(layer_2.name)\"),\n    transfer_vertex_metadata::Bool = false\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nnodes(subgraph::AbstractSubGraph)\nhas_vertex(layer::Layer, mv::MultilayerVertex)\nhas_vertex(interlayer::Interlayer, mv::MultilayerVertex)\nnv(subgraph::AbstractSubGraph)\nmv_vertices(subgraph::AbstractSubGraph)\nmv_inneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\nmv_outneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\nmv_neighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\nhas_edge(subgraph::AbstractSubGraph,me::MultilayerEdge)\nhas_edge( subgraph::AbstractSubGraph, s::MultilayerVertex, d::MultilayerVertex)\nne(subgraph::AbstractSubGraph)\nedges(subgraph::S) where {T,U,S<:AbstractSubGraph{T,U}} \nadd_edge!( subgraph::S, me::E) where {T,U<:Real,S<:AbstractSubGraph{T,U},E<:MultilayerEdge{ <: Union{U, Nothing}}}\nadd_edge!(layer::Layer, src::MultilayerVertex, dst::MultilayerVertex, args...; kwargs...)\nadd_edge!(interlayer::Interlayer, src::MultilayerVertex, dst::MultilayerVertex, args...; kwargs...)\nrem_edge!(subgraph::AbstractSubGraph, src::MultilayerVertex, dst::MultilayerVertex)\nrem_edge!(subgraph::AbstractSubGraph, me::MultilayerEdge)\nget_metadata(subgraph::AbstractSubGraph, bare_mv::MultilayerVertex)\nget_metadata(subgraph::AbstractSubGraph, src::MultilayerVertex, dst::MultilayerVertex)\nget_weight(subgraph::AbstractSubGraph, src::MultilayerVertex, dst::MultilayerVertex) \nis_directed(subgraph::AbstractSubGraph)\nis_directed(::Type{S}) where {T,U,G,S <: AbstractSubGraph{T,U,G}}\nadjacency_matrix(subgraph::AbstractSubGraph)\nMultilayerGraphs.weights(subgraph::S) where {T,U,S<:AbstractSubGraph{T,U}}\nname(subgraph::AbstractSubGraph)\n \nis_multiplex_interlayer(interlayer::Interlayer)\n\nget_symmetric_interlayer(\n    interlayer::In;\n    symmetric_interlayer_name::String = String(interlayer.name) * \"_rev\"\n) where {T,U,G,In<:Interlayer{T,U,G}}","category":"page"},{"location":"API/#MultilayerGraphs.Layer","page":"API","title":"MultilayerGraphs.Layer","text":"mutable struct Layer{T <: Integer, U <: Real, G <: AbstractGraph{T}} <: AbstractLayer{T,U,G}\n\nRepresents a layer in a Multilayer(Di)Graph. Its type hierarchy is: Layer <: AbstractLayer <: AbstractSubGraph .\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Symbol, Vector{<:MultilayerVertex}, Vector{<:MultilayerEdge}, G, Type{U}}} where {T<:Integer, U<:Real, G<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.Layer","text":"Layer(name::Symbol, vertices::Vector{<: MultilayerVertex}, edge_list::Vector{ <: MultilayerEdge}, null_graph::G, weighttype::Type{U};  default_vertex_metadata::Function = mv -> NamedTuple(), default_edge_weight::Function = (src, dst) -> one(U), default_edge_metadata::Function = (src, dst) -> NamedTuple()) where {T <: Integer, U <: Real,  G <: AbstractGraph{T}}\n\nConstructor for Layer.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer;\nvertices::Vector{ <: MultilayerVertex}: The MultilayerVertexs of the Layer;\nedge_list::Vector{ <: MultilayerEdge}: The list of MultilayerEdges;\nnull_graph::G: the Layer's underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown;\nweighttype::Type{U}: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted)\n\nKWARGS\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Symbol, Vector{<:MultilayerVertex}, Int64, G, Type{U}}} where {T<:Integer, U<:Real, G<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.Layer","text":"Layer(\n    name::Symbol,\n    vertices::Vector{ <: MultilayerVertex},\n    ne::Int64,\n    null_graph::G,\n    weighttype::Type{U};\n    default_vertex_metadata::Function = mv -> NamedTuple(),\n    default_edge_weight::Function = (src, dst) -> nothing,\n    default_edge_metadata::Function = (src, dst) -> NamedTuple(),\n    allow_self_loops::Bool = false\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nReturn a random Layer.\n\nARGUMENTS\n\nname::Symbol: The name of the Layer\nvertices::Vector{ <: MultilayerVertex}: The MultilayerVertexs of the Layer\nne::Int64: The number of edges of the Layer\nnull_graph::G: the Layer's underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.\nweighttype::Type{U}: The type of the MultilayerEdge weights (even when the underlying Layer's graph is unweighted, we need to specify a weight type since the MultilayerGraphs will always be weighted);\n\nKWARGS\n\n-default_vertex_metadata::Function: Function that takes a MultilayerVertex and returns a Tuple or a NamedTuple containing the vertex metadata. defaults to mv -> NamedTuple();\n\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\nallow_self_loops::Bool: whether to allow self loops to be generated or not. Defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.has_node-Tuple{Layer, Node}","page":"API","title":"MultilayerGraphs.has_node","text":"has_node(layer::Layer, n::Node)\n\nReturn true if n is a node of layer.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.add_vertex!-Tuple{Layer, MultilayerVertex}","page":"API","title":"Graphs.SimpleGraphs.add_vertex!","text":"add_vertex!(layer::Layer, mv::MultilayerVertex)\n\nAdd vertex to layer layer. \n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.add_vertex!-Union{Tuple{L}, Tuple{T}, Tuple{L, Node, Vararg{Any}}} where {T, L<:(Layer{T, U, G} where {U<:Real, G<:AbstractGraph{T}})}","page":"API","title":"Graphs.SimpleGraphs.add_vertex!","text":"add_vertex!(layer::L, n::Node, args...; kwargs...) where {T, L <: Layer{T}}\n\nAdd vertex associated with node n to layer layer. This method supports the uniform and transparent interfaces. See the Vertices section of the Tutorial.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.rem_vertex!-Tuple{Layer, MultilayerVertex}","page":"API","title":"Graphs.SimpleGraphs.rem_vertex!","text":"rem_vertex!(layer::Layer, mv::MultilayerVertex)\n\nRemove vertex mv from layer layer.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.rem_vertex!-Tuple{Layer, Node}","page":"API","title":"Graphs.SimpleGraphs.rem_vertex!","text":"rem_vertex!(layer::Layer, n::Node)\n\nRemove node n from layer. Modify layer.v_N_associations according to how rem_vertex! works in Graph.jl.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.Interlayer","page":"API","title":"MultilayerGraphs.Interlayer","text":"Interlayer{T<:Integer,U<:Real,G<:AbstractGraph{T}} <: AbstractInterlayer{T,U,G}\n\nRepresents an interlayer in a Multilayer(Di)Graph. Its type hierarchy is: Interlayer <: AbstractInterlayer <: AbstractSubGraph .\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G<:AbstractGraph{T}, Layer{T, U, G} where G<:AbstractGraph{T}, G, Vector{<:MultilayerEdge{<:Union{Nothing, U}}}}} where {T<:Integer, U<:Real, G<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.Interlayer","text":"Interlayer(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    null_graph::G,\n    edge_list::Vector{ <: MultilayerEdge{<: Union{U, Nothing}}};\n    default_edge_weight::Function = (x,y) -> nothing,\n    default_edge_metadata::Function = (x,y) -> NamedTuple(),\n    transfer_vertex_metadata::Bool = false,\n    name::Symbol\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nConstructor for Interlayer.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nedge_list::Vector{ <: MultilayerEdge{<: Union{U, Nothing}}}: The MultilayerEdge list of the Interlayer;\nnull_graph::G: the Interlayer's underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.\n\nKWARGS\n\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\nname::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\ntransfer_vertex_metadata::Bool:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don't support metadata or that pose limitations to it may result in errors.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G<:AbstractGraph{T}, Layer{T, U, G} where G<:AbstractGraph{T}, Int64, G}} where {T<:Integer, U<:(Union{Nothing, var\"#s2\"} where var\"#s2\"<:Real), G<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.Interlayer","text":"Interlayer(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    ne::Int64,\n    null_graph::G;\n    default_edge_weight::Function = (x,y) -> nothing,\n    default_edge_metadata::Function = (x,y) -> NamedTuple(),\n    name::Symbol,\n    transfer_vertex_metadata::Bool = false\n) where {T<:Integer, U <: Union{Nothing, <: Real}, G<:AbstractGraph{T}}\n\nReturn a random Interlayer.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nne::Int64: The number of edges of the Interlayer;\n\nnull_graph::G: the Interlayer's underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.\n\nKWARGS\n\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\nname::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\ntransfer_vertex_metadata::Bool:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don't support metadata or that pose limitations to it may result in errors.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.multiplex_interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G<:AbstractGraph{T}, Layer{T, U, G} where G<:AbstractGraph{T}, G}} where {T<:Integer, U<:Real, G<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.multiplex_interlayer","text":"multiplex_interlayer(nv::Int64,\n    name::Symbol,\n    layer_1::Symbol, \n    layer_2::Symbol, \n    graph_type::Type{G}; \n    forbidden_vertices::Vector{MultilayerVertex}, forbidden_edges::Vector{NTuple{2, MultilayerVertex}}\n) where {T <: Union{ <: Integer, AbstractVertex}, G <: AbstractGraph{T}}\n\nReturn an Interlayer{T,U,G} that has edges only between vertices that represent the same node.\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nnull_graph::G: the Interlayer's underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.\n\nKWARGS\n\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\nname::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\ntransfer_vertex_metadata::Bool:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don't support metadata or that pose limitations to it may result in errors.;\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.empty_interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G<:AbstractGraph{T}, Layer{T, U, G} where G<:AbstractGraph{T}, G}} where {T<:Integer, U<:Real, G<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.empty_interlayer","text":"empty_interlayer(\n    layer_1::Layer{T,U},\n    layer_2::Layer{T,U},\n    null_graph::G;\n    default_edge_weight::Function = (x,y) -> nothing,\n    default_edge_metadata::Function = (x,y) -> NamedTuple(),\n    name::Symbol),\n    transfer_vertex_metadata::Bool = false\n) where {T<:Integer, U <: Real, G<:AbstractGraph{T}}\n\nConstruct an empty interlayer (i.e. an interlayer with no edges).\n\nARGUMENTS\n\nlayer_1::Layer{T,U}: one of the two layers connected by the Interlayer;\nlayer_2::Layer{T,U}: one of the two layers connected by the Interlayer;\nnull_graph::G: the Interlayer's underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.\n\nKWARGS\n\ndefault_edge_weight::Function: Function that takes a pair of MultilayerVertexs and returns an edge weight of type weighttype or nothing (which is compatible with unweighted underlying graphs and corresponds to one(weighttype) for weighted underlying graphs). Defaults to (src, dst) -> nothing;\ndefault_edge_metadata::Function: Function that takes a pair of MultilayerVertexs and  returns a Tuple or a NamedTuple containing the edge metadata, that will be called when add_edge!(mg,src,dst, args...; kwargs...) is called without the metadata keyword argument, and when generating the edges in this constructor. Defaults to  (src, dst) -> NamedTuple();\nname::Symbol: The name of the Interlayer. Defaults to Symbol(\"interlayer(layer1.name)(layer2.name)\");\ntransfer_vertex_metadata::Bool:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don't support metadata or that pose limitations to it may result in errors.;\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.nodes-Tuple{AbstractSubGraph}","page":"API","title":"MultilayerGraphs.nodes","text":"nodes(subgraph::AbstractSubGraph)\n\nReturn the collection of the nodes of subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.has_vertex-Tuple{Layer, MultilayerVertex}","page":"API","title":"Graphs.has_vertex","text":"has_vertex(layer::Layer, mv::MultilayerVertex)\n\nReturn true if v is a vertex of layer.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.has_vertex-Tuple{Interlayer, MultilayerVertex}","page":"API","title":"Graphs.has_vertex","text":"has_vertex(interlayer::Interlayer, v::MultilayerVertex)\n\nReturn true if v is a vertex of interlayer.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.nv-Tuple{AbstractSubGraph}","page":"API","title":"Graphs.nv","text":"nv(subgraph::AbstractSubGraph)\n\nReturn the number of vertices in subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.mv_vertices-Tuple{AbstractSubGraph}","page":"API","title":"MultilayerGraphs.mv_vertices","text":"mv_vertices(subgraph::AbstractSubGraph)\n\nReturn the collection of the MultilayerVertexs of subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.mv_inneighbors-Tuple{AbstractSubGraph, MultilayerVertex}","page":"API","title":"MultilayerGraphs.mv_inneighbors","text":"mv_inneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\n\nReturn the MultilayerVertexs inneighbors of mv within subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.mv_outneighbors-Tuple{AbstractSubGraph, MultilayerVertex}","page":"API","title":"MultilayerGraphs.mv_outneighbors","text":"mv_outneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\n\nReturn the MultilayerVertexs outneighbors of mv within subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.mv_neighbors-Tuple{AbstractSubGraph, MultilayerVertex}","page":"API","title":"MultilayerGraphs.mv_neighbors","text":"mv_neighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\n\nDefaults to mv_outneighbors.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.has_edge-Tuple{AbstractSubGraph, MultilayerEdge}","page":"API","title":"Graphs.has_edge","text":"has_edge(subgraph::AbstractSubGraph,me::MultilayerEdge)\n\nReturn true if there is an edge from src(me) to dst(me) within subgraph, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.has_edge-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}","page":"API","title":"Graphs.has_edge","text":"has_edge( subgraph::AbstractSubGraph, s::MultilayerVertex, d::MultilayerVertex)\n\nReturn true if there is an edge between s and d, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.ne-Tuple{AbstractSubGraph}","page":"API","title":"Graphs.ne","text":"ne(subgraph::AbstractSubGraph)\n\nReturn the number of edges in subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.edges-Union{Tuple{S}, Tuple{U}, Tuple{T}} where {T, U, S<:(AbstractSubGraph{T, U, G} where G<:AbstractGraph{T})}","page":"API","title":"Graphs.edges","text":"edges(subgraph::S) where {T,U,S<:AbstractSubGraph{T,U}}\n\nReturn an iterator over all the edges of subgraph.\n\n\n\n\n\nedges(mg::M) where {T,U,M<:AbstractMultilayerUGraph{T,U}}\n\nReturn an list of all the edges of mg.\n\n\n\n\n\nedges(mg::M) where {T,U,M<:AbstractMultilayerDiGraph{T,U}}\n\nReturn an list of all the edges of mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{S}, Tuple{U}, Tuple{T}, Tuple{S, E}} where {T, U<:Real, S<:(AbstractSubGraph{T, U, G} where G<:AbstractGraph{T}), E<:(MultilayerEdge{<:Union{Nothing, U}})}","page":"API","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!( subgraph::S, me::E) where {T,U<:Real,S<:AbstractSubGraph{T,U},E<:MultilayerEdge{ <: Union{U, Nothing}}}\n\nAdd unweighted edge me to subgraph. Its weight and metadata fields are passed to the uniform interface of add_edge!(::Layer, ::MultilayerVertex, ::MultilayerVertex, ::Tuple).\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.add_edge!-Tuple{Layer, MultilayerVertex, MultilayerVertex, Vararg{Any}}","page":"API","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(layer::L, src::MultilayerVertex, dst::MultilayerVertex, args...; kwargs...) where {L <: Layer}\n\nAdd edge from vertex src to vertex dst to layer layer. Returns true if succeeds. This method supports the uniform and transparent interfaces. See the Edges section of the Tutorial.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.add_edge!-Tuple{Interlayer, MultilayerVertex, MultilayerVertex, Vararg{Any}}","page":"API","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(interlayer::Interlayer, src::MultilayerVertex, dst::MultilayerVertex, args...; kwargs...)\n\nAdd edge from vertex src to vertex dst to Interlayer interlayer.Returns true if succeeds, but will fail (return false) if src and dst belong to the same layer, since interlayers are always bipartite. This method supports the uniform and transparent interfaces. See the Edges section of the Tutorial.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.rem_edge!-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}","page":"API","title":"Graphs.SimpleGraphs.rem_edge!","text":"rem_edge!(subgraph::AbstractSubGraph, src::MultilayerVertex, dst::MultilayerVertex)\n\nRemove edge from src to dst in subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.rem_edge!-Tuple{AbstractSubGraph, MultilayerEdge}","page":"API","title":"Graphs.SimpleGraphs.rem_edge!","text":"rem_edge!(subgraph::AbstractSubGraph, me::MultilayerEdge)\n\nRemove edge from src(me) to dst(me) in subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.get_metadata-Tuple{AbstractSubGraph, MultilayerVertex}","page":"API","title":"MultilayerGraphs.get_metadata","text":"get_metadata(subgraph::AbstractSubGraph, bare_mv::MultilayerVertex)\n\nReturn the metadata of the vertex bare_mv in subgraph (metadata assigned to bare_mv will be discarded). \n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.get_metadata-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}","page":"API","title":"MultilayerGraphs.get_metadata","text":"get_edge_metadata(subgraph::S, src::MultilayerVertex, dst::MultilayerVertex)\n\nReturn the metadata of the edge between the source vertex src and the destination vertex dst in subgraph. \n\n\n\n\n\n","category":"method"},{"location":"API/#SimpleWeightedGraphs.get_weight-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}","page":"API","title":"SimpleWeightedGraphs.get_weight","text":"get_weight(subgraph::S, src::MultilayerVertex, dst::MultilayerVertex)\n\nReturn the weight of the edge between the source vertex src and the destination vertex dst in subgraph. \n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.is_directed-Tuple{AbstractSubGraph}","page":"API","title":"Graphs.is_directed","text":"is_directed(subgraph::AbstractSubGraph)\n\nReturn true if subgraph is directed, false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.is_directed-Union{Tuple{Type{S}}, Tuple{S}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, S<:AbstractSubGraph{T, U, G}}","page":"API","title":"Graphs.is_directed","text":"is_directed(::Type{S}) where {T,U,G,S <: AbstractSubGraph{T,U,G}}\n\nReturn true if instances of S are directed, false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.LinAlg.adjacency_matrix-Tuple{AbstractSubGraph}","page":"API","title":"Graphs.LinAlg.adjacency_matrix","text":"adjacency_matrix(subgraph::AbstractSubGraph)\n\nReturn the adjacency matrix of subgraph.graph.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.weights-Union{Tuple{S}, Tuple{U}, Tuple{T}} where {T, U, S<:(AbstractSubGraph{T, U, G} where G<:AbstractGraph{T})}","page":"API","title":"Graphs.weights","text":"weights(subgraph::S) where { T,U, G <: AbstractGraph{T}, S <:AbstractSubGraph{T,U,G}}\n\nReturn the weights of subgraph.graph, with the eltype converted to U.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.name-Tuple{AbstractSubGraph}","page":"API","title":"MultilayerGraphs.name","text":"name(subgraph::AbstractSubGraph)\n\nReturn the name of subgraph. \n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.is_multiplex_interlayer-Tuple{Interlayer}","page":"API","title":"MultilayerGraphs.is_multiplex_interlayer","text":"is_multiplex_interlayer(interlayer::In) where {In <: Interlayer}\n\nCheck that Interlayer interlayer is a multiplex-type Interlayer.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.get_symmetric_interlayer-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, In<:Interlayer{T, U, G}}","page":"API","title":"MultilayerGraphs.get_symmetric_interlayer","text":"get_symmetric_interlayer(interlayer::In; symmetric_interlayer_name::String) where{T,U,G, In <: Interlayer{T,U,G}}\n\nReturn the Interlayer corresponding to interlayer where layer_1 and layer_2 are swapped. Its name will be symmetric_interlayer_name (defaults to interlayer_(interlayer.layer_2)_(interlayer.layer_1)).\n\n\n\n\n\n","category":"method"},{"location":"API/#msm_eu","page":"API","title":"Multilayer-Specific Methods","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"MultilayerGraph{T,U}\n\nMultilayerDiGraph{T,U}\n\nMultilayerGraph(T::Type{<:Number}, U::Type{<:Number})\n\nMultilayerDiGraph(T::Type{<:Number}, U::Type{<:Number})\n\nMultilayerGraph(\n    layers::Vector{<:Layer{T,U}},\n    specified_interlayers::Vector{<:Interlayer{T,U}};\n    default_interlayers_null_graph::H = SimpleGraph{T}(),\n    default_interlayers_structure::String=\"multiplex\",\n) where {T,U, H <: AbstractGraph{T}}\n\nMultilayerDiGraph(\n    layers::Vector{<:Layer{T,U}},\n    specified_interlayers::Vector{<:Interlayer{T,U}};\n    default_interlayers_null_graph::H = SimpleGraph{T}(),\n    default_interlayers_structure::String=\"multiplex\",\n) where {T,U, H <: AbstractGraph{T}}\n\nMultilayerGraph(\n    empty_layers::Vector{<:Layer{T,U}},\n    empty_interlayers::Vector{<:Interlayer{T,U}},\n    degree_distribution::UnivariateDistribution;\n    allow_self_loops::Bool = false,\n    default_interlayers_null_graph::H = SimpleGraph{T}(),\n) where {T <: Integer, U <: Real, H <: AbstractGraph{T}}\n\nMultilayerDiGraph(\n    empty_layers::Vector{<:Layer{T,U}},\n    empty_interlayers::Vector{<:Interlayer{T,U}},\n    indegree_distribution::UnivariateDistribution,\n    outdegree_distribution::UnivariateDistribution;\n    allow_self_loops::Bool = false,\n    default_interlayers_null_graph::H = SimpleGraph{T}(),\n) where {T <: Integer, U <: Real, H <: AbstractGraph{T}}\n\nMultilayerGraph(\n    empty_multilayergraph::MultilayerGraph{T,U}, \n    degree_sequence::Vector{<:Integer}; \n    allow_self_loops::Bool = false, \n    perform_checks::Bool = true\n) where {T,U}\n\nMultilayerDiGraph(\n    empty_multilayerdigraph::MultilayerDiGraph{T,U}, \n    indegree_sequence::Vector{<:Integer},\n    outdegree_sequence::Vector{<:Integer};\n    allow_self_loops::Bool = false,\n     perform_checks::Bool = false\n) where {T,U}\n\nnodes(mg::AbstractMultilayerGraph)\nnn(mg::AbstractMultilayerGraph) \nadd_node!(mg::AbstractMultilayerGraph, n::Node)\nrem_node!(mg::AbstractMultilayerGraph, n::Node)\nhas_vertex(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\nnv(mg::M) where {M <: AbstractMultilayerGraph }\nmv_vertices(mg::AbstractMultilayerGraph)\nmv_inneighbors(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\nmv_outneighbors(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\nmv_neighbors( mg::AbstractMultilayerGraph, mv::MultilayerVertex)\nadd_vertex!(mg::M, V::MultilayerVertex) where {T, U, M <: AbstractMultilayerUGraph{T,U}}\nadd_vertex!(mg::M, V::MultilayerVertex) where {T, U, M <: AbstractMultilayerDiGraph{T,U}}\nrem_vertex!(mg::AbstractMultilayerUGraph, V::MultilayerVertex)\nrem_vertex!(mg::AbstractMultilayerDiGraph, V::MultilayerVertex)\nhas_edge(mg::AbstractMultilayerGraph, edge::MultilayerEdge) \nhas_edge( subgraph::AbstractMultilayerGraph, s::MultilayerVertex, d::MultilayerVertex)\nne(mg::AbstractMultilayerGraph)\nedges(mg::AbstractMultilayerUGraph)\nedges(mg::M) where {T,U,M<:AbstractMultilayerUGraph{T,U}}\nedges(mg::M) where {T,U,M<:AbstractMultilayerDiGraph{T,U}}\nadd_edge!(mg::M, src::V, dst::V; weight::Union{Nothing, U} = one(U), metadata::Union{Tuple,NamedTuple} = NamedTuple() ) where {T,U, M <: AbstractMultilayerGraph{T,U}, V <: MultilayerVertex}\nadd_edge!(mg::M, me::E) where {T,U, M <: AbstractMultilayerUGraph{T,U}, E <: MultilayerEdge{ <: Union{U,Nothing}}}\nadd_edge!(mg::M, me::E) where {T,U, M <: AbstractMultilayerDiGraph{T,U}, E <: MultilayerEdge{ <: Union{U,Nothing}}}\nrem_edge!(mg::AbstractMultilayerGraph, me::MultilayerEdge)\nrem_edge!(mg::MultilayerGraph, src::MultilayerVertex, dst::MultilayerVertex)\nrem_edge!(mg::MultilayerDiGraph, src::MultilayerVertex, dst::MultilayerVertex)\nget_metadata(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\nget_metadata(mg::AbstractMultilayerGraph, src::MultilayerVertex, dst::MultilayerVertex)\nget_weight(mg::AbstractMultilayerGraph, src::MultilayerVertex, dst::MultilayerVertex)\nset_weight!(mg::M, src::MultilayerVertex, dst::MultilayerVertex, weight::U) where { T,U, M <: AbstractMultilayerUGraph{T,U}}\nset_weight!(mg::M, src::MultilayerVertex, dst::MultilayerVertex, weight::U) where { T,U, M <: AbstractMultilayerDiGraph{T,U}}\nis_directed(mg::AbstractMultilayerUGraph)\nis_directed(m::M) where { M <: Type{ <: AbstractMultilayerUGraph}}\nis_directed(mg::AbstractMultilayerDiGraph)\nis_directed(m::M) where { M <: Type{ <: AbstractMultilayerDiGraph}}\nhas_node(mg::AbstractMultilayerGraph, n::Node)\nset_metadata!(mg::AbstractMultilayerGraph, mv::MultilayerVertex, metadata::Union{Tuple, NamedTuple}) \nset_metadata!(mg::AbstractMultilayerDiGraph, src::MultilayerVertex, dst::MultilayerVertex, metadata::Union{Tuple, NamedTuple})\nset_metadata!(mg::AbstractMultilayerUGraph, src::MultilayerVertex, dst::MultilayerVertex, metadata::Union{Tuple, NamedTuple})\nnl(mg::AbstractMultilayerGraph)\nnIn(mg::AbstractMultilayerGraph)\nhas_layer(mg::AbstractMultilayerGraph, layer_name::Symbol)\n\nadd_layer!(mg::M, new_layer::L; default_interlayers_null_graph::H = SimpleGraph{T}(), default_interlayers_structure::String =\"multiplex\"\n) where {T,U,G<:AbstractGraph{T},M<:AbstractMultilayerUGraph{T,U},L<:Layer{T,U,G}, H <: AbstractGraph{T}}\n\nadd_layer!(\n    mg::M, new_layer::L; default_interlayers_null_graph::H = SimpleGraph{T}(), default_interlayers_structure::String =\"multiplex\"\n) where {T,U,G<:AbstractGraph{T},M<:AbstractMultilayerDiGraph{T,U},L<:Layer{T,U,G}, H <: AbstractGraph{T}}\n\nspecify_interlayer!(\n    mg::M,\n    new_interlayer::In\n) where {T,U,G<:AbstractGraph{T},M<:AbstractMultilayerDiGraph{T,U},In<:Interlayer{T,U,G}}\n\nspecify_interlayer!(\n    mg::M,\n    new_interlayer::In\n) where {T,U,G<:AbstractGraph{T},M<:AbstractMultilayerUGraph{T,U},In<:Interlayer{T,U,G}}\n\nget_interlayer(\n    mg::AbstractMultilayerGraph, layer_1_name::Symbol, layer_2_name::Symbol\n)\n\n\nindegree( mg::AbstractMultilayerGraph, v::MultilayerVertex) \nindegree(mg::AbstractMultilayerGraph, vs::AbstractVector{<:MultilayerVertex}=vertices(mg))\n\noutdegree(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\noutdegree(mg::AbstractMultilayerGraph, vs::AbstractVector{<:MultilayerVertex}=vertices(mg))\n\ndegree(mg::AbstractMultilayerGraph, vs::AbstractVector{<:MultilayerVertex}=vertices(mg)) \n\nmean_degree(mg::AbstractMultilayerGraph)\n\ndegree_second_moment(mg::AbstractMultilayerGraph) \n\ndegree_variance(mg::AbstractMultilayerGraph)\n\nMultilayerGraphs.weighttype(::M) where {T,U,M<:AbstractMultilayerGraph{T,U}}\n\nmultilayer_global_clustering_coefficient(\n    mg::AbstractMultilayerGraph, norm_factor::Union{Float64,Symbol}=:max\n)\n\noverlay_clustering_coefficient(\n    mg::AbstractMultilayerGraph,\n    norm_factor::Union{Float64,Symbol}=:max\n)\n\neigenvector_centrality(\n    mg::M; weighted::Bool = true,  norm::String=\"1\", tol::Float64=1e-6, maxiter::Int64=2000\n) where {T,U,M<:AbstractMultilayerGraph{T,U}}\n\nmodularity(\n    mg::M, c::Matrix{Int64}; null_model::Union{String,Array{U,4}}=\"degree\"\n) where {T,U,M<:AbstractMultilayerGraph{T,U}}\n\n\nvon_neumann_entropy(mg::M) where {T,U,M<:AbstractMultilayerUGraph{T,U}}","category":"page"},{"location":"API/#MultilayerGraphs.MultilayerGraph","page":"API","title":"MultilayerGraphs.MultilayerGraph","text":"MultilayerGraph{T, U, G <: AbstractGraph{T}} <: AbstractMultilayerGraph{T,U}\n\nA concrete type that can represent a general multilayer graph. Its internal fields aren't meant to be modified by the user. Please prefer the provided API.\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.MultilayerDiGraph","page":"API","title":"MultilayerGraphs.MultilayerDiGraph","text":"MultilayerDiGraph{T, U, G <: AbstractGraph{T}} <: AbstractMultilayerGraph{T,U}\n\nA concrete type that can represent a general multilayer graph. Its internal fields aren't meant to be modified by the user. Please prefer the provided API.\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.MultilayerGraph-Tuple{Type{<:Number}, Type{<:Number}}","page":"API","title":"MultilayerGraphs.MultilayerGraph","text":"MultilayerGraph(T::Type{<:Number}, U::Type{<:Number})\n\nReturn a null MultilayerGraph with with vertex type T weighttype U. Use this constructor and then add Layers and Interlayers via the add_layer! and specify_interlayer! methods.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.MultilayerDiGraph-Tuple{Type{<:Number}, Type{<:Number}}","page":"API","title":"MultilayerGraphs.MultilayerDiGraph","text":"MultilayerDiGraph(n_nodes::Int64, T::Type{ <: Number}, U::Type{ <: Number} )\n\nReturn a null MultilayerDiGraph with with vertex type T weighttype U. Use this constructor and then add Layers and Interlayers via the add_layer! and specify_interlayer! methods.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.MultilayerGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{<:Layer{T, U, G} where G<:AbstractGraph{T}}, Vector{<:Interlayer{T, U, G} where G<:AbstractGraph{T}}}} where {T, U, H<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.MultilayerGraph","text":"MultilayerGraph(\n    layers::Vector{<:Layer{T,U}},\n    specified_interlayers::Vector{<:Interlayer{T,U}};\n    default_interlayers_null_graph::H = SimpleGraph{T}(),\n    default_interlayers_structure::String=\"multiplex\",\n) where {T,U, H <: AbstractGraph{T}}\n\nConstruct a MultilayerGraph with layers given by layers. The interlayers will be constructed by default according to default_interlayer where only \"multiplex\" and \"empty\" are allowed, except for those specified in specified_interlayers. default_interlayer = \"multiplex\" will imply that unspecified interlayers will have only diagonal couplings, while  default_interlayer = \"multiplex\" will produced interlayers that have no couplings.\n\nARGUMENTS\n\nlayers::Vector{<:Layer{T,U}}: The (ordered) list of layers the multilayer graph will have;\nspecified_interlayers::Vector{<:Interlayer{T,U}}: The list of interlayers specified by the user. Note that the user does not need to specify all interlayers, as the unspecified ones will be automatically constructed using the indications given by the default_interlayers_null_graph and default_interlayers_structure keywords.;\ndefault_interlayers_null_graph::H = SimpleGraph{T}(): Sets the underlying graph for the interlayers that are to be automatically specified. Defaults to SimpleGraph{T}(). See the Layer constructors for more information.;\ndefault_interlayers_structure::String = \"multiplex\": Sets the structure of the interlayers that are to be automatically specified. May be \"multiplex\" for diagonally coupled interlayers, or \"empty\" for empty interlayers (no edges).  \"multiplex\". See the Interlayer constructors for more information.;\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.MultilayerDiGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{<:Layer{T, U, G} where G<:AbstractGraph{T}}, Vector{<:Interlayer{T, U, G} where G<:AbstractGraph{T}}}} where {T, U, H<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.MultilayerDiGraph","text":"MultilayerDiGraph(\n    layers::Vector{<:Layer{T,U}},\n    specified_interlayers::Vector{<:Interlayer{T,U}};\n    default_interlayers_null_graph::H = SimpleGraph{T}(),\n    default_interlayers_structure::String=\"multiplex\",\n) where {T,U, H <: AbstractGraph{T}}\n\nConstruct a MultilayerDiGraph with layers given by layers. The interlayers will be constructed by default according to default_interlayer where only \"multiplex\" and \"empty\" are allowed, except for those specified in specified_interlayers. default_interlayer = \"multiplex\" will imply that unspecified interlayers will have only diagonal couplings, while  default_interlayer = \"multiplex\" will produced interlayers that have no couplings.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.MultilayerGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{<:Layer{T, U, G} where G<:AbstractGraph{T}}, Vector{<:Interlayer{T, U, G} where G<:AbstractGraph{T}}, UnivariateDistribution}} where {T<:Integer, U<:Real, H<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.MultilayerGraph","text":"MultilayerGraph(\n    empty_layers::Vector{<:Layer{T,U}},\n    empty_interlayers::Vector{<:Interlayer{T,U}},\n    degree_distribution::UnivariateDistribution;\n    allow_self_loops::Bool = false,\n    default_interlayers_null_graph::H = SimpleGraph{T}(),\n) where {T <: Integer, U <: Real, H <: AbstractGraph{T}}\n\nReturn a random MultilayerGraph that has empty_layers as layers and empty_interlayers as specified interlayers. empty_layers and empty_interlayers must respectively be Layers and Interlayers with whatever number of vertices but no edges (if any edge is found, an error is thrown). The  degree distribution of the returned random MultilayerGraph is given by degree_distribution, which must have a support that only contains positive numbers for obvious reasons. allow_self_loops = true allows for self loops t be present in the final random MultilayerGraph. default_interlayers_null_graph controls the null_graph argument passed to automatically-generated interlayers. \n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.MultilayerDiGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{<:Layer{T, U, G} where G<:AbstractGraph{T}}, Vector{<:Interlayer{T, U, G} where G<:AbstractGraph{T}}, UnivariateDistribution, UnivariateDistribution}} where {T<:Integer, U<:Real, H<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.MultilayerDiGraph","text":"MultilayerDiGraph(\n    empty_layers::Vector{<:Layer{T,U}},\n    empty_interlayers::Vector{<:Interlayer{T,U}},\n    indegree_distribution::UnivariateDistribution,\n    outdegree_distribution::UnivariateDistribution;\n    allow_self_loops::Bool = false,\n    default_interlayers_null_graph::H = SimpleGraph{T}(),\n) where {T <: Integer, U <: Real, H <: AbstractGraph{T}}\n\nReturn a random MultilayerDiGraph that has empty_layers as layers and empty_interlayers as specified interlayers. empty_layers and empty_interlayers must respectively be Layers and Interlayers with whatever number of vertices but no edges (if any edge is found, an error is thrown). The  degree distribution of the returned random MultilayerDiGraph is given by degree_distribution, which must have a support that only contains positive numbers for obvious reasons. allow_self_loops = true allows for self loops t be present in the final random MultilayerDiGraph. default_interlayers_null_graph controls the null_graph argument passed to automatically-generated interlayers. \n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.MultilayerGraph-Union{Tuple{U}, Tuple{T}, Tuple{MultilayerGraph{T, U}, Vector{<:Integer}}} where {T, U}","page":"API","title":"MultilayerGraphs.MultilayerGraph","text":"MultilayerGraph(empty_multilayergraph::MultilayerGraph{T,U},\ndegree_sequence::Vector{<:Integer}; \nallow_self_loops::Bool = false,\nperform_checks::Bool = false) where {T,U}\n\nReturn a random MultilayerGraph with degree sequence degree_sequence. allow_self_loops controls the presence of self-loops, while if perform_checks is true, the degree_sequence os checked to be graphical.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.MultilayerDiGraph-Union{Tuple{U}, Tuple{T}, Tuple{MultilayerDiGraph{T, U}, Vector{<:Integer}, Vector{<:Integer}}} where {T, U}","page":"API","title":"MultilayerGraphs.MultilayerDiGraph","text":"MultilayerDiGraph(\n    empty_multilayerdigraph::MultilayerDiGraph{T,U}, \n    indegree_sequence::Vector{<:Integer},\n    outdegree_sequence::Vector{<:Integer};\n    allow_self_loops::Bool = false,\n    perform_checks::Bool = false\n) where {T,U}\n\nReturn a random MultilayerDiGraph with degree sequence degree_sequence. allow_self_loops controls the presence of self-loops, while if perform_checks is true, the degree_sequence os checked to be graphical.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.nodes-Tuple{AbstractMultilayerGraph}","page":"API","title":"MultilayerGraphs.nodes","text":"nodes(mg::AbstractMultilayerGraph\n\nReturn the nodes of the AbstractMultilayerGraph mg, in order of addition.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.nn-Tuple{AbstractMultilayerGraph}","page":"API","title":"MultilayerGraphs.nn","text":"nn(mg::M) where {M <: AbstractMultilayerGraph }\n\nReturn the number of nodes in mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.add_node!-Tuple{AbstractMultilayerGraph, Node}","page":"API","title":"MultilayerGraphs.add_node!","text":"add_node!(mg::AbstractMultilayerGraph, n::Node)\n\nAdd node n to mg. Return true if succeeds.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.rem_node!-Tuple{AbstractMultilayerGraph, Node}","page":"API","title":"MultilayerGraphs.rem_node!","text":"rem_node!(mg::AbstractMultilayerGraph, n::Node)\n\nRemove node n to mg. Return true if succeeds.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.has_vertex-Tuple{AbstractMultilayerGraph, MultilayerVertex}","page":"API","title":"Graphs.has_vertex","text":"has_vertex(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\n\nReturn true if mv is in mg, else false.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.nv-Tuple{M} where M<:AbstractMultilayerGraph","page":"API","title":"Graphs.nv","text":"nv(mg::M) where {M <: AbstractMultilayerGraph }\n\nReturn the number of vertices in mg, excluding the missing vertices.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.mv_vertices-Tuple{AbstractMultilayerGraph}","page":"API","title":"MultilayerGraphs.mv_vertices","text":"mv_vertices(mg::AbstractMultilayerGraph)\n\nReturn a list of the MultilayerVertexs contained in mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.mv_inneighbors-Tuple{AbstractMultilayerGraph, MultilayerVertex}","page":"API","title":"MultilayerGraphs.mv_inneighbors","text":"mv_inneighbors(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\n\nReturn the list of MultilayerVertex inneighbors of mv within mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.mv_outneighbors-Tuple{AbstractMultilayerGraph, MultilayerVertex}","page":"API","title":"MultilayerGraphs.mv_outneighbors","text":"mv_outneighbors(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\n\nReturn the list of MultilayerVertex outneighbors of mv within mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.mv_neighbors-Tuple{AbstractMultilayerGraph, MultilayerVertex}","page":"API","title":"MultilayerGraphs.mv_neighbors","text":"mv_neighbors(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\n\nReturn the list of MultilayerVertex neighbors of mv within mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.add_vertex!-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, MultilayerVertex}} where {T, U, M<:AbstractMultilayerUGraph{T, U}}","page":"API","title":"Graphs.SimpleGraphs.add_vertex!","text":"add_vertex!(mg::M, V::MultilayerVertex) where {T, U, M <: AbstractMultilayerUGraph{T,U}}\n\nAdd MultilayerVertex V to multilayer graph mg, provided that node(V) is a Node of mg. Return true if succeeds.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.add_vertex!-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, MultilayerVertex}} where {T, U, M<:AbstractMultilayerDiGraph{T, U}}","page":"API","title":"Graphs.SimpleGraphs.add_vertex!","text":"add_vertex!(mg::M, V::MultilayerVertex) where {T, U, M <: AbstractMultilayerDiGraph{T,U}}\n\nAdd MultilayerVertex V to multilayer graph mg, provided that node(V) is a Node of mg. Return true if succeeds. \n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.rem_vertex!-Tuple{AbstractMultilayerUGraph, MultilayerVertex}","page":"API","title":"Graphs.SimpleGraphs.rem_vertex!","text":"rem_vertex!(mg::AbstractMultilayerUGraph, V::MultilayerVertex)\n\nRemove MultilayerVertex mv from mg. Return true if succeeds, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.rem_vertex!-Tuple{AbstractMultilayerDiGraph, MultilayerVertex}","page":"API","title":"Graphs.SimpleGraphs.rem_vertex!","text":"rem_vertex!(mg::AbstractMultilayerDiGraph, V::MultilayerVertex)\n\nRemove MultilayerVertex mv from mg. Return true if succeeds, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.has_edge-Tuple{AbstractMultilayerGraph, MultilayerEdge}","page":"API","title":"Graphs.has_edge","text":"has_edge(mg::AbstractMultilayerGraph, edge::MultilayerEdge)\n\nReturn true if mg has an edge between the source and the destination of edge (does not check edge or vertex metadata).\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.has_edge-Tuple{AbstractMultilayerGraph, MultilayerVertex, MultilayerVertex}","page":"API","title":"Graphs.has_edge","text":"has_edge(mg::AbstractMultilayerGraph, src::MultilayerVertex, dst::MultilayerVertex)\n\nReturn true if mg has edge between the src and dst (does not check edge or vertex metadata).\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.ne-Tuple{AbstractMultilayerGraph}","page":"API","title":"Graphs.ne","text":"ne(mg::AbstractMultilayerGraph)\n\nReturn the number of edges in mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.edges-Tuple{AbstractMultilayerUGraph}","page":"API","title":"Graphs.edges","text":"edges(subgraph::S) where {T,U,S<:AbstractSubGraph{T,U}}\n\nReturn an iterator over all the edges of subgraph.\n\n\n\n\n\nedges(mg::M) where {T,U,M<:AbstractMultilayerUGraph{T,U}}\n\nReturn an list of all the edges of mg.\n\n\n\n\n\nedges(mg::M) where {T,U,M<:AbstractMultilayerDiGraph{T,U}}\n\nReturn an list of all the edges of mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.edges-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M<:AbstractMultilayerUGraph{T, U}}","page":"API","title":"Graphs.edges","text":"edges(subgraph::S) where {T,U,S<:AbstractSubGraph{T,U}}\n\nReturn an iterator over all the edges of subgraph.\n\n\n\n\n\nedges(mg::M) where {T,U,M<:AbstractMultilayerUGraph{T,U}}\n\nReturn an list of all the edges of mg.\n\n\n\n\n\nedges(mg::M) where {T,U,M<:AbstractMultilayerDiGraph{T,U}}\n\nReturn an list of all the edges of mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.edges-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M<:AbstractMultilayerDiGraph{T, U}}","page":"API","title":"Graphs.edges","text":"edges(subgraph::S) where {T,U,S<:AbstractSubGraph{T,U}}\n\nReturn an iterator over all the edges of subgraph.\n\n\n\n\n\nedges(mg::M) where {T,U,M<:AbstractMultilayerUGraph{T,U}}\n\nReturn an list of all the edges of mg.\n\n\n\n\n\nedges(mg::M) where {T,U,M<:AbstractMultilayerDiGraph{T,U}}\n\nReturn an list of all the edges of mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U, M<:AbstractMultilayerGraph{T, U}, V<:MultilayerVertex}","page":"API","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(mg::M, src::V, dst::V; weight::Union{Nothing, U} = one(U), metadata::Union{Tuple,NamedTuple} = NamedTuple() ) where {T,U, M <: AbstractMultilayerGraph{T,U}, V <: MultilayerVertex}\n\nAdd a MultilayerEdge between src and dst with weight weight and metadata metadata. Return true if succeeds, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U, M<:AbstractMultilayerUGraph{T, U}, E<:(MultilayerEdge{<:Union{Nothing, U}})}","page":"API","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(mg::M, me::E) where {T,U, M <: AbstractMultilayerUGraph{T,U}, E <: MultilayerEdge{ <: Union{U,Nothing}}}\n\nAdd MultilayerEdge me to the MultilayerGraph mg. Return true if succeeds, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U, M<:AbstractMultilayerDiGraph{T, U}, E<:(MultilayerEdge{<:Union{Nothing, U}})}","page":"API","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(mg::M, me::E) where {T,U, M <: AbstractMultilayerDiGraph{T,U}, E <: MultilayerEdge{ <: Union{U,Nothing}}}\n\nAdd MultilayerEdge me to the MultilayerDiGraph mg. Return true if succeeds, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.rem_edge!-Tuple{AbstractMultilayerGraph, MultilayerEdge}","page":"API","title":"Graphs.SimpleGraphs.rem_edge!","text":"rem_edge!(mg::AbstractMultilayerGraph, me::MultilayerEdge)\n\nRemove edge from src(me) to dst(me) from mg. Return true if succeeds, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.rem_edge!-Tuple{MultilayerGraph, MultilayerVertex, MultilayerVertex}","page":"API","title":"Graphs.SimpleGraphs.rem_edge!","text":"rem_edge!(mg::AbstractMultilayerUGraph, src::MultilayerVertex, dst::MultilayerVertex)\n\nRemove edge from src to dst from mg. Return true if succeeds, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.rem_edge!-Tuple{MultilayerDiGraph, MultilayerVertex, MultilayerVertex}","page":"API","title":"Graphs.SimpleGraphs.rem_edge!","text":"rem_edge!(mg::MultilayerDiGraph, src::MultilayerVertex, dst::MultilayerVertex)\n\nRemove edge from src to dst from mg. Return true if succeeds, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.get_metadata-Tuple{AbstractMultilayerGraph, MultilayerVertex}","page":"API","title":"MultilayerGraphs.get_metadata","text":"get_metadata(mg::AbstractMultilayerGraph, bare_mv::MultilayerVertex)\n\nReturn the metadata associated to MultilayerVertex mv (regardless of metadata assigned to bare_mv).\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.get_metadata-Tuple{AbstractMultilayerGraph, MultilayerVertex, MultilayerVertex}","page":"API","title":"MultilayerGraphs.get_metadata","text":"get_metadata(mg::AbstractMultilayerGraph, src::MultilayerVertex, dst::MultilayerVertex)\n\nReturn the metadata associated to the MultilayerEdge from src to dst.\n\n\n\n\n\n","category":"method"},{"location":"API/#SimpleWeightedGraphs.get_weight-Tuple{AbstractMultilayerGraph, MultilayerVertex, MultilayerVertex}","page":"API","title":"SimpleWeightedGraphs.get_weight","text":"get_weight(mg::AbstractMultilayerGraph, src::MultilayerVertex, dst::MultilayerVertexph\n\nReturn the weight associated to the MultilayerEdge from src to dst.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.set_weight!-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, MultilayerVertex, MultilayerVertex, U}} where {T, U, M<:AbstractMultilayerUGraph{T, U}}","page":"API","title":"MultilayerGraphs.set_weight!","text":"set_weight!(mg::M, src::MultilayerVertex{L1}, dst::MultilayerVertex{L2}, weight::U) where {L1 <: Symbol, L2 <: Symbol, T,U, M <: AbstractMultilayerGraph{T,U}}\n\nSet the weight of the edge between src and dst to weight. Return true if succeeds (i.e. if the edge exists and the underlying graph chosen for the Layer/Interlayer where the edge lies is weighted under the IsWeighted trait).\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.set_weight!-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, MultilayerVertex, MultilayerVertex, U}} where {T, U, M<:AbstractMultilayerDiGraph{T, U}}","page":"API","title":"MultilayerGraphs.set_weight!","text":"set_weight!(mg::M, src::MultilayerVertex{L1}, dst::MultilayerVertex{L2}, weight::U) where {L1 <: Symbol, L2 <: Symbol, T,U, M <: AbstractMultilayerGraph{T,U}}\n\nSet the weight of the edge between src and dst to weight. Return true if succeeds (i.e. if the edge exists and the underlying graph chosen for the Layer/Interlayer where the edge lies is weighted under the IsWeighted trait).\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.is_directed-Tuple{AbstractMultilayerUGraph}","page":"API","title":"Graphs.is_directed","text":"is_directed(mg::AbstractMultilayerUGraph)\n\nReturn true if mg is directed, false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.is_directed-Tuple{M} where M<:(Type{<:AbstractMultilayerUGraph})","page":"API","title":"Graphs.is_directed","text":"is_directed(m::M) where { M <: Type{ <: AbstractMultilayerUGraph}}\n\nReturn true if mg is directed, false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.is_directed-Tuple{AbstractMultilayerDiGraph}","page":"API","title":"Graphs.is_directed","text":"is_directed(mg::AbstractMultilayerDiGraph)\n\nReturn true if mg is directed, false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.is_directed-Tuple{M} where M<:(Type{<:AbstractMultilayerDiGraph})","page":"API","title":"Graphs.is_directed","text":"is_directed(m::M) where { M <: Type{ <: AbstractMultilayerDiGraph}}\n\nReturn true if mg is directed, false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.has_node-Tuple{AbstractMultilayerGraph, Node}","page":"API","title":"MultilayerGraphs.has_node","text":"has_node(mg::AbstractMultilayerGraph, n::Node)\n\nReturn true if n is a node of mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.set_metadata!-Tuple{AbstractMultilayerGraph, MultilayerVertex, Union{Tuple, NamedTuple}}","page":"API","title":"MultilayerGraphs.set_metadata!","text":"set_metadata!(mg::AbstractMultilayerGraph, mv::MultilayerVertex, metadata::Union{Tuple, NamedTuple})\n\nSet the metadata of vertex mv to metadata. Return true if succeeds\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.set_metadata!-Tuple{AbstractMultilayerDiGraph, MultilayerVertex, MultilayerVertex, Union{Tuple, NamedTuple}}","page":"API","title":"MultilayerGraphs.set_metadata!","text":"set_metadata!(mg::AbstractMultilayerDiGraph, src::MultilayerVertex, dst::MultilayerVertex, metadata::Union{Tuple, NamedTuple})\n\nSet the metadata of the edge between src and dst to metadata. Return true if succeeds (i.e. if the edge exists and the underlying graph chosen for the Layer/Interlayer where the edge lies supports metadata at the edge level  under the IsMeta trait).\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.set_metadata!-Tuple{AbstractMultilayerUGraph, MultilayerVertex, MultilayerVertex, Union{Tuple, NamedTuple}}","page":"API","title":"MultilayerGraphs.set_metadata!","text":"set_metadata!(mg::AbstractMultilayerUGraph, src::MultilayerVertex, dst::MultilayerVertex, metadata::Union{Tuple, NamedTuple})\n\nSet the metadata of the edge between src and dst to metadata. Return true if succeeds (i.e. if the edge exists and the underlying graph chosen for the Layer/Interlayer where the edge lies supports metadata at the edge level  under the IsMeta trait).\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.nl-Tuple{AbstractMultilayerGraph}","page":"API","title":"MultilayerGraphs.nl","text":"nl(mg::AbstractMultilayerGraph)\n\nReturn the number of layers in mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.nIn-Tuple{AbstractMultilayerGraph}","page":"API","title":"MultilayerGraphs.nIn","text":"nIn(mg::AbstractMultilayerGraph)\n\nReturn the number of interlayers in mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.has_layer-Tuple{AbstractMultilayerGraph, Symbol}","page":"API","title":"MultilayerGraphs.has_layer","text":"has_layer(mg::AbstractMultilayerGraph, layer_name::Symbol)\n\nReturn true in layer_name is a name of a [Layer](@ref) of mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.add_layer!-Union{Tuple{H}, Tuple{L}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, G<:AbstractGraph{T}, M<:AbstractMultilayerUGraph{T, U}, L<:Layer{T, U, G}, H<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.add_layer!","text":"add_layer!( mg::M,\n    new_layer::L; \n    default_interlayers_null_graph::H = SimpleGraph{T}(), \n    default_interlayers_structure::String =\"multiplex\"\n) where {T,U,G<:AbstractGraph{T},M<:AbstractMultilayerUGraph{T,U},L<:Layer{T,U,G}, H <: AbstractGraph{T}}\n\nAdd layer layer to mg.\n\nARGUMENTS\n\nmg::M: the MultilayerGraph which the new layer will be added to;\nnew_layer::L: the new Layer to add to mg;\ndefault_interlayers_null_graph::H = SimpleGraph{T}(): upon addition of a new Layer, all the Interlayers between the new and the existing Layers are immediately created. This keyword argument specifies their null_graph See the Layer constructor for more information. Defaults to SimpleGraph{T}();\ndefault_interlayers_structure::String = \"multiplex\": The structure of the Interlayers created by default. May either be \"multiplex\" to have diagonally-coupled only interlayers, or \"empty\" for empty interlayers. Defaults to \"multiplex\".\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.add_layer!-Union{Tuple{H}, Tuple{L}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, G<:AbstractGraph{T}, M<:AbstractMultilayerDiGraph{T, U}, L<:Layer{T, U, G}, H<:AbstractGraph{T}}","page":"API","title":"MultilayerGraphs.add_layer!","text":"add_layer!(\n    mg::M, \n    new_layer::L; \n    default_interlayers_null_graph::H = SimpleGraph{T}(), \n    default_interlayers_structure::String =\"multiplex\"\n) where {T,U,G<:AbstractGraph{T},M<:AbstractMultilayerDiGraph{T,U},L<:Layer{T,U,G}, H <: AbstractGraph{T}}\n\nAdd layer layer to mg.\n\nARGUMENTS\n\nmg::M: the MultilayerDiGraph which the new layer will be added to;\nnew_layer::L: the new Layer to add to mg;\ndefault_interlayers_null_graph::H: upon addition of a new Layer, all the Interlayers between the new and the existing Layers are immediately created. This keyword argument specifies their null_graph See the Layer constructor for more information. Defaults to SimpleGraph{T}();\ndefault_interlayers_structure::String: The structure of the Interlayers created by default. May either be \"multiplex\" to have diagonally-coupled only interlayers, or \"empty\" for empty interlayers. Defaults to \"multiplex\".\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G<:AbstractGraph{T}, M<:AbstractMultilayerDiGraph{T, U}, In<:Interlayer{T, U, G}}","page":"API","title":"MultilayerGraphs.specify_interlayer!","text":"specify_interlayer!(\n    mg::M,\n    new_interlayer::In\n) where {T,U,G<:AbstractGraph{T},M<:AbstractMultilayerDiGraph{T,U},In<:Interlayer{T,U,G}}\n\nSpecify the interlayer new_interlayer as part of mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G<:AbstractGraph{T}, M<:AbstractMultilayerUGraph{T, U}, In<:Interlayer{T, U, G}}","page":"API","title":"MultilayerGraphs.specify_interlayer!","text":"specify_interlayer!(\n    mg::M,\n    new_interlayer::In\n) where {T,U,G<:AbstractGraph{T},M<:AbstractMultilayerUGraph{T,U},In<:Interlayer{T,U,G}}\n\nSpecify the interlayer new_interlayer as part of mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.get_interlayer-Tuple{AbstractMultilayerGraph, Symbol, Symbol}","page":"API","title":"MultilayerGraphs.get_interlayer","text":"get_interlayer(\n    mg::AbstractMultilayerGraph, layer_1_name::Symbol, \n    layer_2_name::Symbol\n)\n\nReturn the Interlayer between layer_1 and layer_2.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.indegree-Tuple{AbstractMultilayerGraph, MultilayerVertex}","page":"API","title":"Graphs.indegree","text":"indegree( mg::AbstractMultilayerGraph, v::MultilayerVertex)\n\nGet the indegree of vertex v in mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.indegree","page":"API","title":"Graphs.indegree","text":"indegree( mg::M, vs::AbstractVector{V}=vertices(mg)) where {T,M<:AbstractMultilayerGraph{T,<:Real},V<:MultilayerVertex}\n\nGet the vector of indegrees of vertices vs in mg.\n\n\n\n\n\n","category":"function"},{"location":"API/#Graphs.outdegree-Tuple{AbstractMultilayerGraph, MultilayerVertex}","page":"API","title":"Graphs.outdegree","text":"outdegree(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\n\nGet the outdegree of vertex v in mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.outdegree","page":"API","title":"Graphs.outdegree","text":"outdegree(mg::M, vs::AbstractVector{V}=vertices(mg)) where {T,M<:AbstractMultilayerGraph{T,<:Real},V<:MultilayerVertex}\n\nGet the vector of outdegrees of vertices vs in mg.\n\n\n\n\n\n","category":"function"},{"location":"API/#Graphs.degree","page":"API","title":"Graphs.degree","text":"degree(mg::AbstractMultilayerGraph, vs::AbstractVector{<:MultilayerVertex}=vertices(mg))\n\nGet the degree of vertices vs in mg.\n\n\n\n\n\n","category":"function"},{"location":"API/#MultilayerGraphs.mean_degree-Tuple{AbstractMultilayerGraph}","page":"API","title":"MultilayerGraphs.mean_degree","text":"mean_degree(mg::AbstractMultilayerGraph)\n\nReturn the mean of the degree sequence of mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.degree_second_moment-Tuple{AbstractMultilayerGraph}","page":"API","title":"MultilayerGraphs.degree_second_moment","text":"degree_second_moment(mg::AbstractMultilayerGraph)\n\nCalculate the second moment of the degree sequence of mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.degree_variance-Tuple{AbstractMultilayerGraph}","page":"API","title":"MultilayerGraphs.degree_variance","text":"degree_variance(mg::AbstractMultilayerGraph)\n\nReturn the variance of the degree sequence of mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.weighttype-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M<:AbstractMultilayerGraph{T, U}}","page":"API","title":"MultilayerGraphs.weighttype","text":"weighttype(::M) where {T,U,M<:AbstractMultilayerGraph{T,U}}\n\nReturn the weight type of mg (i.e. the eltype of the weight tensor or the supra-adjacency matrix).\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.multilayer_global_clustering_coefficient","page":"API","title":"MultilayerGraphs.multilayer_global_clustering_coefficient","text":"multilayer_global_clustering_coefficient(\n    mg::AbstractMultilayerGraph, \n    norm_factor::Union{Float64,Symbol}=:max\n)\n\nReturn the complete multilayer global clustering coefficient, equal to the ratio of realized triplets over all possible triplets, including those whose every or some edges belong to interlayers, normalized by norm_factor. If norm_factor == :max, then the ratio is normalized by maximum(array(weight_tensor(mg))), else it is not normalized. This function does not override Graphs.jl's global_clustering_coefficient, since the latter does not consider cliques where two nodes are the same node but in different layers/interlayers. See De Domenico et al. (2013).\n\n\n\n\n\n","category":"function"},{"location":"API/#MultilayerGraphs.overlay_clustering_coefficient","page":"API","title":"MultilayerGraphs.overlay_clustering_coefficient","text":"overlay_clustering_coefficient(\n    mg::AbstractMultilayerGraph, \n    norm_factor::Union{Float64,Symbol}=:max\n)\n\nReturn the overlay clustering coefficient as calculated in De Domenico et al. (2013). If norm_factor == :max, then the ratio is normalized by maximum(array(weight_tensor(mg))), else it is not normalized. \n\n\n\n\n\n","category":"function"},{"location":"API/#Graphs.eigenvector_centrality-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M<:AbstractMultilayerGraph{T, U}}","page":"API","title":"Graphs.eigenvector_centrality","text":"eigenvector_centrality(\n    mg::M;\n    norm::String = \"1\",\n    tol::Float64 = 1e-6,\n    maxiter::Int64 = 2000\n    ) where {T, U, M <: AbstractMultilayerGraph{T, U}}\n\nCalculate the eigenvector centrality of mg via an iterative algorithm. The norm parameter may be \"1\" or \"n\",  and respectively the eigenvector centrality will be normalized to 1 or further divided by the number of nodes of mg. The tol parameter terminates the approximation when two consecutive iteration differ by no more than  tol. The maxiters parameter terminates the algorithm when it goes beyond maxiters iterations.\n\nThe returned values are: the eigenvector centrality and the relative error at each algorithm iteration, that is, the summed absolute values of the componentwise differences between the centrality computed at the current iteration minus the centrality computed at the previous iteration.\n\nNote: in the limit case of a monoplex graph, this function outputs a eigenvector centrality vector that coincides the one outputted by Graphs.jl's eigenvector_centrality.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.modularity-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, Matrix{Int64}}} where {T, U, M<:AbstractMultilayerGraph{T, U}}","page":"API","title":"Graphs.modularity","text":"modularity(\n    mg::M, \n    c::Matrix{Int64}; \n    null_model::Union{String,Array{U,4}} = \"degree\"\n) where {T, U, M <: AbstractMultilayerGraph{T,U}}\n\nCalculate the modularity of mg, as shown in De Domenico et al. (2013).\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.von_neumann_entropy-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M<:AbstractMultilayerUGraph{T, U}}","page":"API","title":"MultilayerGraphs.von_neumann_entropy","text":"von_neumann_entropy(mg::M) where {T,U,  M <: AbstractMultilayerUGraph{T, U}}\n\nCompute the Von Neumann entropy of mg, according to De Domenico et al. (2013). Only for undirected multilayer graphs.\n\n\n\n\n\n","category":"method"},{"location":"API/#representations_eu","page":"API","title":"Representations","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"array(atr::AbstractTensorRepresentation)\nWeightTensor{U}\nweight_tensor(mg::M) where {T,U, M <: AbstractMultilayerGraph{T,U}}\nMetadataTensor{U}\nmetadata_tensor(mg::M) where {T,U, M <: AbstractMultilayerGraph{T,U}}\narray(amr::AbstractMatrixRepresentation)\nSupraWeightMatrix{T,U}\nsupra_weight_matrix(mg::M) where {T,U, M <: AbstractMultilayerGraph{T,U}}","category":"page"},{"location":"API/#MultilayerGraphs.array-Tuple{AbstractTensorRepresentation}","page":"API","title":"MultilayerGraphs.array","text":"array(atr::AbstractTensorRepresentation)\n\nReturn the array representation of atr.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.WeightTensor","page":"API","title":"MultilayerGraphs.WeightTensor","text":"WeightTensor{U}\n\nConcrete type representing the weight tensor of a multilayer graph.  Look at the EXAMPLES section below to learn how to use it.\n\nEXAMPLES\n\n# Assuming a MultilayerGraph named mg is defined, and that mv1 and mv2 are two of its `MultilayerVertex`ss\nwt = WeightTensor(mg)\n# One may access te corresponding WeightTensor's entry via:\nwt[mv1, mv2]\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.weight_tensor-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M<:AbstractMultilayerGraph{T, U}}","page":"API","title":"MultilayerGraphs.weight_tensor","text":"weight_tensor(mg::M) where {T,U, M <: AbstractMultilayerGraph{T,U}}\n\nCompute the weight tensor of mg. Return an object of type WeightTensor.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.MetadataTensor","page":"API","title":"MultilayerGraphs.MetadataTensor","text":"MetadataTensor{U}\n\nConcrete type representing the metadata tensor of a multilayer graph.  Look at the EXAMPLES section below to learn how to use it.\n\nEXAMPLES\n\n# Assuming a MultilayerGraph named mg is defined, and that mv1 and mv2 are two of its `MultilayerVertex`s\nmt = MetadataTensor(mg)\n# One may access te corresponding MetadataTensor's entry via:\nmt[mv1, mv2]\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.metadata_tensor-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M<:AbstractMultilayerGraph{T, U}}","page":"API","title":"MultilayerGraphs.metadata_tensor","text":"metadata_tensor(mg::M) where {T,U, M <: AbstractMultilayerGraph{T,U}}\n\nCompute the weight tensor of mg. Return an object of type WeightTensor.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.array-Tuple{AbstractMatrixRepresentation}","page":"API","title":"MultilayerGraphs.array","text":"array(amr::AbstractMatrixRepresentation)\n\nReturn the array representation of amr.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.SupraWeightMatrix","page":"API","title":"MultilayerGraphs.SupraWeightMatrix","text":"SupraWeightMatrix{T,U}\n\nA concrete type representing the (supra) weight matrix of a multilayer graph. It takes into account missing vertices by default. Look at the EXAMPLES section to learn how to use it.\n\nEXAMPLES\n\n# Assuming a MultilayerGraph named mg is defined, and that mv1 and mv2 are two of its `MultilayerVertex`ss\nswm = SupraWeightMatrix(mg)\n# One may access te corresponding SupraWeightMatrix's entry via:\nswm[mv1, mv2]\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.supra_weight_matrix-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M<:AbstractMultilayerGraph{T, U}}","page":"API","title":"MultilayerGraphs.supra_weight_matrix","text":"supra_weight_matrix(mg::M) where {T,U, M <: AbstractMultilayerGraph{T,U}}\n\nCompute the supra weight matrix of mg. Return an object of type SupraWeightMatrix\n\n\n\n\n\n","category":"method"},{"location":"API/#traits_eu","page":"API","title":"Traits","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"is_weighted(g::G) where { G <: AbstractGraph}\nis_weighted(g::G) where {G<:Type{<:AbstractGraph}}\n\nis_meta(g::G) where {G <: AbstractGraph}\nis_meta(g::G) where {G<:Type{<:AbstractGraph}}","category":"page"},{"location":"API/#MultilayerGraphs.is_weighted-Tuple{G} where G<:AbstractGraph","page":"API","title":"MultilayerGraphs.is_weighted","text":"is_weighted(g::G) where { G <: AbstractGraph}\n\nCheck whether g is weighted.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.is_weighted-Tuple{G} where G<:(Type{<:AbstractGraph})","page":"API","title":"MultilayerGraphs.is_weighted","text":"is_weighted(g::G) where {G<:Type{<:AbstractGraph}}\n\nCheck whether g is weighted.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.is_meta-Tuple{G} where G<:AbstractGraph","page":"API","title":"MultilayerGraphs.is_meta","text":"is_meta(g::G) where {G <: AbstractGraph}\n\nCheck whether g supports edge AND vertex metadata.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.is_meta-Tuple{G} where G<:(Type{<:AbstractGraph})","page":"API","title":"MultilayerGraphs.is_meta","text":"is_meta(g::G) where {G<:Type{<:AbstractGraph}}\n\nCheck whether g supports edge AND vertex metadata.\n\n\n\n\n\n","category":"method"},{"location":"API/#utilities_eu","page":"API","title":"Utilities","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"multilayer_kronecker_delta(dims::NTuple{4,Int64})\nδk{T}\nδk(N::Int64)\nδ_1{T<: Number}\nδ_2{T<:Number}\nδ_3{T<:Number}\nδ_Ω{T}","category":"page"},{"location":"API/#MultilayerGraphs.multilayer_kronecker_delta-Tuple{NTuple{4, Int64}}","page":"API","title":"MultilayerGraphs.multilayer_kronecker_delta","text":"multilayer_kronecker_delta(dims::NTuple{4,Int64})\n\nReturn a 4-dimensional Kronecker delta with size equal to dims.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.δk","page":"API","title":"MultilayerGraphs.δk","text":"mutable struct δk{T} <: AbstractVector{T}\n\nThe Kronecker delta.\n\nFIELDS\n\nN::Int64: the number of dimensions;\nrepresentation::Matrix{Int64}: the matrix representing the Kronecker delta;\nT: the return type when called δk[i,j].\n\nCONSTRUCTORS\n\nδk{T}(N::Int64) where {T <: Number}\n\nInner constructor that only requires N and the eltype.\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.δk-Tuple{Int64}","page":"API","title":"MultilayerGraphs.δk","text":"δk(N::Int64)\n\nOuter constructor that only requires N.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.δ_1","page":"API","title":"MultilayerGraphs.δ_1","text":"struct δ_1{T<: Number}\n\nThe δ_1 from De Domenico et al. (2013). Evaluate it via the notation [i,j].\n\nFIELDS\n\nN:Int64: the dimensionality of δ_1;\nT: the return type.\n\nCONSTRUCTORS\n\nδ_1{T<: Number}(N::Int64)\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.δ_2","page":"API","title":"MultilayerGraphs.δ_2","text":"struct δ_2{T<: Number}\n\nThe δ_2 from De Domenico et al. (2013). Evaluate it via the notation [i,j].\n\nFIELDS\n\nN:Int64: the dimensionality of δ_2;\nT: the return type.\n\nCONSTRUCTORS\n\nδ_2{T<: Number}(N::Int64)\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.δ_3","page":"API","title":"MultilayerGraphs.δ_3","text":"struct δ_3{T<: Number}\n\nThe δ_3 from De Domenico et al. (2013). Evaluate it via the notation [i,j].\n\nFIELDS\n\nN:Int64: the dimensionality of δ_3;\nT: the return type.\n\nCONSTRUCTORS\n\nδ_3{T<: Number}(N::Int64)\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.δ_Ω","page":"API","title":"MultilayerGraphs.δ_Ω","text":"δ_Ω{T} <: AbstractVector{T}\n\nStruct that represents the δ_Ω defined in De Domenico et al. (2013).\n\nFIELDS\n\nδ_1::δ_1{T}: Instance of δ_1;\nδ_2::δ_2{T}: Instance of δ_2;\nδ_3::δ_3{T}: Instance of δ_3;\nN::Int64  : Maximum index (number of layers);\nrepresentation::Array{Int64,4}: Multidimensional-array representation of δ_Ω.\n\n\n\n\n\n","category":"type"},{"location":"API/#Developer","page":"API","title":"Developer","text":"","category":"section"},{"location":"API/#nodes_dev","page":"API","title":"Nodes","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"AbstractNode","category":"page"},{"location":"API/#MultilayerGraphs.AbstractNode","page":"API","title":"MultilayerGraphs.AbstractNode","text":"abstract type AbstractNode\n\nAn abstract type representing a node.\n\n\n\n\n\n","category":"type"},{"location":"API/#vertices_dev","page":"API","title":"Vertices","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"AbstractVertex\nAbstractMultilayerVertex","category":"page"},{"location":"API/#MultilayerGraphs.AbstractVertex","page":"API","title":"MultilayerGraphs.AbstractVertex","text":"abstract type AbstractVertex\n\nAn abstract type for vertices that may not be represented by Integer and for which it may be inappropriate to use a graph with vertex-level metadata.\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.AbstractMultilayerVertex","page":"API","title":"MultilayerGraphs.AbstractMultilayerVertex","text":"AbstractMultilayerVertex{S} <: AbstractVertex\n\nAn abstract type representing an abstract MultilayerGraph vertex.\n\n\n\n\n\n","category":"type"},{"location":"API/#edges_dev","page":"API","title":"Edges","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"AbstractMultilayerEdge\nmetadata(he::MultilayerGraphs.HalfEdge)\nweight(he::MultilayerGraphs.HalfEdge)","category":"page"},{"location":"API/#MultilayerGraphs.AbstractMultilayerEdge","page":"API","title":"MultilayerGraphs.AbstractMultilayerEdge","text":"AbstractMultilayerEdge{T} <: AbstractEdge{T}\n\nAn abstract type representing a MultilayerGraph edge.\n\nIt must have fields: src, dst, weight.\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.metadata-Tuple{MultilayerGraphs.HalfEdge}","page":"API","title":"MultilayerGraphs.metadata","text":"metadata(he::HalfEdge)\n\nReturn the metadata associated to the edge.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.weight-Tuple{MultilayerGraphs.HalfEdge}","page":"API","title":"MultilayerGraphs.weight","text":"weight(he::HalfEdge)\n\nReturn the weight of the edge.\n\n\n\n\n\n","category":"method"},{"location":"API/#subgraphs_dev","page":"API","title":"Subgraphs","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"has_vertex(subgraph::S, v::T ) where {T,S<:AbstractSubGraph{T}}\nvertices(subgraph::AbstractSubGraph)\ninneighbors(subgraph::S, v::T) where {T, S <: AbstractSubGraph{T}}\ninneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\noutneighbors(subgraph::S, v::T) where {T,S<:AbstractSubGraph{T}}\noutneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\nneighbors(subgraph::S, v::T) where {T,S<:AbstractSubGraph{T}}\nneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\nedgetype(::S) where {T,U,S<:AbstractSubGraph{T,U}}\nhas_edge( subgraph::S, s::T, d::T) where {T,S<:AbstractSubGraph{T}}\nadd_edge!(subgraph::S, src::T, dst::T; weight::W = nothing, metadata::Union{Tuple, NamedTuple}= NamedTuple()) where {T, U<: Real, W<:Union{ U, Nothing},G<:AbstractGraph{T},S<:AbstractSubGraph{T,U,G}} \nrem_edge!(subgraph::S, src::T, dst::T) where {T, S<:AbstractSubGraph{T}}\nAbstractLayer\nLayer(descriptor::MultilayerGraphs.LayerDescriptor{T}, vertices::Vector{<: MultilayerVertex}, edge_list::Vector{<:MultilayerEdge}) where {T <: Integer}\nrem_vertex!(layer::L, v::T) where {T, L <: Layer{T}} \nAbstractInterlayer","category":"page"},{"location":"API/#Graphs.has_vertex-Union{Tuple{S}, Tuple{T}, Tuple{S, T}} where {T, S<:(AbstractSubGraph{T, U, G} where {U<:Real, G<:AbstractGraph{T}})}","page":"API","title":"Graphs.has_vertex","text":"has_vertex( subgraph::S, v::T ) where {T,S<:AbstractSubGraph{T}}\n\nReturn true if v is a vertex of subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.vertices-Tuple{AbstractSubGraph}","page":"API","title":"Graphs.vertices","text":"vertices(subgraph::AbstractSubGraph)\n\nReturn the collection of the vertices of subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.inneighbors-Union{Tuple{S}, Tuple{T}, Tuple{S, T}} where {T, S<:(AbstractSubGraph{T, U, G} where {U<:Real, G<:AbstractGraph{T}})}","page":"API","title":"Graphs.inneighbors","text":"inneighbors(subgraph::S, v::T) where {T, S <: AbstractSubGraph{T}}\n\nReturn the list of inneighbors of v within subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.inneighbors-Tuple{AbstractSubGraph, MultilayerVertex}","page":"API","title":"Graphs.inneighbors","text":"inneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\n\nReturn the list of inneighbors of mv within subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.outneighbors-Union{Tuple{S}, Tuple{T}, Tuple{S, T}} where {T, S<:(AbstractSubGraph{T, U, G} where {U<:Real, G<:AbstractGraph{T}})}","page":"API","title":"Graphs.outneighbors","text":"outneighbors(subgraph::S, v::T) where {T,S<:AbstractSubGraph{T}}\n\nReturn the list of outneighbors of v within subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.outneighbors-Tuple{AbstractSubGraph, MultilayerVertex}","page":"API","title":"Graphs.outneighbors","text":"outneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\n\nReturn the list of outneighbors of mv within subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.neighbors-Union{Tuple{S}, Tuple{T}, Tuple{S, T}} where {T, S<:(AbstractSubGraph{T, U, G} where {U<:Real, G<:AbstractGraph{T}})}","page":"API","title":"Graphs.neighbors","text":"neighbors(subgraph::S, v::T) where {T, S <: AbstractSubGraph{T}}\n\nReturn the list of neighbors of v within subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.neighbors-Tuple{AbstractSubGraph, MultilayerVertex}","page":"API","title":"Graphs.neighbors","text":"neighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)\n\nReturn the list of neighbors of mv within subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.edgetype-Union{Tuple{S}, Tuple{U}, Tuple{T}} where {T, U, S<:(AbstractSubGraph{T, U, G} where G<:AbstractGraph{T})}","page":"API","title":"Graphs.edgetype","text":"edgetype(::S) where {T,U,S<:AbstractSubGraph{T,U}}\n\nReturn the edge type for subgraph.\n\n\n\n\n\nedgetype(::M) where {T,U,M<:AbstractMultilayerGraph{T,U}}\n\nReturn the edge type for mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.has_edge-Union{Tuple{S}, Tuple{T}, Tuple{S, T, T}} where {T, S<:(AbstractSubGraph{T, U, G} where {U<:Real, G<:AbstractGraph{T}})}","page":"API","title":"Graphs.has_edge","text":"has_edge( subgraph::S, s::T, d::T) where {T,S<:AbstractSubGraph{T}}\n\nReturn true if there is an edge between s and d, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.add_edge!-Union{Tuple{S}, Tuple{G}, Tuple{W}, Tuple{U}, Tuple{T}, Tuple{S, T, T}} where {T, U<:Real, W<:Union{Nothing, U}, G<:AbstractGraph{T}, S<:AbstractSubGraph{T, U, G}}","page":"API","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(subgraph::S, src::T, dst::T; weight::W = nothing, metadata::Union{Tuple, NamedTuple}= NamedTuple()) where {T, U<: Real, W<:Union{ U, Nothing},S<:AbstractSubGraph{T,U}}\n\nAdd edge from src to dst with weight weight and metadata metadata to subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.rem_edge!-Union{Tuple{S}, Tuple{T}, Tuple{S, T, T}} where {T, S<:(AbstractSubGraph{T, U, G} where {U<:Real, G<:AbstractGraph{T}})}","page":"API","title":"Graphs.SimpleGraphs.rem_edge!","text":"rem_edge!(subgraph::S, src::T, dst::T) where {T, S<:AbstractSubGraph{T}}\n\nRemove edge from src to dst in a directed subgraph.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.AbstractLayer","page":"API","title":"MultilayerGraphs.AbstractLayer","text":"AbstractLayer{T,U,G}\n\nAn abstract type representing a generic Layer.\n\nFIELDS\n\nT: the node type;\nU: the MultilayerEdge weight eltype;\nG: the underlying graph type.\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.Layer-Union{Tuple{T}, Tuple{MultilayerGraphs.LayerDescriptor{T}, Vector{<:MultilayerVertex}, Vector{<:MultilayerEdge}}} where T<:Integer","page":"API","title":"MultilayerGraphs.Layer","text":"Layer(descriptor::LayerDescriptor{T}, vertices::Vector{<: MultilayerVertex}, edge_list::Vector{<:MultilayerEdge}) where {T <: Integer}\n\nConstructor for Layer.\n\nARGUMENTS\n\ndescriptor::LayerDescriptor{T};\nvertices::Vector{<: MultilayerVertex};\nedge_list::Vector{<:MultilayerEdge};\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.SimpleGraphs.rem_vertex!-Union{Tuple{L}, Tuple{T}, Tuple{L, T}} where {T, L<:(Layer{T, U, G} where {U<:Real, G<:AbstractGraph{T}})}","page":"API","title":"Graphs.SimpleGraphs.rem_vertex!","text":"rem_vertex!(layer::L, v::T) where {T, L <: Layer{T}}\n\nRemove vertex v from layer layer.\n\n\n\n\n\n","category":"method"},{"location":"API/#MultilayerGraphs.AbstractInterlayer","page":"API","title":"MultilayerGraphs.AbstractInterlayer","text":"AbstractInterlayer{T,U,G}\n\nAn abstract type representing a generic Interlayer.\n\nPARAMETRIC TYPES\n\nT: the node type;\nU: the adjacency matrix/tensor eltype;\nG: the underlying graph type.\n\n\n\n\n\n","category":"type"},{"location":"API/#msm_dev","page":"API","title":"Multilayer-Specific Methods","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"AbstractMultilayerGraph{T <: Integer, U <: Real}\nhas_vertex(mg::M, v::T) where {T, M <: AbstractMultilayerGraph{T}}\nvertices(mg::AbstractMultilayerGraph)\ninneighbors(mg::M, v::T) where {T,M<:AbstractMultilayerUGraph{T,<:Real}}\ninneighbors(mg::M, v::T) where {T, M<:AbstractMultilayerGraph{T,<:Real}}\ninneighbors(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\noutneighbors(mg::M, v::T) where {T, M<:AbstractMultilayerGraph{T}}\nneighbors(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\nedgetype(::M) where {T,U,M<:AbstractMultilayerGraph{T,U}}\nhas_edge(mg::M, src::T, dst::T) where { T, M <: AbstractMultilayerUGraph{T}}\nhas_edge(mg::M, src::T, dst::T) where { T, M <: AbstractMultilayerDiGraph{T}}\nrem_edge!(mg::M, src::T, dst::T) where {T, M <: AbstractMultilayerGraph{T}\nAbstractMultilayerUGraph{T,U}\nAbstractMultilayerDiGraph{T,U}","category":"page"},{"location":"API/#MultilayerGraphs.AbstractMultilayerGraph","page":"API","title":"MultilayerGraphs.AbstractMultilayerGraph","text":"AbstractMultilayerGraph{T <: Integer, U <: Real} <: AbstractGraph{T}\n\nAn abstract type for multilayer graphs. It is a subtype of AbstractGraph and its concrete subtypes may extend Graphs.jl.\n\n\n\n\n\n","category":"type"},{"location":"API/#Graphs.has_vertex-Union{Tuple{M}, Tuple{T}, Tuple{M, T}} where {T, M<:(AbstractMultilayerGraph{T})}","page":"API","title":"Graphs.has_vertex","text":"has_vertex(mg::M, v::T) where {T,M <: AbstractMultilayerGraph{T}}\n\nReturn true if v is in mg, else false.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.vertices-Tuple{AbstractMultilayerGraph}","page":"API","title":"Graphs.vertices","text":"vertices(mg::M) where {M<:AbstractMultilayerGraph}\n\nReturn the collection of the vertices of mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.inneighbors-Union{Tuple{M}, Tuple{T}, Tuple{M, T}} where {T, M<:(AbstractMultilayerUGraph{T, <:Real})}","page":"API","title":"Graphs.inneighbors","text":"inneighbors(mg::M, v::T) where {T,M<:AbstractMultilayerUGraph{T,<:Real}}\n\nReturn the list of inneighbors of v within mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.inneighbors-Union{Tuple{M}, Tuple{T}, Tuple{M, T}} where {T, M<:(AbstractMultilayerGraph{T})}","page":"API","title":"Graphs.inneighbors","text":"inneighbors(mg::M, v::T\n\n) where {T, M<:AbstractMultilayerGraph{T,<:Real}}\n\nReturn the list of inneighbors of v within mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.inneighbors-Tuple{AbstractMultilayerGraph, MultilayerVertex}","page":"API","title":"Graphs.inneighbors","text":"inneighbors( mg::AbstractMultilayerGraph, mv::MultilayerVertex )\n\nReturn the list of inneighbors of mv within mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.outneighbors-Union{Tuple{M}, Tuple{T}, Tuple{M, T}} where {T, M<:(AbstractMultilayerGraph{T})}","page":"API","title":"Graphs.outneighbors","text":"outneighbors(mg::M, v::T) where {T, M<:AbstractMultilayerGraph{T}}\n\nReturn the list of outneighbors of v within mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.neighbors-Tuple{AbstractMultilayerGraph, MultilayerVertex}","page":"API","title":"Graphs.neighbors","text":"neighbors(mg::AbstractMultilayerGraph, mv::MultilayerVertex)\n\nGet the neighbors of vertex mv in mg. Reduces to outneighbors for both directed and undirected multilayer graphs.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.edgetype-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M<:AbstractMultilayerGraph{T, U}}","page":"API","title":"Graphs.edgetype","text":"edgetype(::S) where {T,U,S<:AbstractSubGraph{T,U}}\n\nReturn the edge type for subgraph.\n\n\n\n\n\nedgetype(::M) where {T,U,M<:AbstractMultilayerGraph{T,U}}\n\nReturn the edge type for mg.\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.has_edge-Union{Tuple{M}, Tuple{T}, Tuple{M, T, T}} where {T, M<:(AbstractMultilayerUGraph{T})}","page":"API","title":"Graphs.has_edge","text":"has_edge(mg::M, src::T, dst::T) where { T, M <: AbstractMultilayerUGraph{T}}\n\nReturn true if mg has edge between the src and dst (does not check edge or vertex metadata).\n\n\n\n\n\n","category":"method"},{"location":"API/#Graphs.has_edge-Union{Tuple{M}, Tuple{T}, Tuple{M, T, T}} where {T, M<:(AbstractMultilayerDiGraph{T})}","page":"API","title":"Graphs.has_edge","text":"has_edge(mg::M, src::T, dst::T) where { T, M <: AbstractMultilayerDiGraph{T}}\n\nReturn true if mg has edge between the src and dst (does not check edge or vertex metadata).\n\n\n\n\n\n","category":"method"},{"location":"API/#representations_dev","page":"API","title":"Representations","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"AbstractTensorRepresentation{U}\nAbstractMatrixRepresentation{T,U}","category":"page"},{"location":"API/#MultilayerGraphs.AbstractTensorRepresentation","page":"API","title":"MultilayerGraphs.AbstractTensorRepresentation","text":"AbstractTensorRepresentation{U}\n\nAn abstract type encoding a generic tensorial representation of the links and metadata of a multilayer graph. \n\nConcrete subtypes must have an array field (a 4-dimensional tensor of eltype U, indexes as [sourcenodeidx, destinationnodeidx, sourcelayeridx, destinationlayeridx ]).\n\nPARAMETRIC TYPES\n\nU: the weight type of the multilayer graph.\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.AbstractMatrixRepresentation","page":"API","title":"MultilayerGraphs.AbstractMatrixRepresentation","text":"AbstractMatrixRepresentation{T,U}\n\nAn abstract type encoding a generic matrix representation of the links and metadata of a multilayer graph. \n\nConcrete subtypes must have an array field (a matrix of eltype U) and a v_V_associations (a Bijection{T, Union{MissingVertex, MultilayerVertex}}).\n\nPARAMETRIC TYPES\n\nT: the type of the internal representation of vertices;\nU: the weight type of the multilayer graph.\n\n\n\n\n\n","category":"type"},{"location":"API/#traits_dev","page":"API","title":"Traits","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"IsWeighted{X}\nIsMeta{X}","category":"page"},{"location":"API/#MultilayerGraphs.IsWeighted","page":"API","title":"MultilayerGraphs.IsWeighted","text":"IsWeighted{X}\n\nTrait that discerns between weighted and unweighted graphs. A graph type should take the IsWeighted trait IF AND ONLY IF it implements the signature add_edge!(src,dst,weight). Otherwise it should not.\n\n\n\n\n\n","category":"type"},{"location":"API/#MultilayerGraphs.IsMeta","page":"API","title":"MultilayerGraphs.IsMeta","text":"IsMeta{X}\n\nTrait that discerns between graphs that sport edge and vertex  metadata.\n\n\n\n\n\n","category":"type"}]
}
