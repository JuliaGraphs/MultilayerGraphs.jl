<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MultilayerGraphs.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://juliagraphs.org/MultilayerGraphs.jl/API/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MultilayerGraphs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MultilayerGraphs.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#End-User"><span>End-User</span></a></li><li><a class="tocitem" href="#Developer"><span>Developer</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/main/docs/src/API.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>This page provides a list of exported methods organized by topic and audience. Methods that act on vertices, edges, and layers are grouped together. Some methods are intended for developers who want to use the <code>Graphs.jl</code> library as part of their code, while others are meant for end-users.</p><h2 id="End-User"><a class="docs-heading-anchor" href="#End-User">End-User</a><a id="End-User-1"></a><a class="docs-heading-anchor-permalink" href="#End-User" title="Permalink"></a></h2><h3 id="nodes_eu"><a class="docs-heading-anchor" href="#nodes_eu">Nodes</a><a id="nodes_eu-1"></a><a class="docs-heading-anchor-permalink" href="#nodes_eu" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Node" href="#MultilayerGraphs.Node"><code>MultilayerGraphs.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Node &lt;: AbstractNode</code></pre><p>A custom concrete type representing a node of a multilayer graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/node.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.id" href="#MultilayerGraphs.id"><code>MultilayerGraphs.id</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">id(n::Node)</code></pre><p>Return the id of <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/node.jl#L17-L21">source</a></section></article><h3 id="vertices_eu"><a class="docs-heading-anchor" href="#vertices_eu">Vertices</a><a id="vertices_eu-1"></a><a class="docs-heading-anchor-permalink" href="#vertices_eu" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.eltype" href="#Base.eltype"><code>Base.eltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.eltype(subgraph::AbstractSubGraph)</code></pre><p>Return the vertex type of <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L17-L21">source</a></section><section><div><pre><code class="nohighlight hljs">eltype(::M) where {T,M&lt;:AbstractMultilayerGraph{T}}</code></pre><p>Return the vertex type of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerVertex" href="#MultilayerGraphs.MultilayerVertex"><code>MultilayerGraphs.MultilayerVertex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultilayerVertex{N &lt;: Integer} &lt;: AbstractMultilayerVertex{N}</code></pre><p>A struct representing a vertex of a MultilayerGraph.</p><p><strong>FIELDS</strong></p><ul><li><code>node::Node</code>: the <code>Node</code> that the <code>MultilayerVertex</code> represents;</li><li><code>layer::Union{Nothing, Symbol}</code>: the name of the <code>Layer</code> the <code>MultilayerVertex</code> lies in;</li><li><code>metadata::Union{&lt;: NamedTuple, &lt;: Tuple}</code>: the metadata associated to this <code>MultilayerVertex</code>.</li></ul><p><strong>CONSTRUCTORS</strong></p><pre><code class="nohighlight hljs">MultilayerVertex(node::Node, layer::Union{Nothing, Symbol},  metadata::Union{&lt;: NamedTuple, &lt;: Tuple})</code></pre><p>Constructs a <code>MultilayerVertex</code> representing <a href="#MultilayerGraphs.Node"><code>Node</code></a> <code>node</code> in <a href="#MultilayerGraphs.Layer"><code>Layer</code></a> with metadata <code>metadata</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/vertices/multilayervertex.jl#L8-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MV" href="#MultilayerGraphs.MV"><code>MultilayerGraphs.MV</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MV</code></pre><p>Alias for <code>MultilayerVertex</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/vertices/multilayervertex.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.node" href="#MultilayerGraphs.node"><code>MultilayerGraphs.node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">node(mv::MultilayerVertex)</code></pre><p>Returns the Node represented by <code>mv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/vertices/multilayervertex.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer" href="#MultilayerGraphs.layer"><code>MultilayerGraphs.layer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer(mv::MultilayerVertex)</code></pre><p>Return the name of the layer which the <code>MultilayerVertex</code> belongs to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/vertices/multilayervertex.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.metadata-Tuple{MultilayerVertex}" href="#MultilayerGraphs.metadata-Tuple{MultilayerVertex}"><code>MultilayerGraphs.metadata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">metadata(mv::MultilayerVertex)</code></pre><p>Return the metadata associated to <code>mv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/vertices/multilayervertex.jl#L101-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MissingVertex" href="#MultilayerGraphs.MissingVertex"><code>MultilayerGraphs.MissingVertex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MissingVertex</code></pre><p>A mutable struct that acts as a placeholder for a vertex that is missing in a Layer. It is mutable so that it may be added more than once to the <code>Bijections</code> struct from Bijections.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/vertices/missingvertex.jl#L1-L5">source</a></section></article><h3 id="edges_eu"><a class="docs-heading-anchor" href="#edges_eu">Edges</a><a id="edges_eu-1"></a><a class="docs-heading-anchor-permalink" href="#edges_eu" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerEdge" href="#MultilayerGraphs.MultilayerEdge"><code>MultilayerGraphs.MultilayerEdge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MultilayerEdge{ T &lt;: MultilayerVertex, U &lt;: Union{ &lt;: Real, Nothing}} &lt;: AbstractMultilayerEdge{T}</code></pre><p>Default concrete subtype of AbstractMultilayerEdge.</p><p><strong>FIELDS</strong></p><ul><li><code>src::T</code>: the source vertex of the edge;</li><li><code>dst::T</code>: the destination vertex of the edge;</li><li><code>weight::U</code>: the edge weight.</li></ul><p><strong>CONSTRUCTORS</strong></p><pre><code class="nohighlight hljs">MultilayerEdge(src::T, dst::T, weight::U) where { T &lt;: MultilayerVertex, U &lt;: Union{ &lt;: Real, Nothing}}</code></pre><p>Default constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/multilayeredge.jl#L10-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.ME" href="#MultilayerGraphs.ME"><code>MultilayerGraphs.ME</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ME</code></pre><p>Shorter alias for MultilayerEdge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/multilayeredge.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimpleWeightedGraphs.weight-Tuple{AbstractMultilayerEdge}" href="#SimpleWeightedGraphs.weight-Tuple{AbstractMultilayerEdge}"><code>SimpleWeightedGraphs.weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weight(e::AbstractMultilayerEdge)</code></pre><p>Return the weight of <code>e</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/multilayeredge.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.metadata-Tuple{AbstractMultilayerEdge}" href="#MultilayerGraphs.metadata-Tuple{AbstractMultilayerEdge}"><code>MultilayerGraphs.metadata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">metadata(e::AbstractMultilayerEdge)</code></pre><p>Return the metadata of <code>e</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/multilayeredge.jl#L95-L99">source</a></section></article><h3 id="subgraphs_eu"><a class="docs-heading-anchor" href="#subgraphs_eu">Subgraphs</a><a id="subgraphs_eu-1"></a><a class="docs-heading-anchor-permalink" href="#subgraphs_eu" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Layer" href="#MultilayerGraphs.Layer"><code>MultilayerGraphs.Layer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Layer{T &lt;: Integer, U &lt;: Real, G &lt;: AbstractGraph{T}} &lt;: AbstractLayer{T,U,G}</code></pre><p>Represents a layer in a <code>Multilayer(Di)Graph</code>. Its type hierarchy is: Layer &lt;: AbstractLayer &lt;: AbstractSubGraph .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Symbol, Union{Vector{MultilayerVertex{nothing}}, Vector{Node}}, Union{Vector{Tuple{MultilayerVertex{nothing}, MultilayerVertex{nothing}}}, Vector{&lt;:MultilayerEdge}}, G, Type{U}}} where {T&lt;:Integer, U&lt;:Real, G&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Symbol, Union{Vector{MultilayerVertex{nothing}}, Vector{Node}}, Union{Vector{Tuple{MultilayerVertex{nothing}, MultilayerVertex{nothing}}}, Vector{&lt;:MultilayerEdge}}, G, Type{U}}} where {T&lt;:Integer, U&lt;:Real, G&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.Layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Layer(
    name::Symbol, 
    vertices::Vector{&lt;: MultilayerVertex}, 
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}, 
    null_graph::G, 
    weighttype::Type{U};  
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_weight::Function = (src, dst) -&gt; one(U), d
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple()) where {T &lt;: Integer, U &lt;: Real,  G &lt;: AbstractGraph{T}}</code></pre><p>Constructor for <code>Layer</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li><li><code>null_graph::G</code>: the Layer&#39;s underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown;</li><li><code>weighttype::Type{U}</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L118-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Symbol, Union{Vector{MultilayerVertex{nothing}}, Vector{Node}}, Int64, G, Type{U}}} where {T&lt;:Integer, U&lt;:Real, G&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Symbol, Union{Vector{MultilayerVertex{nothing}}, Vector{Node}}, Int64, G, Type{U}}} where {T&lt;:Integer, U&lt;:Real, G&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.Layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Layer(
    name::Symbol,
    vertices::Union{V, N},
    ne::Int64,
    null_graph::G,
    weighttype::Type{U};
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_weight::Function = (src, dst) -&gt; nothing,
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    allow_self_loops::Bool = false
) where {T&lt;:Integer,U&lt;:Real,G&lt;:AbstractGraph{T}, V &lt;: Vector{MultilayerVertex{nothing}}, N &lt;: Vector{Node}}</code></pre><p>Return a random <code>Layer</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>vertices::Union{V, N}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>name::Symbol</code>: The name of the Layer</li><li><code>ne::Int64</code>: The number of edges of the Layer</li><li><code>null_graph::G</code>: the Layer&#39;s underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.</li><li><code>weighttype::Type{U}</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted);</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>allow_self_loops::Bool</code>: whether to allow self loops to be generated or not. Defaults to <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L161-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer_simplegraph" href="#MultilayerGraphs.layer_simplegraph"><code>MultilayerGraphs.layer_simplegraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer_simplegraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>SimpleGraph</code> from <code>Graphs.jl</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L539-L557">source</a></section><section><div><pre><code class="nohighlight hljs">layer_simplegraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    degree_distribution::UnivariateDistribution;
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>SimpleGraph</code> from <code>Graphs.jl</code> with a degree sequence sampled from <code>degree_distribution</code>. Realization is performed via the Havel-Hakimi algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>degree_distribution::UnivariateDistribution</code>: The degree distribution from which the degree sequence is sampled ;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L568-L586">source</a></section><section><div><pre><code class="nohighlight hljs">layer_simplegraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    ne::Int64;
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Return a random <code>Layer</code> with <code>ne</code> edges whose underlying graph is a <code>SimpleGraph</code> from <code>Graphs.jl</code> with a degree sequence sampled from <code>degree_distribution</code>. Realization is performed via the Havel-Hakimi algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>ne::Int64</code>: The number of edges of the Layer;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L597-L615">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer_simpledigraph" href="#MultilayerGraphs.layer_simpledigraph"><code>MultilayerGraphs.layer_simpledigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer_simpledigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>SimpleDiGraph</code> from <code>Graphs.jl</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L627-L645">source</a></section><section><div><pre><code class="nohighlight hljs">layer_simpledigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    indegree_distribution::UnivariateDistribution,
    outdegree_distribution::UnivariateDistribution;
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>SimplDiGraph{vertextype}</code> from <code>Graphs.jl</code> with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>indegree_distribution::UnivariateDistribution</code>: The degree distribution from which the indegree sequence is sampled ;</li><li><code>outdegree_distribution::UnivariateDistribution</code>: The degree distribution from which the outdegree sequence is sampled ;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L656-L676">source</a></section><section><div><pre><code class="nohighlight hljs">layer_simpledigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    ne::Int64;
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Return a random <code>Layer</code> with <code>ne</code> edges whose underlying graph is a <code>SimplDiGraph{vertextype}</code> from <code>Graphs.jl</code> with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>ne::Int64</code>: The number of edges of the Layer;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L695-L713">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer_simpleweightedgraph" href="#MultilayerGraphs.layer_simpleweightedgraph"><code>MultilayerGraphs.layer_simpleweightedgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer_simpleweightedgraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};
    default_edge_weight::Function = (src,dst) -&gt; nothing,
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>SimpleWeightedGraph</code> from <code>SimpleWeightedGraphs.jl</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L725-L745">source</a></section><section><div><pre><code class="nohighlight hljs">layer_simpleweightedgraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    degree_distribution::UnivariateDistribution;
    default_edge_weight::Function = (src,dst) -&gt; nothing,
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>SimpleWeightedGraph</code> from <code>SimpleWeightedGraphs.jl</code>. with a degree sequence sampled from <code>degree_distribution</code>. Realization is performed via the Havel-Hakimi algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>degree_distribution::UnivariateDistribution</code>: The degree distribution from which the degree sequence is sampled ;</li><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L764-L784">source</a></section><section><div><pre><code class="nohighlight hljs">layer_simpleweightedgraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    ne::Int64;
    default_edge_weight::Function = (src,dst) -&gt; nothing,
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Return a random <code>Layer</code> with <code>ne</code> edges whose underlying graph is a <code>SimpleWeightedGraph</code> from <code>SimpleWeightedGraphs.jl</code>. with a degree sequence sampled from <code>degree_distribution</code>. Realization is performed via the Havel-Hakimi algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>ne::Int64</code>: The number of edges of the Layer;</li><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L803-L823">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer_simpleweighteddigraph" href="#MultilayerGraphs.layer_simpleweighteddigraph"><code>MultilayerGraphs.layer_simpleweighteddigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer_simpleweighteddigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};
    default_edge_weight::Function = (src,dst) -&gt; nothing,
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>SimpleWeightedDiGraph</code> from <code>SimpleWeightedGraphs.jl</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L843-L863">source</a></section><section><div><pre><code class="nohighlight hljs">layer_simpleweighteddigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    indegree_distribution::UnivariateDistribution,
    outdegree_distribution::UnivariateDistribution;
    default_edge_weight::Function = (src,dst) -&gt; nothing,
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>SimpleWeightedDiGraph</code> from <code>SimpleWeightedGraphs.jl</code>, with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>indegree_distribution::UnivariateDistribution</code>: The degree distribution from which the indegree sequence is sampled ;</li><li><code>outdegree_distribution::UnivariateDistribution</code>: The degree distribution from which the outdegree sequence is sampled ;</li><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L882-L904">source</a></section><section><div><pre><code class="nohighlight hljs">layer_simpleweighteddigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    ne::Int64;
    default_edge_weight::Function = (src,dst) -&gt; nothing,
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Return a random <code>Layer</code> with <code>ne</code> edges whose underlying graph is a <code>SimpleWeightedDiGraph</code> from <code>SimpleWeightedGraphs.jl</code>, with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>ne::Int64</code>: The number of edges of the Layer;</li><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L925-L944">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer_metadigraph" href="#MultilayerGraphs.layer_metadigraph"><code>MultilayerGraphs.layer_metadigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer_metadigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>MetaDiGraph</code> from <code>MetaGraphs.jl</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1105-L1130">source</a></section><section><div><pre><code class="nohighlight hljs">layer_metadigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    indegree_distribution::UnivariateDistribution,
    outdegree_distribution::UnivariateDistribution;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>MetaDiGraph</code> from <code>MetaDiGraphs.jl</code> with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>indegree_distribution::UnivariateDistribution</code>: The degree distribution from which the indegree sequence is sampled ;</li><li><code>outdegree_distribution::UnivariateDistribution</code>: The degree distribution from which the outdegree sequence is sampled ;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1151-L1179">source</a></section><section><div><pre><code class="nohighlight hljs">layer_metadigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    ne::Int64;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Return a random <code>Layer</code> with <code>ne</code> edges whose underlying graph is a <code>MetaDiGraph</code> from <code>MetaDiGraphs.jl</code> with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>ne::Int64</code>: The number of edges of the Layer;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1202-L1228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer_valgraph" href="#MultilayerGraphs.layer_valgraph"><code>MultilayerGraphs.layer_valgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer_valgraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>ValGraph</code> from <code>SimpleValueGraphs.jl</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1250-L1275">source</a></section><section><div><pre><code class="nohighlight hljs">layer_valgraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    degree_distribution::UnivariateDistribution;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>ValGraph</code> from <code>SimpleValueGraphs.jl</code>. with a degree sequence sampled from <code>degree_distribution</code>. Realization is performed via the Havel-Hakimi algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>degree_distribution::UnivariateDistribution</code>: The degree distribution from which the degree sequence is sampled ;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1327-L1353">source</a></section><section><div><pre><code class="nohighlight hljs">layer_valgraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    ne::Int64;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Return a random <code>Layer</code> with <code>ne</code> edges whose underlying graph is a <code>ValGraph</code> from <code>SimpleValueGraphs.jl</code>. with a degree sequence sampled from <code>degree_distribution</code>. Realization is performed via the Havel-Hakimi algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>ne::Int64</code>: The number of edges of the Layer;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1385-L1411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer_valoutdigraph" href="#MultilayerGraphs.layer_valoutdigraph"><code>MultilayerGraphs.layer_valoutdigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer_valoutdigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>ValOutDiGraph</code> from <code>SimpleValueGraphs.jl</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1444-L1469">source</a></section><section><div><pre><code class="nohighlight hljs">layer_valoutdigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    indegree_distribution::UnivariateDistribution,
    outdegree_distribution::UnivariateDistribution;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>ValOutDiGraph</code> from <code>SimpleValueGraphs.jl</code> with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>indegree_distribution::UnivariateDistribution</code>: The degree distribution from which the indegree sequence is sampled ;</li><li><code>outdegree_distribution::UnivariateDistribution</code>: The degree distribution from which the outdegree sequence is sampled ;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>. Do not type this function&#39;s arguments;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>,  Do not type this function&#39;s arguments;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1501-L1528">source</a></section><section><div><pre><code class="nohighlight hljs">layer_valoutdigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    ne::Int64;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Return a random <code>Layer</code> with <code>ne</code> edges whose underlying graph is a <code>ValOutDiGraph</code> from <code>SimpleValueGraphs.jl</code> with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>ne::Int64</code>: The number of edges of the Layer;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>. Do not type this function&#39;s arguments;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>,  Do not type this function&#39;s arguments;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1562-L1587">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer_valdigraph" href="#MultilayerGraphs.layer_valdigraph"><code>MultilayerGraphs.layer_valdigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer_valdigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>ValDiGraph</code> from <code>SimpleValueGraphs.jl</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1620-L1645">source</a></section><section><div><pre><code class="nohighlight hljs">layer_valdigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    indegree_distribution::UnivariateDistribution,
    outdegree_distribution::UnivariateDistribution;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>ValDiGraph</code> from <code>SimpleValueGraphs.jl</code> with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>indegree_distribution::UnivariateDistribution</code>: The degree distribution from which the indegree sequence is sampled ;</li><li><code>outdegree_distribution::UnivariateDistribution</code>: The degree distribution from which the outdegree sequence is sampled ;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>. Do not type this function&#39;s arguments;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>,  Do not type this function&#39;s arguments;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1677-L1704">source</a></section><section><div><pre><code class="nohighlight hljs">layer_valdigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    ne::Int64;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Return a random <code>Layer</code> with <code>ne</code> edges whose underlying graph is a <code>ValDiGraph</code> from <code>SimpleValueGraphs.jl</code> with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>ne::Int64</code>: The number of edges of the Layer;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>. Do not type this function&#39;s arguments;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>,  Do not type this function&#39;s arguments;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1738-L1763">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer_metagraph" href="#MultilayerGraphs.layer_metagraph"><code>MultilayerGraphs.layer_metagraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer_metagraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>MetaGraph</code> from <code>MetaGraphs.jl</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L964-L989">source</a></section><section><div><pre><code class="nohighlight hljs">layer_metagraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    degree_distribution::UnivariateDistribution;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>MetaGraph</code> from <code>MetaGraphs.jl</code> with a degree sequence sampled from <code>degree_distribution</code>. Realization is performed via the Havel-Hakimi algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>degree_distribution::UnivariateDistribution</code>: The degree distribution from which the degree sequence is sampled ;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1010-L1036">source</a></section><section><div><pre><code class="nohighlight hljs">layer_metagraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    ne::Int64;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Return a random <code>Layer</code> with <code>ne</code> edges whose underlying graph is a <code>MetaGraph</code> from <code>MetaGraphs.jl</code> with a degree sequence sampled from <code>degree_distribution</code>. Realization is performed via the Havel-Hakimi algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>ne::Int64</code>: The number of edges of the Layer;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1057-L1083">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.has_node-Tuple{Layer, Node}" href="#MultilayerGraphs.has_node-Tuple{Layer, Node}"><code>MultilayerGraphs.has_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_node(layer::Layer, n::Node)</code></pre><p>Return <code>true</code> if <code>n</code> is a node of <code>layer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1795-L1799">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_vertex!-Tuple{Layer, MultilayerVertex}" href="#Graphs.SimpleGraphs.add_vertex!-Tuple{Layer, MultilayerVertex}"><code>Graphs.SimpleGraphs.add_vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_vertex!(layer::Layer, mv::MultilayerVertex)</code></pre><p>Add vertex to layer <code>layer</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1813-L1817">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_vertex!-Union{Tuple{L}, Tuple{T}, Tuple{L, Node, Vararg{Any}}} where {T, L&lt;:(Layer{T, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{T}})}" href="#Graphs.SimpleGraphs.add_vertex!-Union{Tuple{L}, Tuple{T}, Tuple{L, Node, Vararg{Any}}} where {T, L&lt;:(Layer{T, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{T}})}"><code>Graphs.SimpleGraphs.add_vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_vertex!(layer::L, n::Node, args...; kwargs...) where {T, L &lt;: Layer{T}}</code></pre><p>Add vertex associated with node <code>n</code> to layer <code>layer</code>. This method supports the uniform and transparent interfaces. See the <a href="@ref">Vertices</a> section of the Tutorial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1825-L1829">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.rem_vertex!-Tuple{Layer, MultilayerVertex}" href="#Graphs.SimpleGraphs.rem_vertex!-Tuple{Layer, MultilayerVertex}"><code>Graphs.SimpleGraphs.rem_vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_vertex!(layer::Layer, mv::MultilayerVertex)</code></pre><p>Remove vertex <code>mv</code> from layer <code>layer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1886-L1890">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.rem_vertex!-Tuple{Layer, Node}" href="#Graphs.SimpleGraphs.rem_vertex!-Tuple{Layer, Node}"><code>Graphs.SimpleGraphs.rem_vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_vertex!(layer::Layer, n::Node)</code></pre><p>Remove node <code>n</code> from <code>layer</code>. Modify <code>layer.v_N_associations</code> according to how <code>rem_vertex!</code> works in <a href="https://juliagraphs.org/Graphs.jl/dev/core_functions/simplegraphs/#Graphs.SimpleGraphs.rem_vertex!-Tuple{Graphs.SimpleGraphs.AbstractSimpleGraph,%20Integer}">Graph.jl</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1896-L1900">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Interlayer" href="#MultilayerGraphs.Interlayer"><code>MultilayerGraphs.Interlayer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Interlayer{T&lt;:Integer,U&lt;:Real,G&lt;:AbstractGraph{T}} &lt;: AbstractInterlayer{T,U,G}</code></pre><p>Represents an interlayer in a <code>Multilayer(Di)Graph</code>. Its type hierarchy is: Interlayer &lt;: AbstractInterlayer &lt;: AbstractSubGraph .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G&lt;:AbstractGraph{T}, Layer{T, U, G} where G&lt;:AbstractGraph{T}, G, Vector{&lt;:MultilayerEdge{&lt;:Union{Nothing, U}}}}} where {T&lt;:Integer, U&lt;:Real, G&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G&lt;:AbstractGraph{T}, Layer{T, U, G} where G&lt;:AbstractGraph{T}, G, Vector{&lt;:MultilayerEdge{&lt;:Union{Nothing, U}}}}} where {T&lt;:Integer, U&lt;:Real, G&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.Interlayer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Interlayer(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    null_graph::G,
    edge_list::Vector{ &lt;: MultilayerEdge{&lt;: Union{U, Nothing}}};
    default_edge_weight::Function = (x,y) -&gt; nothing,
    default_edge_metadata::Function = (x,y) -&gt; NamedTuple(),
    transfer_vertex_metadata::Bool = false,
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Vector{ &lt;: MultilayerEdge{&lt;: Union{U, Nothing}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li><li><code>null_graph::G</code>: the Interlayer&#39;s underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li><li><code>transfer_vertex_metadata::Bool</code>:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don&#39;t support metadata or that pose limitations to it may result in errors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L80-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G&lt;:AbstractGraph{T}, Layer{T, U, G} where G&lt;:AbstractGraph{T}, Int64, G}} where {T&lt;:Integer, U&lt;:(Union{Nothing, var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real), G&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G&lt;:AbstractGraph{T}, Layer{T, U, G} where G&lt;:AbstractGraph{T}, Int64, G}} where {T&lt;:Integer, U&lt;:(Union{Nothing, var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real), G&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.Interlayer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Interlayer(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64,
    null_graph::G;
    default_edge_weight::Function = (x,y) -&gt; nothing,
    default_edge_metadata::Function = (x,y) -&gt; NamedTuple(),
    interlayer_name::Symbol,
    transfer_vertex_metadata::Bool = false
) where {T&lt;:Integer, U &lt;: Union{Nothing, &lt;: Real}, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random <code>Interlayer</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li><li><code>null_graph::G</code>: the Interlayer&#39;s underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li><li><code>transfer_vertex_metadata::Bool</code>:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don&#39;t support metadata or that pose limitations to it may result in errors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L136-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.interlayer_simplegraph" href="#MultilayerGraphs.interlayer_simplegraph"><code>MultilayerGraphs.interlayer_simplegraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interlayer_simplegraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{&lt;:Union{U, Nothing}}}, Vector{ &lt;:Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}};
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer whose underlying graph is a <code>SimpleGraph</code> from <code>Graphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L448-L468">source</a></section><section><div><pre><code class="nohighlight hljs">interlayer_simplegraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64;
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random Interlayer with <code>ne</code> edges whose underlying graph is a <code>SimpleGraph</code> from <code>Graphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L483-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.interlayer_simpleweightedgraph" href="#MultilayerGraphs.interlayer_simpleweightedgraph"><code>MultilayerGraphs.interlayer_simpleweightedgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interlayer_simpleweightedgraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}};
    default_edge_weight::Function=(x, y) -&gt; nothing,
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer whose underlying graph is a <code>SimpleWeightedGraph</code> from <code>SimpleWeightedGraphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L582-L604">source</a></section><section><div><pre><code class="nohighlight hljs">interlayer_simpleweightedgraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64;
    default_edge_weight::Function=(x, y) -&gt; nothing,
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random Interlayer with <code>ne</code> edges whose underlying graph is a <code>SimpleWeightedGraph</code> from <code>SimpleWeightedGraphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L625-L647">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.interlayer_metagraph" href="#MultilayerGraphs.interlayer_metagraph"><code>MultilayerGraphs.interlayer_metagraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interlayer_metagraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}};
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple(),
    transfer_vertex_metadata::Bool=false,
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer whose underlying graph is a <code>MetaGraph</code> from <code>MetaGraphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>transfer_vertex_metadata::Bool</code>:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don&#39;t support metadata or that pose limitations to it may result in errors;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L748-L772">source</a></section><section><div><pre><code class="nohighlight hljs">interlayer_metagraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64;
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple(),
    transfer_vertex_metadata::Bool=false,
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random Interlayer with <code>ne</code> edges whose underlying graph is a <code>MetaGraph</code> from <code>MetaGraphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>transfer_vertex_metadata::Bool</code>:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don&#39;t support metadata or that pose limitations to it may result in errors;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L795-L819">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.interlayer_valgraph" href="#MultilayerGraphs.interlayer_valgraph"><code>MultilayerGraphs.interlayer_valgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interlayer_valgraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}};
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple()
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer whose underlying graph is a <code>ValGraph</code> from <code>SimpleValueGraphs.jl</code>, with vertex type <code>T</code>. By default, <code>transfer_vertex_metadata</code> is set to <code>false</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L930-L952">source</a></section><section><div><pre><code class="nohighlight hljs">interlayer_valgraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64;
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple()
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random Interlayer with <code>ne</code> edges whose underlying graph is a <code>ValGraph</code> from <code>SimpleValueGraphs.jl</code>, with vertex type <code>T</code>. By default, <code>transfer_vertex_metadata</code> is set to <code>false</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L979-L1001">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.interlayer_simpledigraph" href="#MultilayerGraphs.interlayer_simpledigraph"><code>MultilayerGraphs.interlayer_simpledigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interlayer_simpledigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}};
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer whose underlying graph is a <code>SimpleDiGraph</code> from <code>Graphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L515-L535">source</a></section><section><div><pre><code class="nohighlight hljs">interlayer_simpledigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64;
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random Interlayer with <code>ne</code> edges whose underlying graph is a <code>SimpleDiGraph</code> from <code>Graphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L550-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.interlayer_simpleweighteddigraph" href="#MultilayerGraphs.interlayer_simpleweighteddigraph"><code>MultilayerGraphs.interlayer_simpleweighteddigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interlayer_simpleweighteddigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}};
    default_edge_weight::Function=(x, y) -&gt; nothing,
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer whose underlying graph is a <code>SimpleWeightedDiGraph</code> from <code>SimpleWeightedGraphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L665-L687">source</a></section><section><div><pre><code class="nohighlight hljs">interlayer_simpleweighteddigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64;
    default_edge_weight::Function=(x, y) -&gt; nothing,
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random Interlayer with <code>ne</code> edges underlying graph is a <code>SimpleWeightedDiGraph</code> from <code>SimpleWeightedGraphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L708-L730">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.interlayer_metadigraph" href="#MultilayerGraphs.interlayer_metadigraph"><code>MultilayerGraphs.interlayer_metadigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interlayer_metadigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}};
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple(),
    transfer_vertex_metadata::Bool=false,
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer whose underlying graph is a <code>MetaDiGraph</code> from <code>MetaGraphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>transfer_vertex_metadata::Bool</code>:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don&#39;t support metadata or that pose limitations to it may result in errors;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L839-L863">source</a></section><section><div><pre><code class="nohighlight hljs">interlayer_metadigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64;
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple(),
    transfer_vertex_metadata::Bool=false,
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random Interlayer with <code>ne</code> edges whose underlying graph is a <code>MetaDiGraph</code> from <code>MetaGraphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>transfer_vertex_metadata::Bool</code>:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don&#39;t support metadata or that pose limitations to it may result in errors;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L886-L910">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.interlayer_valoutdigraph" href="#MultilayerGraphs.interlayer_valoutdigraph"><code>MultilayerGraphs.interlayer_valoutdigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interlayer_valoutdigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}};
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple()
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer whose underlying graph is a <code>ValOutDiGraph</code> from <code>SimpleValueGraphs.jl</code>, with vertex type <code>T</code>. By default, <code>transfer_vertex_metadata</code> is set to <code>false</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L1025-L1047">source</a></section><section><div><pre><code class="nohighlight hljs">interlayer_valoutdigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64;
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple()
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random Interlayer with <code>ne</code> edges whose underlying graph is a <code>ValOutDiGraph</code> from <code>SimpleValueGraphs.jl</code>, with vertex type <code>T</code>. By default, <code>transfer_vertex_metadata</code> is set to <code>false</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L1074-L1096">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.interlayer_valdigraph" href="#MultilayerGraphs.interlayer_valdigraph"><code>MultilayerGraphs.interlayer_valdigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interlayer_valdigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}};
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple()
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer whose underlying graph is a <code>ValDiGraph</code> from <code>SimpleValueGraphs.jl</code>, with vertex type <code>T</code>. By default, <code>transfer_vertex_metadata</code> is set to <code>false</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L1120-L1142">source</a></section><section><div><pre><code class="nohighlight hljs">interlayer_valdigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64;
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple()
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random Interlayer with <code>ne</code> edges whose underlying graph is a <code>ValDiGraph</code> from <code>SimpleValueGraphs.jl</code>, with vertex type <code>T</code>. By default, <code>transfer_vertex_metadata</code> is set to <code>false</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L1169-L1191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.multiplex_interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G&lt;:AbstractGraph{T}, Layer{T, U, G} where G&lt;:AbstractGraph{T}, G}} where {T&lt;:Integer, U&lt;:Real, G&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.multiplex_interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G&lt;:AbstractGraph{T}, Layer{T, U, G} where G&lt;:AbstractGraph{T}, G}} where {T&lt;:Integer, U&lt;:Real, G&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.multiplex_interlayer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multiplex_interlayer(
    nv::Int64,
    interlayer_name::Symbol,
    layer_1::Symbol, 
    layer_2::Symbol, 
    graph_type::Type{G}; 
    forbidden_vertices::Vector{MultilayerVertex}, forbidden_edges::Vector{NTuple{2, MultilayerVertex}}
) where {T &lt;: Union{ &lt;: Integer, AbstractVertex}, G &lt;: AbstractGraph{T}}</code></pre><p>Return an <code>Interlayer{T,U,G}</code> that has edges only between vertices that represent the same node.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>null_graph::G</code>: the Interlayer&#39;s underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li><li><code>transfer_vertex_metadata::Bool</code>:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don&#39;t support metadata or that pose limitations to it may result in errors;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L250-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.empty_interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G&lt;:AbstractGraph{T}, Layer{T, U, G} where G&lt;:AbstractGraph{T}, G}} where {T&lt;:Integer, U&lt;:Real, G&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.empty_interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G&lt;:AbstractGraph{T}, Layer{T, U, G} where G&lt;:AbstractGraph{T}, G}} where {T&lt;:Integer, U&lt;:Real, G&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.empty_interlayer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">empty_interlayer(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    null_graph::G;
    default_edge_weight::Function = (x,y) -&gt; nothing,
    default_edge_metadata::Function = (x,y) -&gt; NamedTuple(),
    interlayer_name::Symbol),
    transfer_vertex_metadata::Bool = false
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Construct an empty interlayer (i.e. an interlayer with no edges).</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>null_graph::G</code>: the Interlayer&#39;s underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li><li><code>transfer_vertex_metadata::Bool</code>:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don&#39;t support metadata or that pose limitations to it may result in errors;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L362-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.nodes-Tuple{AbstractSubGraph}" href="#MultilayerGraphs.nodes-Tuple{AbstractSubGraph}"><code>MultilayerGraphs.nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nodes(subgraph::AbstractSubGraph)</code></pre><p>Return the collection of the nodes of <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_vertex-Tuple{Layer, MultilayerVertex}" href="#Graphs.has_vertex-Tuple{Layer, MultilayerVertex}"><code>Graphs.has_vertex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_vertex(layer::Layer, mv::MultilayerVertex)</code></pre><p>Return <code>true</code> if <code>v</code> is a vertex of <code>layer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1802-L1806">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_vertex-Tuple{Interlayer, MultilayerVertex}" href="#Graphs.has_vertex-Tuple{Interlayer, MultilayerVertex}"><code>Graphs.has_vertex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_vertex(interlayer::Interlayer, v::MultilayerVertex)</code></pre><p>Return <code>true</code> if <code>v</code> is a vertex of <code>interlayer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L1280-L1284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.nv-Tuple{AbstractSubGraph}" href="#Graphs.nv-Tuple{AbstractSubGraph}"><code>Graphs.nv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nv(subgraph::AbstractSubGraph)</code></pre><p>Return the number of vertices in <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.mv_vertices-Tuple{AbstractSubGraph}" href="#MultilayerGraphs.mv_vertices-Tuple{AbstractSubGraph}"><code>MultilayerGraphs.mv_vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mv_vertices(subgraph::AbstractSubGraph)</code></pre><p>Return the collection of the <code>MultilayerVertex</code>s of <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.mv_inneighbors-Tuple{AbstractSubGraph, MultilayerVertex}" href="#MultilayerGraphs.mv_inneighbors-Tuple{AbstractSubGraph, MultilayerVertex}"><code>MultilayerGraphs.mv_inneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mv_inneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)</code></pre><p>Return the <code>MultilayerVertex</code>s inneighbors of <code>mv</code> within <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.mv_outneighbors-Tuple{AbstractSubGraph, MultilayerVertex}" href="#MultilayerGraphs.mv_outneighbors-Tuple{AbstractSubGraph, MultilayerVertex}"><code>MultilayerGraphs.mv_outneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mv_outneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)</code></pre><p>Return the <code>MultilayerVertex</code>s outneighbors of <code>mv</code> within <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.mv_neighbors-Tuple{AbstractSubGraph, MultilayerVertex}" href="#MultilayerGraphs.mv_neighbors-Tuple{AbstractSubGraph, MultilayerVertex}"><code>MultilayerGraphs.mv_neighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mv_neighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)</code></pre><p>Defaults to <a href="#MultilayerGraphs.mv_outneighbors-Tuple{AbstractSubGraph, MultilayerVertex}"><code>mv_outneighbors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_edge-Tuple{AbstractSubGraph, MultilayerEdge}" href="#Graphs.has_edge-Tuple{AbstractSubGraph, MultilayerEdge}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_edge(subgraph::AbstractSubGraph,me::MultilayerEdge)</code></pre><p>Return <code>true</code> if there is an edge from <code>src(me)</code> to <code>dst(me)</code> within subgraph, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L215-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_edge-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}" href="#Graphs.has_edge-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_edge( subgraph::AbstractSubGraph, s::MultilayerVertex, d::MultilayerVertex)</code></pre><p>Return <code>true</code> if there is an edge between <code>s</code> and <code>d</code>, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L224-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_edge-Tuple{Layer, MultilayerVertex{nothing}, MultilayerVertex{nothing}}" href="#Graphs.has_edge-Tuple{Layer, MultilayerVertex{nothing}, MultilayerVertex{nothing}}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_edge( layer::Layer, s::MultilayerVertex{nothing}, d::MultilayerVertex{nothing})</code></pre><p>Return <code>true</code> if there is an edge between <code>s</code> and <code>d</code>, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1951-L1955">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.ne-Tuple{AbstractSubGraph}" href="#Graphs.ne-Tuple{AbstractSubGraph}"><code>Graphs.ne</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ne(subgraph::AbstractSubGraph)</code></pre><p>Return the number of edges in <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L244-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.edges-Union{Tuple{S}, Tuple{U}, Tuple{T}} where {T, U, S&lt;:(AbstractSubGraph{T, U, G} where G&lt;:AbstractGraph{T})}" href="#Graphs.edges-Union{Tuple{S}, Tuple{U}, Tuple{T}} where {T, U, S&lt;:(AbstractSubGraph{T, U, G} where G&lt;:AbstractGraph{T})}"><code>Graphs.edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edges(subgraph::S) where {T,U,S&lt;:AbstractSubGraph{T,U}}</code></pre><p>Return an iterator over all the edges of <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L251-L255">source</a></section><section><div><pre><code class="nohighlight hljs">edges(mg::M) where {T,U,M&lt;:AbstractMultilayerUGraph{T,U}}</code></pre><p>Return an list of all the edges of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerugraph.jl#L116-L120">source</a></section><section><div><pre><code class="nohighlight hljs">edges(mg::M) where {T,U,M&lt;:AbstractMultilayerDiGraph{T,U}}</code></pre><p>Return an list of all the edges of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerdigraph.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{S}, Tuple{U}, Tuple{T}, Tuple{S, E}} where {T, U&lt;:Real, S&lt;:(AbstractSubGraph{T, U, G} where G&lt;:AbstractGraph{T}), E&lt;:(MultilayerEdge{&lt;:Union{Nothing, U}})}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{S}, Tuple{U}, Tuple{T}, Tuple{S, E}} where {T, U&lt;:Real, S&lt;:(AbstractSubGraph{T, U, G} where G&lt;:AbstractGraph{T}), E&lt;:(MultilayerEdge{&lt;:Union{Nothing, U}})}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!( subgraph::S, me::E) where {T,U&lt;:Real,S&lt;:AbstractSubGraph{T,U},E&lt;:MultilayerEdge{ &lt;: Union{U, Nothing}}}</code></pre><p>Add unweighted edge <code>me</code> to <code>subgraph</code>. Its <code>weight</code> and <code>metadata</code> fields are passed to the uniform interface of <a href="#Graphs.SimpleGraphs.add_edge!-Tuple{Layer, MultilayerVertex, MultilayerVertex, Vararg{Any}}"><code>add_edge!(::Layer, ::MultilayerVertex, ::MultilayerVertex, ::Tuple)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L264-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Tuple{Layer, MultilayerVertex, MultilayerVertex, Vararg{Any}}" href="#Graphs.SimpleGraphs.add_edge!-Tuple{Layer, MultilayerVertex, MultilayerVertex, Vararg{Any}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(layer::L, src::MultilayerVertex, dst::MultilayerVertex, args...; kwargs...) where {L &lt;: Layer}</code></pre><p>Add edge from vertex <code>src</code> to vertex <code>dst</code> to layer <code>layer</code>. Returns true if succeeds. This method supports the uniform and transparent interfaces. See the <a href="@ref edges_tut_subg">Edges</a> section of the Tutorial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1966-L1970">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Tuple{Interlayer, MultilayerVertex, MultilayerVertex, Vararg{Any}}" href="#Graphs.SimpleGraphs.add_edge!-Tuple{Interlayer, MultilayerVertex, MultilayerVertex, Vararg{Any}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(interlayer::Interlayer, src::MultilayerVertex, dst::MultilayerVertex, args...; kwargs...)</code></pre><p>Add edge from vertex <code>src</code> to vertex <code>dst</code> to Interlayer <code>interlayer</code>.Returns true if succeeds, but will fail (return false) if <code>src</code> and <code>dst</code> belong to the same layer, since interlayers are always bipartite. This method supports the uniform and transparent interfaces. See the <a href="@ref edges_tut_subg">Edges</a> section of the Tutorial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L1289-L1293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.rem_edge!-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}" href="#Graphs.SimpleGraphs.rem_edge!-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}"><code>Graphs.SimpleGraphs.rem_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_edge!(subgraph::AbstractSubGraph, src::MultilayerVertex, dst::MultilayerVertex)</code></pre><p>Remove edge from <code>src</code> to <code>dst</code> in <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L312-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.rem_edge!-Tuple{AbstractSubGraph, MultilayerEdge}" href="#Graphs.SimpleGraphs.rem_edge!-Tuple{AbstractSubGraph, MultilayerEdge}"><code>Graphs.SimpleGraphs.rem_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_edge!(subgraph::AbstractSubGraph, me::MultilayerEdge)</code></pre><p>Remove edge from <code>src(me)</code> to <code>dst(me)</code> in <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L323-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_metadata-Tuple{AbstractSubGraph, MultilayerVertex}" href="#MultilayerGraphs.get_metadata-Tuple{AbstractSubGraph, MultilayerVertex}"><code>MultilayerGraphs.get_metadata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_metadata(subgraph::AbstractSubGraph, bare_mv::MultilayerVertex)</code></pre><p>Return the metadata of the vertex <code>bare_mv</code> in <code>subgraph</code> (metadata assigned to <code>bare_mv</code> will be discarded). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L198-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_metadata-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}" href="#MultilayerGraphs.get_metadata-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}"><code>MultilayerGraphs.get_metadata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_edge_metadata(subgraph::S, src::MultilayerVertex, dst::MultilayerVertex)</code></pre><p>Return the metadata of the edge between the source vertex <code>src</code> and the destination vertex <code>dst</code> in <code>subgraph</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L354-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimpleWeightedGraphs.get_weight-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}" href="#SimpleWeightedGraphs.get_weight-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}"><code>SimpleWeightedGraphs.get_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_weight(subgraph::S, src::MultilayerVertex, dst::MultilayerVertex)</code></pre><p>Return the weight of the edge between the source vertex <code>src</code> and the destination vertex <code>dst</code> in <code>subgraph</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L365-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_directed-Tuple{AbstractSubGraph}" href="#Graphs.is_directed-Tuple{AbstractSubGraph}"><code>Graphs.is_directed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_directed(subgraph::AbstractSubGraph)</code></pre><p>Return <code>true</code> if <code>subgraph</code> is directed, <code>false</code> otherwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L377-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_directed-Union{Tuple{Type{S}}, Tuple{S}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, S&lt;:AbstractSubGraph{T, U, G}}" href="#Graphs.is_directed-Union{Tuple{Type{S}}, Tuple{S}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, S&lt;:AbstractSubGraph{T, U, G}}"><code>Graphs.is_directed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_directed(::Type{S}) where {T,U,G,S &lt;: AbstractSubGraph{T,U,G}}</code></pre><p>Return <code>true</code> if instances of <code>S</code> are directed, <code>false</code> otherwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L384-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.LinAlg.adjacency_matrix-Tuple{AbstractSubGraph}" href="#Graphs.LinAlg.adjacency_matrix-Tuple{AbstractSubGraph}"><code>Graphs.LinAlg.adjacency_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adjacency_matrix(subgraph::AbstractSubGraph)</code></pre><p>Return the adjacency matrix of <code>subgraph.graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L391-L395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.weights-Union{Tuple{S}, Tuple{U}, Tuple{T}} where {T, U, S&lt;:(AbstractSubGraph{T, U, G} where G&lt;:AbstractGraph{T})}" href="#Graphs.weights-Union{Tuple{S}, Tuple{U}, Tuple{T}} where {T, U, S&lt;:(AbstractSubGraph{T, U, G} where G&lt;:AbstractGraph{T})}"><code>Graphs.weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weights(subgraph::S) where { T,U, G &lt;: AbstractGraph{T}, S &lt;:AbstractSubGraph{T,U,G}}</code></pre><p>Return the weights of <code>subgraph.graph</code>, with the eltype converted to <code>U</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L398-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.is_multiplex_interlayer-Tuple{Interlayer}" href="#MultilayerGraphs.is_multiplex_interlayer-Tuple{Interlayer}"><code>MultilayerGraphs.is_multiplex_interlayer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_multiplex_interlayer(interlayer::In) where {In &lt;: Interlayer}</code></pre><p>Check that Interlayer <code>interlayer</code> is a multiplex-type Interlayer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L1242-L1246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_symmetric_interlayer-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, In&lt;:Interlayer{T, U, G}}" href="#MultilayerGraphs.get_symmetric_interlayer-Union{Tuple{In}, Tuple{G}, Tuple{U}, Tuple{T}} where {T, U, G, In&lt;:Interlayer{T, U, G}}"><code>MultilayerGraphs.get_symmetric_interlayer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_symmetric_interlayer(interlayer::In; symmetric_interlayer_name::String) where{T,U,G, In &lt;: Interlayer{T,U,G}}</code></pre><p>Return the <code>Interlayer</code> corresponding to <code>interlayer</code> where <code>layer_1</code> and <code>layer_2</code> are swapped. Its interlayer<em>name will be `symmetric</em>interlayer<em>name<code>(defaults to</code>interlayer</em>(interlayer.layer<em>2)</em>(interlayer.layer_1)`).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L1399-L1403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.name-Tuple{AbstractSubGraph}" href="#MultilayerGraphs.name-Tuple{AbstractSubGraph}"><code>MultilayerGraphs.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">name(subgraph::AbstractSubGraph)</code></pre><p>Return the name of <code>subgraph</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L425-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.graph-Tuple{AbstractSubGraph}" href="#MultilayerGraphs.graph-Tuple{AbstractSubGraph}"><code>MultilayerGraphs.graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">name(subgraph::AbstractSubGraph)</code></pre><p>Return the underlying graph of <code>subgraph</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L432-L436">source</a></section></article><h3 id="msm_eu"><a class="docs-heading-anchor" href="#msm_eu">Multilayer-Specific Methods</a><a id="msm_eu-1"></a><a class="docs-heading-anchor-permalink" href="#msm_eu" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerGraph" href="#MultilayerGraphs.MultilayerGraph"><code>MultilayerGraphs.MultilayerGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultilayerGraph{T, U, G &lt;: AbstractGraph{T}} &lt;: AbstractMultilayerGraph{T,U}</code></pre><p>A concrete type that can represent a general multilayer graph. Its internal fields aren&#39;t meant to be modified by the user. Please prefer the provided API.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/multilayergraph.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerDiGraph" href="#MultilayerGraphs.MultilayerDiGraph"><code>MultilayerGraphs.MultilayerDiGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultilayerDiGraph{T, U, G &lt;: AbstractGraph{T}} &lt;: AbstractMultilayerGraph{T,U}</code></pre><p>A concrete type that can represent a general multilayer graph. Its internal fields aren&#39;t meant to be modified by the user. Please prefer the provided API.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/multilayerdigraph.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerGraph-Tuple{Type{&lt;:Number}, Type{&lt;:Number}}" href="#MultilayerGraphs.MultilayerGraph-Tuple{Type{&lt;:Number}, Type{&lt;:Number}}"><code>MultilayerGraphs.MultilayerGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerGraph(T::Type{&lt;:Number}, U::Type{&lt;:Number})</code></pre><p>Return a null MultilayerGraph with with vertex type <code>T</code> weighttype <code>U</code>. Use this constructor and then add Layers and Interlayers via the <code>add_layer!</code> and <code>specify_interlayer!</code> methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/multilayergraph.jl#L157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerDiGraph-Tuple{Type{&lt;:Number}, Type{&lt;:Number}}" href="#MultilayerGraphs.MultilayerDiGraph-Tuple{Type{&lt;:Number}, Type{&lt;:Number}}"><code>MultilayerGraphs.MultilayerDiGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerDiGraph(n_nodes::Int64, T::Type{ &lt;: Number}, U::Type{ &lt;: Number} )</code></pre><p>Return a null MultilayerDiGraph with with vertex type <code>T</code> weighttype <code>U</code>. Use this constructor and then add Layers and Interlayers via the <code>add_layer!</code> and <code>specify_interlayer!</code> methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/multilayerdigraph.jl#L173-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:AbstractGraph{T}}}} where {T, U, H&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.MultilayerGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:AbstractGraph{T}}}} where {T, U, H&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.MultilayerGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerGraph(
    layers::Vector{&lt;:Layer{T,U}},
    specified_interlayers::Vector{&lt;:Interlayer{T,U}};
    default_interlayers_null_graph::H = SimpleGraph{T}(),
    default_interlayers_structure::String=&quot;multiplex&quot;,
) where {T,U, H &lt;: AbstractGraph{T}}</code></pre><p>Construct a MultilayerGraph with layers given by <code>layers</code>. The interlayers will be constructed by default according to <code>default_interlayer</code> where only <code>&quot;multiplex&quot;</code> and <code>&quot;empty&quot;</code> are allowed, except for those specified in <code>specified_interlayers</code>. <code>default_interlayer = &quot;multiplex&quot;</code> will imply that unspecified interlayers will have only diagonal couplings, while  <code>default_interlayer = &quot;multiplex&quot;</code> will produced interlayers that have no couplings.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layers::Vector{&lt;:Layer{T,U}}</code>: The (ordered) list of layers the multilayer graph will have;</li><li><code>specified_interlayers::Vector{&lt;:Interlayer{T,U}}</code>: The list of interlayers specified by the user. Note that the user does not need to specify all interlayers, as the unspecified ones will be automatically constructed using the indications given by the <code>default_interlayers_null_graph</code> and <code>default_interlayers_structure</code> keywords;</li><li><code>default_interlayers_null_graph::H = SimpleGraph{T}()</code>: Sets the underlying graph for the interlayers that are to be automatically specified. Defaults to <code>SimpleGraph{T}()</code>. See the <code>Interlayer</code> constructors for more information;</li><li><code>default_interlayers_structure::String = &quot;multiplex&quot;</code>: Sets the structure of the interlayers that are to be automatically specified. May be &quot;multiplex&quot; for diagonally coupled interlayers, or &quot;empty&quot; for empty interlayers (no edges).  &quot;multiplex&quot;. See the <code>Interlayer</code> constructors for more information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/multilayergraph.jl#L20-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerDiGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:AbstractGraph{T}}}} where {T, U, H&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.MultilayerDiGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:AbstractGraph{T}}}} where {T, U, H&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.MultilayerDiGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerDiGraph(
    layers::Vector{&lt;:Layer{T,U}},
    specified_interlayers::Vector{&lt;:Interlayer{T,U}};
    default_interlayers_null_graph::H = SimpleGraph{T}(),
    default_interlayers_structure::String=&quot;multiplex&quot;,
) where {T,U, H &lt;: AbstractGraph{T}}</code></pre><p>Construct a MultilayerDiGraph with layers given by <code>layers</code>. The interlayers will be constructed by default according to <code>default_interlayer</code> where only <code>&quot;multiplex&quot;</code> and <code>&quot;empty&quot;</code> are allowed, except for those specified in <code>specified_interlayers</code>. <code>default_interlayer = &quot;multiplex&quot;</code> will imply that unspecified interlayers will have only diagonal couplings, while  <code>default_interlayer = &quot;multiplex&quot;</code> will produced interlayers that have no couplings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/multilayerdigraph.jl#L22-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:AbstractGraph{T}}, UnivariateDistribution}} where {T&lt;:Integer, U&lt;:Real, H&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.MultilayerGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:AbstractGraph{T}}, UnivariateDistribution}} where {T&lt;:Integer, U&lt;:Real, H&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.MultilayerGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerGraph(
    empty_layers::Vector{&lt;:Layer{T,U}},
    empty_interlayers::Vector{&lt;:Interlayer{T,U}},
    degree_distribution::UnivariateDistribution;
    allow_self_loops::Bool = false,
    default_interlayers_null_graph::H = SimpleGraph{T}(),
) where {T &lt;: Integer, U &lt;: Real, H &lt;: AbstractGraph{T}}</code></pre><p>Return a random MultilayerGraph that has <code>empty_layers</code> as layers and <code>empty_interlayers</code> as specified interlayers. <code>empty_layers</code> and <code>empty_interlayers</code> must respectively be <code>Layer</code>s and <code>Interlayer</code>s with whatever number of vertices but no edges (if any edge is found, an error is thrown). The  degree distribution of the returned random <code>MultilayerGraph</code> is given by <code>degree_distribution</code>, which must have a support that only contains positive numbers for obvious reasons. <code>allow_self_loops = true</code> allows for self loops t be present in the final random MultilayerGraph. <code>default_interlayers_null_graph</code> controls the <code>null_graph</code> argument passed to automatically-generated interlayers. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/multilayergraph.jl#L63-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerDiGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:AbstractGraph{T}}, UnivariateDistribution, UnivariateDistribution}} where {T&lt;:Integer, U&lt;:Real, H&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.MultilayerDiGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:AbstractGraph{T}}, UnivariateDistribution, UnivariateDistribution}} where {T&lt;:Integer, U&lt;:Real, H&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.MultilayerDiGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerDiGraph(
    empty_layers::Vector{&lt;:Layer{T,U}},
    empty_interlayers::Vector{&lt;:Interlayer{T,U}},
    indegree_distribution::UnivariateDistribution,
    outdegree_distribution::UnivariateDistribution;
    allow_self_loops::Bool = false,
    default_interlayers_null_graph::H = SimpleGraph{T}(),
) where {T &lt;: Integer, U &lt;: Real, H &lt;: AbstractGraph{T}}</code></pre><p>Return a random MultilayerDiGraph that has <code>empty_layers</code> as layers and <code>empty_interlayers</code> as specified interlayers. <code>empty_layers</code> and <code>empty_interlayers</code> must respectively be <code>Layer</code>s and <code>Interlayer</code>s with whatever number of vertices but no edges (if any edge is found, an error is thrown). The  degree distribution of the returned random <code>MultilayerDiGraph</code> is given by <code>degree_distribution</code>, which must have a support that only contains positive numbers for obvious reasons. <code>allow_self_loops = true</code> allows for self loops t be present in the final random MultilayerDiGraph. <code>default_interlayers_null_graph</code> controls the <code>null_graph</code> argument passed to automatically-generated interlayers. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/multilayerdigraph.jl#L58-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerGraph-Union{Tuple{U}, Tuple{T}, Tuple{MultilayerGraph{T, U}, Vector{&lt;:Integer}}} where {T, U}" href="#MultilayerGraphs.MultilayerGraph-Union{Tuple{U}, Tuple{T}, Tuple{MultilayerGraph{T, U}, Vector{&lt;:Integer}}} where {T, U}"><code>MultilayerGraphs.MultilayerGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerGraph(empty_multilayergraph::MultilayerGraph{T,U},
degree_sequence::Vector{&lt;:Integer}; 
allow_self_loops::Bool = false,
perform_checks::Bool = false) where {T,U}</code></pre><p>Return a random <code>MultilayerGraph</code> with degree sequence <code>degree_sequence</code>. <code>allow_self_loops</code> controls the presence of self-loops, while if <code>perform_checks</code> is true, the <code>degree_sequence</code> os checked to be graphical.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/multilayergraph.jl#L103-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerDiGraph-Union{Tuple{U}, Tuple{T}, Tuple{MultilayerDiGraph{T, U}, Vector{&lt;:Integer}, Vector{&lt;:Integer}}} where {T, U}" href="#MultilayerGraphs.MultilayerDiGraph-Union{Tuple{U}, Tuple{T}, Tuple{MultilayerDiGraph{T, U}, Vector{&lt;:Integer}, Vector{&lt;:Integer}}} where {T, U}"><code>MultilayerGraphs.MultilayerDiGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerDiGraph(
    empty_multilayerdigraph::MultilayerDiGraph{T,U}, 
    indegree_sequence::Vector{&lt;:Integer},
    outdegree_sequence::Vector{&lt;:Integer};
    allow_self_loops::Bool = false,
    perform_checks::Bool = false
) where {T,U}</code></pre><p>Return a random <code>MultilayerDiGraph</code> with degree sequence <code>degree_sequence</code>. <code>allow_self_loops</code> controls the presence of self-loops, while if <code>perform_checks</code> is true, the <code>degree_sequence</code> os checked to be graphical.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/multilayerdigraph.jl#L106-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.nodes-Tuple{AbstractMultilayerGraph}" href="#MultilayerGraphs.nodes-Tuple{AbstractMultilayerGraph}"><code>MultilayerGraphs.nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nodes(mg::AbstractMultilayerGraph</code></pre><p>Return the nodes of the AbstractMultilayerGraph <code>mg</code>, in order of addition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.nn-Tuple{AbstractMultilayerGraph}" href="#MultilayerGraphs.nn-Tuple{AbstractMultilayerGraph}"><code>MultilayerGraphs.nn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nn(mg::M) where {M &lt;: AbstractMultilayerGraph }</code></pre><p>Return the number of nodes in <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.add_node!-Tuple{AbstractMultilayerGraph, Node}" href="#MultilayerGraphs.add_node!-Tuple{AbstractMultilayerGraph, Node}"><code>MultilayerGraphs.add_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_node!(mg::AbstractMultilayerGraph, n::Node; add_vertex_to_layers::Union{Vector{Symbol}, Symbol} = Symbol[])</code></pre><p>Add node <code>n</code> to <code>mg</code>. Return true if succeeds. Additionally, add a corresponding vertex to all layers whose name is listed in <code>add_vertex_to_layers</code>. If <code>add_vertex_to_layers == :all</code>, then a corresponding vertex is added to all layers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.rem_node!-Tuple{AbstractMultilayerGraph, Node}" href="#MultilayerGraphs.rem_node!-Tuple{AbstractMultilayerGraph, Node}"><code>MultilayerGraphs.rem_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_node!(mg::AbstractMultilayerGraph, n::Node)</code></pre><p>Remove node <code>n</code> to <code>mg</code>. Return true if succeeds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_vertex-Tuple{AbstractMultilayerGraph, MultilayerVertex}" href="#Graphs.has_vertex-Tuple{AbstractMultilayerGraph, MultilayerVertex}"><code>Graphs.has_vertex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_vertex(mg::AbstractMultilayerGraph, mv::MultilayerVertex)</code></pre><p>Return true if <code>mv</code> is in <code>mg</code>, else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.nv-Tuple{M} where M&lt;:AbstractMultilayerGraph" href="#Graphs.nv-Tuple{M} where M&lt;:AbstractMultilayerGraph"><code>Graphs.nv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nv(mg::M) where {M &lt;: AbstractMultilayerGraph }</code></pre><p>Return the number of vertices in <code>mg</code>, excluding the missing vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.mv_vertices-Tuple{AbstractMultilayerGraph}" href="#MultilayerGraphs.mv_vertices-Tuple{AbstractMultilayerGraph}"><code>MultilayerGraphs.mv_vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mv_vertices(mg::AbstractMultilayerGraph)</code></pre><p>Return a list of the <code>MultilayerVertex</code>s contained in <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.mv_inneighbors-Tuple{AbstractMultilayerGraph, MultilayerVertex}" href="#MultilayerGraphs.mv_inneighbors-Tuple{AbstractMultilayerGraph, MultilayerVertex}"><code>MultilayerGraphs.mv_inneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mv_inneighbors(mg::AbstractMultilayerGraph, mv::MultilayerVertex)</code></pre><p>Return the list of <code>MultilayerVertex</code> inneighbors of <code>mv</code> within <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L741-L745">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.mv_outneighbors-Tuple{AbstractMultilayerGraph, MultilayerVertex}" href="#MultilayerGraphs.mv_outneighbors-Tuple{AbstractMultilayerGraph, MultilayerVertex}"><code>MultilayerGraphs.mv_outneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mv_outneighbors(mg::AbstractMultilayerGraph, mv::MultilayerVertex)</code></pre><p>Return the list of <code>MultilayerVertex</code> outneighbors of <code>mv</code> within <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L750-L754">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.mv_neighbors-Tuple{AbstractMultilayerGraph, MultilayerVertex}" href="#MultilayerGraphs.mv_neighbors-Tuple{AbstractMultilayerGraph, MultilayerVertex}"><code>MultilayerGraphs.mv_neighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mv_neighbors(mg::AbstractMultilayerGraph, mv::MultilayerVertex)</code></pre><p>Return the list of <code>MultilayerVertex</code> neighbors of <code>mv</code> within <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L759-L763">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_vertex!-Tuple{AbstractMultilayerGraph, MultilayerVertex}" href="#Graphs.SimpleGraphs.add_vertex!-Tuple{AbstractMultilayerGraph, MultilayerVertex}"><code>Graphs.SimpleGraphs.add_vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_vertex!(mg::AbstractMultilayerGraph, mv::MultilayerVertex; add_node::Bool = true)</code></pre><p>Add MultilayerVertex <code>mv</code> to multilayer graph <code>mg</code>. If <code>add_node</code> is true and <code>node(mv)</code> is not already part of <code>mg</code>, then add <code>node(mv)</code> to <code>mg</code> before adding <code>mv</code> to <code>mg</code> instead of throwing an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.rem_vertex!-Tuple{AbstractMultilayerUGraph, MultilayerVertex}" href="#Graphs.SimpleGraphs.rem_vertex!-Tuple{AbstractMultilayerUGraph, MultilayerVertex}"><code>Graphs.SimpleGraphs.rem_vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_vertex!(mg::AbstractMultilayerUGraph, V::MultilayerVertex)</code></pre><p>Remove <a href="@ref">MultilayerVertex</a> <code>mv</code> from <code>mg</code>. Return true if succeeds, false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerugraph.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.rem_vertex!-Tuple{AbstractMultilayerDiGraph, MultilayerVertex}" href="#Graphs.SimpleGraphs.rem_vertex!-Tuple{AbstractMultilayerDiGraph, MultilayerVertex}"><code>Graphs.SimpleGraphs.rem_vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_vertex!(mg::AbstractMultilayerDiGraph, V::MultilayerVertex)</code></pre><p>Remove <a href="@ref">MultilayerVertex</a> <code>mv</code> from <code>mg</code>. Return true if succeeds, false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerdigraph.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_edge-Tuple{AbstractMultilayerGraph, MultilayerEdge}" href="#Graphs.has_edge-Tuple{AbstractMultilayerGraph, MultilayerEdge}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_edge(mg::AbstractMultilayerGraph, edge::MultilayerEdge)</code></pre><p>Return true if <code>mg</code> has an edge between the source and the destination of <code>edge</code> (does not check edge or vertex metadata).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L223-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_edge-Tuple{AbstractMultilayerGraph, MultilayerVertex, MultilayerVertex}" href="#Graphs.has_edge-Tuple{AbstractMultilayerGraph, MultilayerVertex, MultilayerVertex}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_edge(mg::AbstractMultilayerGraph, src::MultilayerVertex, dst::MultilayerVertex)</code></pre><p>Return true if <code>mg</code> has edge between the <code>src</code> and <code>dst</code> (does not check edge or vertex metadata).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L232-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.ne-Tuple{AbstractMultilayerGraph}" href="#Graphs.ne-Tuple{AbstractMultilayerGraph}"><code>Graphs.ne</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ne(mg::AbstractMultilayerGraph)</code></pre><p>Return the number of edges in <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L216-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.edges-Tuple{AbstractMultilayerUGraph}" href="#Graphs.edges-Tuple{AbstractMultilayerUGraph}"><code>Graphs.edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edges(subgraph::S) where {T,U,S&lt;:AbstractSubGraph{T,U}}</code></pre><p>Return an iterator over all the edges of <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L251-L255">source</a></section><section><div><pre><code class="nohighlight hljs">edges(mg::M) where {T,U,M&lt;:AbstractMultilayerUGraph{T,U}}</code></pre><p>Return an list of all the edges of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerugraph.jl#L116-L120">source</a></section><section><div><pre><code class="nohighlight hljs">edges(mg::M) where {T,U,M&lt;:AbstractMultilayerDiGraph{T,U}}</code></pre><p>Return an list of all the edges of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerdigraph.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.edges-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerUGraph{T, U}}" href="#Graphs.edges-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerUGraph{T, U}}"><code>Graphs.edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edges(subgraph::S) where {T,U,S&lt;:AbstractSubGraph{T,U}}</code></pre><p>Return an iterator over all the edges of <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L251-L255">source</a></section><section><div><pre><code class="nohighlight hljs">edges(mg::M) where {T,U,M&lt;:AbstractMultilayerUGraph{T,U}}</code></pre><p>Return an list of all the edges of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerugraph.jl#L116-L120">source</a></section><section><div><pre><code class="nohighlight hljs">edges(mg::M) where {T,U,M&lt;:AbstractMultilayerDiGraph{T,U}}</code></pre><p>Return an list of all the edges of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerdigraph.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.edges-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerDiGraph{T, U}}" href="#Graphs.edges-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerDiGraph{T, U}}"><code>Graphs.edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edges(subgraph::S) where {T,U,S&lt;:AbstractSubGraph{T,U}}</code></pre><p>Return an iterator over all the edges of <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L251-L255">source</a></section><section><div><pre><code class="nohighlight hljs">edges(mg::M) where {T,U,M&lt;:AbstractMultilayerUGraph{T,U}}</code></pre><p>Return an list of all the edges of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerugraph.jl#L116-L120">source</a></section><section><div><pre><code class="nohighlight hljs">edges(mg::M) where {T,U,M&lt;:AbstractMultilayerDiGraph{T,U}}</code></pre><p>Return an list of all the edges of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerdigraph.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}, V&lt;:MultilayerVertex}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{V}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, V, V}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}, V&lt;:MultilayerVertex}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(mg::M, src::V, dst::V; weight::Union{Nothing, U} = one(U), metadata::Union{Tuple,NamedTuple} = NamedTuple() ) where {T,U, M &lt;: AbstractMultilayerGraph{T,U}, V &lt;: MultilayerVertex}</code></pre><p>Add a MultilayerEdge between <code>src</code> and <code>dst</code> with weight <code>weight</code> and metadata <code>metadata</code>. Return true if succeeds, false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L260-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}, E&lt;:(MultilayerEdge{&lt;:Union{Nothing, U}})}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, E}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}, E&lt;:(MultilayerEdge{&lt;:Union{Nothing, U}})}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(mg::M, me::E) where {T,U, M &lt;: AbstractMultilayerGraph{T,U}, E &lt;: MultilayerEdge{ &lt;: Union{U,Nothing}}}</code></pre><p>Add a MultilayerEdge between <code>src</code> and <code>dst</code> with weight <code>weight</code> and metadata <code>metadata</code>. Return true if succeeds, false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L275-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.rem_edge!-Tuple{AbstractMultilayerGraph, MultilayerEdge}" href="#Graphs.SimpleGraphs.rem_edge!-Tuple{AbstractMultilayerGraph, MultilayerEdge}"><code>Graphs.SimpleGraphs.rem_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_edge!(mg::AbstractMultilayerGraph, me::MultilayerEdge)</code></pre><p>Remove edge from <code>src(me)</code> to <code>dst(me)</code> from <code>mg</code>. Return true if succeeds, false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L291-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.rem_edge!-Tuple{MultilayerGraph, MultilayerVertex, MultilayerVertex}" href="#Graphs.SimpleGraphs.rem_edge!-Tuple{MultilayerGraph, MultilayerVertex, MultilayerVertex}"><code>Graphs.SimpleGraphs.rem_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_edge!(mg::AbstractMultilayerUGraph, src::MultilayerVertex, dst::MultilayerVertex)</code></pre><p>Remove edge from <code>src</code> to <code>dst</code> from <code>mg</code>. Return true if succeeds, false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/multilayergraph.jl#L209-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.rem_edge!-Tuple{MultilayerDiGraph, MultilayerVertex, MultilayerVertex}" href="#Graphs.SimpleGraphs.rem_edge!-Tuple{MultilayerDiGraph, MultilayerVertex, MultilayerVertex}"><code>Graphs.SimpleGraphs.rem_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_edge!(mg::MultilayerDiGraph, src::MultilayerVertex, dst::MultilayerVertex)</code></pre><p>Remove edge from <code>src</code> to <code>dst</code> from <code>mg</code>. Return true if succeeds, false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/multilayerdigraph.jl#L223-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_metadata-Tuple{AbstractMultilayerGraph, MultilayerVertex}" href="#MultilayerGraphs.get_metadata-Tuple{AbstractMultilayerGraph, MultilayerVertex}"><code>MultilayerGraphs.get_metadata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_metadata(mg::AbstractMultilayerGraph, bare_mv::MultilayerVertex)</code></pre><p>Return the metadata associated to <code>MultilayerVertex</code> mv (regardless of metadata assigned to <code>bare_mv</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_metadata-Tuple{AbstractMultilayerGraph, MultilayerVertex, MultilayerVertex}" href="#MultilayerGraphs.get_metadata-Tuple{AbstractMultilayerGraph, MultilayerVertex, MultilayerVertex}"><code>MultilayerGraphs.get_metadata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_metadata(mg::AbstractMultilayerGraph, src::MultilayerVertex, dst::MultilayerVertex)</code></pre><p>Return the metadata associated to the <code>MultilayerEdge</code> from <code>src</code> to <code>dst</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L316-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimpleWeightedGraphs.get_weight-Tuple{AbstractMultilayerGraph, MultilayerVertex, MultilayerVertex}" href="#SimpleWeightedGraphs.get_weight-Tuple{AbstractMultilayerGraph, MultilayerVertex, MultilayerVertex}"><code>SimpleWeightedGraphs.get_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_weight(mg::AbstractMultilayerGraph, src::MultilayerVertex, dst::MultilayerVertex)h</code></pre><p>Return the weight associated to the <code>MultilayerEdge</code> from <code>src</code> to <code>dst</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L327-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.set_weight!-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, MultilayerVertex, MultilayerVertex, U}} where {T, U, M&lt;:AbstractMultilayerUGraph{T, U}}" href="#MultilayerGraphs.set_weight!-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, MultilayerVertex, MultilayerVertex, U}} where {T, U, M&lt;:AbstractMultilayerUGraph{T, U}}"><code>MultilayerGraphs.set_weight!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_weight!(mg::M, src::MultilayerVertex{L1}, dst::MultilayerVertex{L2}, weight::U) where {L1 &lt;: Symbol, L2 &lt;: Symbol, T,U, M &lt;: AbstractMultilayerGraph{T,U}}</code></pre><p>Set the weight of the edge between <code>src</code> and <code>dst</code> to <code>weight</code>. Return true if succeeds (i.e. if the edge exists and the underlying graph chosen for the Layer/Interlayer where the edge lies is weighted under the <code>IsWeighted</code> trait).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerugraph.jl#L184-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.set_weight!-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, MultilayerVertex, MultilayerVertex, U}} where {T, U, M&lt;:AbstractMultilayerDiGraph{T, U}}" href="#MultilayerGraphs.set_weight!-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, MultilayerVertex, MultilayerVertex, U}} where {T, U, M&lt;:AbstractMultilayerDiGraph{T, U}}"><code>MultilayerGraphs.set_weight!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_weight!(mg::M, src::MultilayerVertex{L1}, dst::MultilayerVertex{L2}, weight::U) where {L1 &lt;: Symbol, L2 &lt;: Symbol, T,U, M &lt;: AbstractMultilayerGraph{T,U}}</code></pre><p>Set the weight of the edge between <code>src</code> and <code>dst</code> to <code>weight</code>. Return true if succeeds (i.e. if the edge exists and the underlying graph chosen for the Layer/Interlayer where the edge lies is weighted under the <code>IsWeighted</code> trait).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerdigraph.jl#L200-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_directed-Tuple{AbstractMultilayerUGraph}" href="#Graphs.is_directed-Tuple{AbstractMultilayerUGraph}"><code>Graphs.is_directed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_directed(mg::AbstractMultilayerUGraph)</code></pre><p>Return <code>true</code> if <code>mg</code> is directed, <code>false</code> otherwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerugraph.jl#L428-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_directed-Tuple{M} where M&lt;:(Type{&lt;:AbstractMultilayerUGraph})" href="#Graphs.is_directed-Tuple{M} where M&lt;:(Type{&lt;:AbstractMultilayerUGraph})"><code>Graphs.is_directed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_directed(m::M) where { M &lt;: Type{ &lt;: AbstractMultilayerUGraph}}</code></pre><p>Return <code>true</code> if <code>mg</code> is directed, <code>false</code> otherwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerugraph.jl#L435-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_directed-Tuple{AbstractMultilayerDiGraph}" href="#Graphs.is_directed-Tuple{AbstractMultilayerDiGraph}"><code>Graphs.is_directed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_directed(mg::AbstractMultilayerDiGraph)</code></pre><p>Return <code>true</code> if <code>mg</code> is directed, <code>false</code> otherwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerdigraph.jl#L468-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_directed-Tuple{M} where M&lt;:(Type{&lt;:AbstractMultilayerDiGraph})" href="#Graphs.is_directed-Tuple{M} where M&lt;:(Type{&lt;:AbstractMultilayerDiGraph})"><code>Graphs.is_directed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_directed(m::M) where { M &lt;: Type{ &lt;: AbstractMultilayerDiGraph}}</code></pre><p>Return <code>true</code> if <code>mg</code> is directed, <code>false</code> otherwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerdigraph.jl#L475-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.has_node-Tuple{AbstractMultilayerGraph, Node}" href="#MultilayerGraphs.has_node-Tuple{AbstractMultilayerGraph, Node}"><code>MultilayerGraphs.has_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_node(mg::AbstractMultilayerGraph, n::Node)</code></pre><p>Return true if <code>n</code> is a node of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.set_metadata!-Tuple{AbstractMultilayerGraph, MultilayerVertex, Union{Tuple, NamedTuple}}" href="#MultilayerGraphs.set_metadata!-Tuple{AbstractMultilayerGraph, MultilayerVertex, Union{Tuple, NamedTuple}}"><code>MultilayerGraphs.set_metadata!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_metadata!(mg::AbstractMultilayerGraph, mv::MultilayerVertex, metadata::Union{Tuple, NamedTuple})</code></pre><p>Set the metadata of vertex <code>mv</code> to <code>metadata</code>. Return true if succeeds</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.set_metadata!-Tuple{AbstractMultilayerDiGraph, MultilayerVertex, MultilayerVertex, Union{Tuple, NamedTuple}}" href="#MultilayerGraphs.set_metadata!-Tuple{AbstractMultilayerDiGraph, MultilayerVertex, MultilayerVertex, Union{Tuple, NamedTuple}}"><code>MultilayerGraphs.set_metadata!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_metadata!(mg::AbstractMultilayerDiGraph, src::MultilayerVertex, dst::MultilayerVertex, metadata::Union{Tuple, NamedTuple})</code></pre><p>Set the metadata of the edge between <code>src</code> and <code>dst</code> to <code>metadata</code>. Return true if succeeds (i.e. if the edge exists and the underlying graph chosen for the Layer/Interlayer where the edge lies supports metadata at the edge level  under the <code>IsMeta</code> trait).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerdigraph.jl#L229-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.set_metadata!-Tuple{AbstractMultilayerUGraph, MultilayerVertex, MultilayerVertex, Union{Tuple, NamedTuple}}" href="#MultilayerGraphs.set_metadata!-Tuple{AbstractMultilayerUGraph, MultilayerVertex, MultilayerVertex, Union{Tuple, NamedTuple}}"><code>MultilayerGraphs.set_metadata!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_metadata!(mg::AbstractMultilayerUGraph, src::MultilayerVertex, dst::MultilayerVertex, metadata::Union{Tuple, NamedTuple})</code></pre><p>Set the metadata of the edge between <code>src</code> and <code>dst</code> to <code>metadata</code>. Return true if succeeds (i.e. if the edge exists and the underlying graph chosen for the Layer/Interlayer where the edge lies supports metadata at the edge level  under the <code>IsMeta</code> trait).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerugraph.jl#L211-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.nl-Tuple{AbstractMultilayerGraph}" href="#MultilayerGraphs.nl-Tuple{AbstractMultilayerGraph}"><code>MultilayerGraphs.nl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nl(mg::AbstractMultilayerGraph)</code></pre><p>Return the number of layers in <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L340-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.nIn-Tuple{AbstractMultilayerGraph}" href="#MultilayerGraphs.nIn-Tuple{AbstractMultilayerGraph}"><code>MultilayerGraphs.nIn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nIn(mg::AbstractMultilayerGraph)</code></pre><p>Return the number of interlayers in <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L347-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.has_layer-Tuple{AbstractMultilayerGraph, Symbol}" href="#MultilayerGraphs.has_layer-Tuple{AbstractMultilayerGraph, Symbol}"><code>MultilayerGraphs.has_layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_layer(mg::AbstractMultilayerGraph, layer_name::Symbol)</code></pre><p>Return true in <code>layer_name</code> is a name of a <code>[Layer](@ref)</code> of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L354-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.add_layer!-Union{Tuple{H}, Tuple{L}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, G&lt;:AbstractGraph{T}, M&lt;:AbstractMultilayerUGraph{T, U}, L&lt;:Layer{T, U, G}, H&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.add_layer!-Union{Tuple{H}, Tuple{L}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, G&lt;:AbstractGraph{T}, M&lt;:AbstractMultilayerUGraph{T, U}, L&lt;:Layer{T, U, G}, H&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.add_layer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_layer!( mg::M,
    new_layer::L; 
    default_interlayers_null_graph::H = SimpleGraph{T}(), 
    default_interlayers_structure::String =&quot;multiplex&quot;
) where {T,U,G&lt;:AbstractGraph{T},M&lt;:AbstractMultilayerUGraph{T,U},L&lt;:Layer{T,U,G}, H &lt;: AbstractGraph{T}}</code></pre><p>Add layer <code>layer</code> to <code>mg</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>mg::M</code>: the <code>MultilayerGraph</code> which the new layer will be added to;</li><li><code>new_layer::L</code>: the new <code>Layer</code> to add to <code>mg</code>;</li><li><code>default_interlayers_null_graph::H = SimpleGraph{T}()</code>: upon addition of a new <code>Layer</code>, all the <code>Interlayer</code>s between the new and the existing <code>Layer</code>s are immediately created. This keyword argument specifies their <code>null_graph</code> See the <code>Layer</code> constructor for more information. Defaults to <code>SimpleGraph{T}()</code>;</li><li><code>default_interlayers_structure::String = &quot;multiplex&quot;</code>: The structure of the <code>Interlayer</code>s created by default. May either be &quot;multiplex&quot; to have diagonally-coupled only interlayers, or &quot;empty&quot; for empty interlayers. Defaults to &quot;multiplex&quot;.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerugraph.jl#L242-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.add_layer!-Union{Tuple{H}, Tuple{L}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, G&lt;:AbstractGraph{T}, M&lt;:AbstractMultilayerDiGraph{T, U}, L&lt;:Layer{T, U, G}, H&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.add_layer!-Union{Tuple{H}, Tuple{L}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, L}} where {T, U, G&lt;:AbstractGraph{T}, M&lt;:AbstractMultilayerDiGraph{T, U}, L&lt;:Layer{T, U, G}, H&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.add_layer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_layer!(
    mg::M, 
    new_layer::L; 
    default_interlayers_null_graph::H = SimpleGraph{T}(), 
    default_interlayers_structure::String =&quot;multiplex&quot;
) where {T,U,G&lt;:AbstractGraph{T},M&lt;:AbstractMultilayerDiGraph{T,U},L&lt;:Layer{T,U,G}, H &lt;: AbstractGraph{T}}</code></pre><p>Add layer <code>layer</code> to <code>mg</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>mg::M</code>: the <code>MultilayerDiGraph</code> which the new layer will be added to;</li><li><code>new_layer::L</code>: the new <code>Layer</code> to add to <code>mg</code>;</li><li><code>default_interlayers_null_graph::H</code>: upon addition of a new <code>Layer</code>, all the <code>Interlayer</code>s between the new and the existing <code>Layer</code>s are immediately created. This keyword argument specifies their <code>null_graph</code> See the <code>Layer</code> constructor for more information. Defaults to <code>SimpleGraph{T}()</code>;</li><li><code>default_interlayers_structure::String</code>: The structure of the <code>Interlayer</code>s created by default. May either be &quot;multiplex&quot; to have diagonally-coupled only interlayers, or &quot;empty&quot; for empty interlayers. Defaults to &quot;multiplex&quot;.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerdigraph.jl#L260-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G&lt;:AbstractGraph{T}, M&lt;:AbstractMultilayerDiGraph{T, U}, In&lt;:Interlayer{T, U, G}}" href="#MultilayerGraphs.specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G&lt;:AbstractGraph{T}, M&lt;:AbstractMultilayerDiGraph{T, U}, In&lt;:Interlayer{T, U, G}}"><code>MultilayerGraphs.specify_interlayer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">specify_interlayer!(
    mg::M,
    new_interlayer::In
) where {T,U,G&lt;:AbstractGraph{T},M&lt;:AbstractMultilayerDiGraph{T,U},In&lt;:Interlayer{T,U,G}}</code></pre><p>Specify the interlayer <code>new_interlayer</code> as part of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerdigraph.jl#L305-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G&lt;:AbstractGraph{T}, M&lt;:AbstractMultilayerUGraph{T, U}, In&lt;:Interlayer{T, U, G}}" href="#MultilayerGraphs.specify_interlayer!-Union{Tuple{In}, Tuple{M}, Tuple{G}, Tuple{U}, Tuple{T}, Tuple{M, In}} where {T, U, G&lt;:AbstractGraph{T}, M&lt;:AbstractMultilayerUGraph{T, U}, In&lt;:Interlayer{T, U, G}}"><code>MultilayerGraphs.specify_interlayer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">specify_interlayer!(
    mg::M,
    new_interlayer::In
) where {T,U,G&lt;:AbstractGraph{T},M&lt;:AbstractMultilayerUGraph{T,U},In&lt;:Interlayer{T,U,G}}</code></pre><p>Specify the interlayer <code>new_interlayer</code> as part of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerugraph.jl#L286-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_interlayer-Tuple{AbstractMultilayerGraph, Symbol, Symbol}" href="#MultilayerGraphs.get_interlayer-Tuple{AbstractMultilayerGraph, Symbol, Symbol}"><code>MultilayerGraphs.get_interlayer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_interlayer(
    mg::AbstractMultilayerGraph, layer_1_name::Symbol, 
    layer_2_name::Symbol
)</code></pre><p>Return the <code>Interlayer</code> between <code>layer_1</code> and <code>layer_2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L550-L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.indegree-Tuple{AbstractMultilayerGraph, MultilayerVertex}" href="#Graphs.indegree-Tuple{AbstractMultilayerGraph, MultilayerVertex}"><code>Graphs.indegree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">indegree( mg::AbstractMultilayerGraph, v::MultilayerVertex)</code></pre><p>Get the indegree of vertex <code>v</code> in <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L642-L646">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.indegree" href="#Graphs.indegree"><code>Graphs.indegree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">indegree( mg::M, vs::AbstractVector{V}=vertices(mg)) where {T,M&lt;:AbstractMultilayerGraph{T,&lt;:Real},V&lt;:MultilayerVertex}</code></pre><p>Get the vector of indegrees of vertices <code>vs</code> in <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L651-L655">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.outdegree-Tuple{AbstractMultilayerGraph, MultilayerVertex}" href="#Graphs.outdegree-Tuple{AbstractMultilayerGraph, MultilayerVertex}"><code>Graphs.outdegree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outdegree(mg::AbstractMultilayerGraph, mv::MultilayerVertex)</code></pre><p>Get the outdegree of vertex <code>v</code> in <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L662-L666">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.outdegree" href="#Graphs.outdegree"><code>Graphs.outdegree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">outdegree(mg::M, vs::AbstractVector{V}=vertices(mg)) where {T,M&lt;:AbstractMultilayerGraph{T,&lt;:Real},V&lt;:MultilayerVertex}</code></pre><p>Get the vector of outdegrees of vertices <code>vs</code> in <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L671-L675">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.degree" href="#Graphs.degree"><code>Graphs.degree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">degree(mg::AbstractMultilayerGraph, vs::AbstractVector{&lt;:MultilayerVertex}=vertices(mg))</code></pre><p>Get the degree of vertices <code>vs</code> in <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L682-L686">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.mean_degree-Tuple{AbstractMultilayerGraph}" href="#MultilayerGraphs.mean_degree-Tuple{AbstractMultilayerGraph}"><code>MultilayerGraphs.mean_degree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean_degree(mg::AbstractMultilayerGraph)</code></pre><p>Return the mean of the degree sequence of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L943-L947">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.degree_second_moment-Tuple{AbstractMultilayerGraph}" href="#MultilayerGraphs.degree_second_moment-Tuple{AbstractMultilayerGraph}"><code>MultilayerGraphs.degree_second_moment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degree_second_moment(mg::AbstractMultilayerGraph)</code></pre><p>Calculate the second moment of the degree sequence of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L950-L954">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.degree_variance-Tuple{AbstractMultilayerGraph}" href="#MultilayerGraphs.degree_variance-Tuple{AbstractMultilayerGraph}"><code>MultilayerGraphs.degree_variance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degree_variance(mg::AbstractMultilayerGraph)</code></pre><p>Return the variance of the degree sequence of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L957-L961">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.weighttype-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}" href="#MultilayerGraphs.weighttype-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>MultilayerGraphs.weighttype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weighttype(::M) where {T,U,M&lt;:AbstractMultilayerGraph{T,U}}</code></pre><p>Return the weight type of <code>mg</code> (i.e. the eltype of the weight tensor or the supra-adjacency matrix).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L733-L737">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.multilayer_global_clustering_coefficient" href="#MultilayerGraphs.multilayer_global_clustering_coefficient"><code>MultilayerGraphs.multilayer_global_clustering_coefficient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">multilayer_global_clustering_coefficient(
    mg::AbstractMultilayerGraph, 
    norm_factor::Union{Float64,Symbol}=:max
)</code></pre><p>Return the complete multilayer global clustering coefficient, equal to the ratio of realized triplets over all possible triplets, including those whose every or some edges belong to interlayers, normalized by <code>norm_factor</code>. If <code>norm_factor == :max</code>, then the ratio is normalized by <code>maximum(array(weight_tensor(mg)))</code>, else it is not normalized. This function does not override Graphs.jl&#39;s <code>global_clustering_coefficient</code>, since the latter does not consider cliques where two nodes are the same node but in different layers/interlayers. See <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L964-L971">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.overlay_clustering_coefficient" href="#MultilayerGraphs.overlay_clustering_coefficient"><code>MultilayerGraphs.overlay_clustering_coefficient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">overlay_clustering_coefficient(
    mg::AbstractMultilayerGraph, 
    norm_factor::Union{Float64,Symbol}=:max
)</code></pre><p>Return the overlay clustering coefficient as calculated in <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>. If <code>norm_factor == :max</code>, then the ratio is normalized by <code>maximum(array(weight_tensor(mg)))</code>, else it is not normalized. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L1030-L1037">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.eigenvector_centrality-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}" href="#Graphs.eigenvector_centrality-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>Graphs.eigenvector_centrality</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eigenvector_centrality(
    mg::M;
    norm::String = &quot;1&quot;,
    tol::Float64 = 1e-6,
    maxiter::Int64 = 2000
    ) where {T, U, M &lt;: AbstractMultilayerGraph{T, U}}</code></pre><p>Calculate the eigenvector centrality of <code>mg</code> via an iterative algorithm. The <code>norm</code> parameter may be <code>&quot;1&quot;</code> or <code>&quot;n&quot;</code>,  and respectively the eigenvector centrality will be normalized to 1 or further divided by the number of nodes of <code>mg</code>. The <code>tol</code> parameter terminates the approximation when two consecutive iteration differ by no more than  <code>tol</code>. The <code>maxiters</code> parameter terminates the algorithm when it goes beyond <code>maxiters</code> iterations.</p><p>The returned values are: the eigenvector centrality and the relative error at each algorithm iteration, that is, the summed absolute values of the componentwise differences between the centrality computed at the current iteration minus the centrality computed at the previous iteration.</p><p>Note: in the limit case of a monoplex graph, this function outputs a eigenvector centrality vector that coincides the one outputted by Graphs.jl&#39;s <code>eigenvector_centrality</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L1059-L1072">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.modularity-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, Matrix{Int64}}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}" href="#Graphs.modularity-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, Matrix{Int64}}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>Graphs.modularity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modularity(
    mg::M, 
    c::Matrix{Int64}; 
    null_model::Union{String,Array{U,4}} = &quot;degree&quot;
) where {T, U, M &lt;: AbstractMultilayerGraph{T,U}}</code></pre><p>Calculate the modularity of <code>mg</code>, as shown in <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L1127-L1135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.von_neumann_entropy-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerUGraph{T, U}}" href="#MultilayerGraphs.von_neumann_entropy-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerUGraph{T, U}}"><code>MultilayerGraphs.von_neumann_entropy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">von_neumann_entropy(mg::M) where {T,U,  M &lt;: AbstractMultilayerUGraph{T, U}}</code></pre><p>Compute the Von Neumann entropy of <code>mg</code>, according to <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>. Only for undirected multilayer graphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerugraph.jl#L463-L467">source</a></section></article><h3 id="representations_eu"><a class="docs-heading-anchor" href="#representations_eu">Representations</a><a id="representations_eu-1"></a><a class="docs-heading-anchor-permalink" href="#representations_eu" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.array-Tuple{AbstractTensorRepresentation}" href="#MultilayerGraphs.array-Tuple{AbstractTensorRepresentation}"><code>MultilayerGraphs.array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">array(atr::AbstractTensorRepresentation)</code></pre><p>Return the array representation of <code>atr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/representations/abstracttensorrepresentation.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.WeightTensor" href="#MultilayerGraphs.WeightTensor"><code>MultilayerGraphs.WeightTensor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WeightTensor{U}</code></pre><p>Concrete type representing the weight tensor of a multilayer graph.  Look at the EXAMPLES section below to learn how to use it.</p><p><strong>EXAMPLES</strong></p><pre><code class="language-julia hljs"># Assuming a MultilayerGraph named mg is defined, and that mv1 and mv2 are two of its `MultilayerVertex`ss
wt = WeightTensor(mg)
# One may access te corresponding WeightTensor&#39;s entry via:
wt[mv1, mv2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/representations/weighttensor.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.weight_tensor-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}" href="#MultilayerGraphs.weight_tensor-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>MultilayerGraphs.weight_tensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weight_tensor(mg::M) where {T,U, M &lt;: AbstractMultilayerGraph{T,U}}</code></pre><p>Compute the weight tensor of <code>mg</code>. Return an object of type <code>WeightTensor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L814-L818">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MetadataTensor" href="#MultilayerGraphs.MetadataTensor"><code>MultilayerGraphs.MetadataTensor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MetadataTensor{U}</code></pre><p>Concrete type representing the metadata tensor of a multilayer graph.  Look at the EXAMPLES section below to learn how to use it.</p><p><strong>EXAMPLES</strong></p><pre><code class="language-julia hljs"># Assuming a MultilayerGraph named mg is defined, and that mv1 and mv2 are two of its `MultilayerVertex`s
mt = MetadataTensor(mg)
# One may access te corresponding MetadataTensor&#39;s entry via:
mt[mv1, mv2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/representations/metadatatensor.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.metadata_tensor-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}" href="#MultilayerGraphs.metadata_tensor-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>MultilayerGraphs.metadata_tensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">metadata_tensor(mg::M) where {T,U, M &lt;: AbstractMultilayerGraph{T,U}}</code></pre><p>Compute the weight tensor of <code>mg</code>. Return an object of type <code>WeightTensor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L909-L913">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.array-Tuple{AbstractMatrixRepresentation}" href="#MultilayerGraphs.array-Tuple{AbstractMatrixRepresentation}"><code>MultilayerGraphs.array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">array(amr::AbstractMatrixRepresentation)</code></pre><p>Return the array representation of <code>amr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/representations/abstractmatrixrepresentation.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.SupraWeightMatrix" href="#MultilayerGraphs.SupraWeightMatrix"><code>MultilayerGraphs.SupraWeightMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SupraWeightMatrix{T,U}</code></pre><p>A concrete type representing the (supra) weight matrix of a multilayer graph. It takes into account missing vertices by default. Look at the EXAMPLES section to learn how to use it.</p><p><strong>EXAMPLES</strong></p><pre><code class="language-julia hljs"># Assuming a MultilayerGraph named mg is defined, and that mv1 and mv2 are two of its `MultilayerVertex`ss
swm = SupraWeightMatrix(mg)
# One may access te corresponding SupraWeightMatrix&#39;s entry via:
swm[mv1, mv2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/representations/supraweightmatrix.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.supra_weight_matrix-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}" href="#MultilayerGraphs.supra_weight_matrix-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>MultilayerGraphs.supra_weight_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">supra_weight_matrix(mg::M) where {T,U, M &lt;: AbstractMultilayerGraph{T,U}}</code></pre><p>Compute the supra weight matrix of <code>mg</code>. Return an object of type <code>SupraWeightMatrix</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L883-L887">source</a></section></article><h3 id="traits_eu"><a class="docs-heading-anchor" href="#traits_eu">Traits</a><a id="traits_eu-1"></a><a class="docs-heading-anchor-permalink" href="#traits_eu" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.is_weighted-Tuple{G} where G&lt;:AbstractGraph" href="#MultilayerGraphs.is_weighted-Tuple{G} where G&lt;:AbstractGraph"><code>MultilayerGraphs.is_weighted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_weighted(g::G) where { G &lt;: AbstractGraph}</code></pre><p>Check whether <code>g</code> is weighted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/traits.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.is_weighted-Tuple{G} where G&lt;:(Type{&lt;:AbstractGraph})" href="#MultilayerGraphs.is_weighted-Tuple{G} where G&lt;:(Type{&lt;:AbstractGraph})"><code>MultilayerGraphs.is_weighted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_weighted(g::G) where {G&lt;:Type{&lt;:AbstractGraph}}</code></pre><p>Check whether <code>g</code> is weighted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/traits.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.is_meta-Tuple{G} where G&lt;:AbstractGraph" href="#MultilayerGraphs.is_meta-Tuple{G} where G&lt;:AbstractGraph"><code>MultilayerGraphs.is_meta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_meta(g::G) where {G &lt;: AbstractGraph}</code></pre><p>Check whether <code>g</code> supports edge AND vertex metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/traits.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.is_meta-Tuple{G} where G&lt;:(Type{&lt;:AbstractGraph})" href="#MultilayerGraphs.is_meta-Tuple{G} where G&lt;:(Type{&lt;:AbstractGraph})"><code>MultilayerGraphs.is_meta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_meta(g::G) where {G&lt;:Type{&lt;:AbstractGraph}}</code></pre><p>Check whether <code>g</code> supports edge AND vertex metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/traits.jl#L42-L46">source</a></section></article><h3 id="utilities_eu"><a class="docs-heading-anchor" href="#utilities_eu">Utilities</a><a id="utilities_eu-1"></a><a class="docs-heading-anchor-permalink" href="#utilities_eu" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.multilayer_kronecker_delta-Tuple{NTuple{4, Int64}}" href="#MultilayerGraphs.multilayer_kronecker_delta-Tuple{NTuple{4, Int64}}"><code>MultilayerGraphs.multilayer_kronecker_delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multilayer_kronecker_delta(dims::NTuple{4,Int64})</code></pre><p>Return a 4-dimensional Kronecker delta with size equal to <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/utilities.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.δk" href="#MultilayerGraphs.δk"><code>MultilayerGraphs.δk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct δk{T} &lt;: AbstractVector{T}</code></pre><p>The Kronecker delta.</p><p><strong>FIELDS</strong></p><ul><li><code>N::Int64</code>: the number of dimensions;</li><li><code>representation::Matrix{Int64}</code>: the matrix representing the Kronecker delta;</li><li><code>T</code>: the return type when called <code>δk[i,j]</code>.</li></ul><p><strong>CONSTRUCTORS</strong></p><pre><code class="nohighlight hljs">δk{T}(N::Int64) where {T &lt;: Number}</code></pre><p>Inner constructor that only requires <code>N</code> and the <code>eltype</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/utilities.jl#L89-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.δk-Tuple{Int64}" href="#MultilayerGraphs.δk-Tuple{Int64}"><code>MultilayerGraphs.δk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">δk(N::Int64)</code></pre><p>Outer constructor that only requires <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/utilities.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.δ_1" href="#MultilayerGraphs.δ_1"><code>MultilayerGraphs.δ_1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct δ_1{T&lt;: Number}</code></pre><p>The <code>δ_1</code> from <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>. Evaluate it via the notation <code>[i,j]</code>.</p><p><strong>FIELDS</strong></p><ul><li><code>N:Int64</code>: the dimensionality of <code>δ_1</code>;</li><li><code>T</code>: the return type.</li></ul><p><strong>CONSTRUCTORS</strong></p><pre><code class="nohighlight hljs">δ_1{T&lt;: Number}(N::Int64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/utilities.jl#L149-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.δ_2" href="#MultilayerGraphs.δ_2"><code>MultilayerGraphs.δ_2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct δ_2{T&lt;: Number}</code></pre><p>The <code>δ_2</code> from <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>. Evaluate it via the notation <code>[i,j]</code>.</p><p><strong>FIELDS</strong></p><ul><li><code>N:Int64</code>: the dimensionality of <code>δ_2</code>;</li><li><code>T</code>: the return type.</li></ul><p><strong>CONSTRUCTORS</strong></p><pre><code class="nohighlight hljs">δ_2{T&lt;: Number}(N::Int64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/utilities.jl#L171-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.δ_3" href="#MultilayerGraphs.δ_3"><code>MultilayerGraphs.δ_3</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct δ_3{T&lt;: Number}</code></pre><p>The <code>δ_3</code> from <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>. Evaluate it via the notation <code>[i,j]</code>.</p><p><strong>FIELDS</strong></p><ul><li><code>N:Int64</code>: the dimensionality of <code>δ_3</code>;</li><li><code>T</code>: the return type.</li></ul><p><strong>CONSTRUCTORS</strong></p><pre><code class="nohighlight hljs">δ_3{T&lt;: Number}(N::Int64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/utilities.jl#L199-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.δ_Ω" href="#MultilayerGraphs.δ_Ω"><code>MultilayerGraphs.δ_Ω</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">δ_Ω{T} &lt;: AbstractVector{T}</code></pre><p>Struct that represents the <code>δ_Ω</code> defined in <a href="https://doi.org/10.1103/PhysRevX.3.041022">De Domenico et al. (2013)</a>.</p><p><strong>FIELDS</strong></p><ul><li><code>δ_1::δ_1{T}</code>: Instance of <code>δ_1</code>;</li><li><code>δ_2::δ_2{T}</code>: Instance of <code>δ_2</code>;</li><li><code>δ_3::δ_3{T}</code>: Instance of <code>δ_3</code>;</li><li><code>N::Int64</code>  : Maximum index (number of layers);</li><li><code>representation::Array{Int64,4}</code>: Multidimensional-array representation of <code>δ_Ω</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/utilities.jl#L221-L233">source</a></section></article><h2 id="Developer"><a class="docs-heading-anchor" href="#Developer">Developer</a><a id="Developer-1"></a><a class="docs-heading-anchor-permalink" href="#Developer" title="Permalink"></a></h2><h3 id="nodes_dev"><a class="docs-heading-anchor" href="#nodes_dev">Nodes</a><a id="nodes_dev-1"></a><a class="docs-heading-anchor-permalink" href="#nodes_dev" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.AbstractNode" href="#MultilayerGraphs.AbstractNode"><code>MultilayerGraphs.AbstractNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractNode</code></pre><p>An abstract type representing a node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/node.jl#L1-L5">source</a></section></article><h3 id="vertices_dev"><a class="docs-heading-anchor" href="#vertices_dev">Vertices</a><a id="vertices_dev-1"></a><a class="docs-heading-anchor-permalink" href="#vertices_dev" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.AbstractVertex" href="#MultilayerGraphs.AbstractVertex"><code>MultilayerGraphs.AbstractVertex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractVertex</code></pre><p>An abstract type for vertices that may not be represented by Integer and for which it may be inappropriate to use a graph with vertex-level metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/vertices/abstractvertex.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.AbstractMultilayerVertex" href="#MultilayerGraphs.AbstractMultilayerVertex"><code>MultilayerGraphs.AbstractMultilayerVertex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMultilayerVertex{S} &lt;: AbstractVertex</code></pre><p>An abstract type representing an abstract MultilayerGraph vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/vertices/multilayervertex.jl#L1-L5">source</a></section></article><h3 id="edges_dev"><a class="docs-heading-anchor" href="#edges_dev">Edges</a><a id="edges_dev-1"></a><a class="docs-heading-anchor-permalink" href="#edges_dev" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.AbstractMultilayerEdge" href="#MultilayerGraphs.AbstractMultilayerEdge"><code>MultilayerGraphs.AbstractMultilayerEdge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMultilayerEdge{T} &lt;: AbstractEdge{T}</code></pre><p>An abstract type representing a <code>MultilayerGraph</code> edge.</p><p>It must have fields: <code>src</code>, <code>dst</code>, <code>weight</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/multilayeredge.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.metadata-Tuple{MultilayerGraphs.HalfEdge}" href="#MultilayerGraphs.metadata-Tuple{MultilayerGraphs.HalfEdge}"><code>MultilayerGraphs.metadata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">metadata(he::HalfEdge)</code></pre><p>Return the metadata associated to the edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/halfedge.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimpleWeightedGraphs.weight-Tuple{MultilayerGraphs.HalfEdge}" href="#SimpleWeightedGraphs.weight-Tuple{MultilayerGraphs.HalfEdge}"><code>SimpleWeightedGraphs.weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weight(he::HalfEdge)</code></pre><p>Return the weight of the edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/halfedge.jl#L30-L34">source</a></section></article><h3 id="subgraphs_dev"><a class="docs-heading-anchor" href="#subgraphs_dev">Subgraphs</a><a id="subgraphs_dev-1"></a><a class="docs-heading-anchor-permalink" href="#subgraphs_dev" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_vertex-Union{Tuple{S}, Tuple{T}, Tuple{S, T}} where {T, S&lt;:(AbstractSubGraph{T, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{T}})}" href="#Graphs.has_vertex-Union{Tuple{S}, Tuple{T}, Tuple{S, T}} where {T, S&lt;:(AbstractSubGraph{T, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{T}})}"><code>Graphs.has_vertex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_vertex( subgraph::S, v::T ) where {T,S&lt;:AbstractSubGraph{T}}</code></pre><p>Return <code>true</code> if <code>v</code> is a vertex of <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.vertices-Tuple{AbstractSubGraph}" href="#Graphs.vertices-Tuple{AbstractSubGraph}"><code>Graphs.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertices(subgraph::AbstractSubGraph)</code></pre><p>Return the collection of the vertices of <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.inneighbors-Union{Tuple{S}, Tuple{T}, Tuple{S, T}} where {T, S&lt;:(AbstractSubGraph{T, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{T}})}" href="#Graphs.inneighbors-Union{Tuple{S}, Tuple{T}, Tuple{S, T}} where {T, S&lt;:(AbstractSubGraph{T, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{T}})}"><code>Graphs.inneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inneighbors(subgraph::S, v::T) where {T, S &lt;: AbstractSubGraph{T}}</code></pre><p>Return the list of inneighbors of <code>v</code> within <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.inneighbors-Tuple{AbstractSubGraph, MultilayerVertex}" href="#Graphs.inneighbors-Tuple{AbstractSubGraph, MultilayerVertex}"><code>Graphs.inneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)</code></pre><p>Return the list of inneighbors of <code>mv</code> within <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.outneighbors-Union{Tuple{S}, Tuple{T}, Tuple{S, T}} where {T, S&lt;:(AbstractSubGraph{T, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{T}})}" href="#Graphs.outneighbors-Union{Tuple{S}, Tuple{T}, Tuple{S, T}} where {T, S&lt;:(AbstractSubGraph{T, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{T}})}"><code>Graphs.outneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outneighbors(subgraph::S, v::T) where {T,S&lt;:AbstractSubGraph{T}}</code></pre><p>Return the list of outneighbors of <code>v</code> within <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.outneighbors-Tuple{AbstractSubGraph, MultilayerVertex}" href="#Graphs.outneighbors-Tuple{AbstractSubGraph, MultilayerVertex}"><code>Graphs.outneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)</code></pre><p>Return the list of outneighbors of <code>mv</code> within <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.neighbors-Union{Tuple{S}, Tuple{T}, Tuple{S, T}} where {T, S&lt;:(AbstractSubGraph{T, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{T}})}" href="#Graphs.neighbors-Union{Tuple{S}, Tuple{T}, Tuple{S, T}} where {T, S&lt;:(AbstractSubGraph{T, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{T}})}"><code>Graphs.neighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbors(subgraph::S, v::T) where {T, S &lt;: AbstractSubGraph{T}}</code></pre><p>Return the list of neighbors of <code>v</code> within <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.neighbors-Tuple{AbstractSubGraph, MultilayerVertex}" href="#Graphs.neighbors-Tuple{AbstractSubGraph, MultilayerVertex}"><code>Graphs.neighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)</code></pre><p>Return the list of neighbors of <code>mv</code> within <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.edgetype-Union{Tuple{S}, Tuple{U}, Tuple{T}} where {T, U, S&lt;:(AbstractSubGraph{T, U, G} where G&lt;:AbstractGraph{T})}" href="#Graphs.edgetype-Union{Tuple{S}, Tuple{U}, Tuple{T}} where {T, U, S&lt;:(AbstractSubGraph{T, U, G} where G&lt;:AbstractGraph{T})}"><code>Graphs.edgetype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edgetype(::S) where {T,U,S&lt;:AbstractSubGraph{T,U}}</code></pre><p>Return the edge type for <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L208-L212">source</a></section><section><div><pre><code class="nohighlight hljs">edgetype(::M) where {T,U,M&lt;:AbstractMultilayerGraph{T,U}}</code></pre><p>Return the edge type for <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L209-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_edge-Union{Tuple{S}, Tuple{T}, Tuple{S, T, T}} where {T, S&lt;:(AbstractSubGraph{T, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{T}})}" href="#Graphs.has_edge-Union{Tuple{S}, Tuple{T}, Tuple{S, T, T}} where {T, S&lt;:(AbstractSubGraph{T, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{T}})}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_edge( subgraph::S, s::T, d::T) where {T,S&lt;:AbstractSubGraph{T}}</code></pre><p>Return <code>true</code> if there is an edge between <code>s</code> and <code>d</code>, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L235-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{S}, Tuple{G}, Tuple{W}, Tuple{U}, Tuple{T}, Tuple{S, T, T}} where {T, U&lt;:Real, W&lt;:Union{Nothing, U}, G&lt;:AbstractGraph{T}, S&lt;:AbstractSubGraph{T, U, G}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{S}, Tuple{G}, Tuple{W}, Tuple{U}, Tuple{T}, Tuple{S, T, T}} where {T, U&lt;:Real, W&lt;:Union{Nothing, U}, G&lt;:AbstractGraph{T}, S&lt;:AbstractSubGraph{T, U, G}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(subgraph::S, src::T, dst::T; weight::W = nothing, metadata::Union{Tuple, NamedTuple}= NamedTuple()) where {T, U&lt;: Real, W&lt;:Union{ U, Nothing},S&lt;:AbstractSubGraph{T,U}}</code></pre><p>Add edge from <code>src</code> to <code>dst</code> with weight <code>weight</code> and metadata <code>metadata</code> to <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L297-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.rem_edge!-Union{Tuple{S}, Tuple{T}, Tuple{S, T, T}} where {T, S&lt;:(AbstractSubGraph{T, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{T}})}" href="#Graphs.SimpleGraphs.rem_edge!-Union{Tuple{S}, Tuple{T}, Tuple{S, T, T}} where {T, S&lt;:(AbstractSubGraph{T, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{T}})}"><code>Graphs.SimpleGraphs.rem_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_edge!(subgraph::S, src::T, dst::T) where {T, S&lt;:AbstractSubGraph{T}}</code></pre><p>Remove edge from <code>src</code> to <code>dst</code> in a directed <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L332-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.AbstractLayer" href="#MultilayerGraphs.AbstractLayer"><code>MultilayerGraphs.AbstractLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractLayer{T,U,G}</code></pre><p>An abstract type representing a generic Layer.</p><p><strong>FIELDS</strong></p><ul><li><code>T</code>: the node type;</li><li><code>U</code>: the <code>MultilayerEdge</code> weight eltype;</li><li><code>G</code>: the underlying graph type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Layer-Union{Tuple{T}, Tuple{MultilayerGraphs.LayerDescriptor{T}, Vector{&lt;:MultilayerVertex}, Vector{&lt;:MultilayerEdge}}} where T&lt;:Integer" href="#MultilayerGraphs.Layer-Union{Tuple{T}, Tuple{MultilayerGraphs.LayerDescriptor{T}, Vector{&lt;:MultilayerVertex}, Vector{&lt;:MultilayerEdge}}} where T&lt;:Integer"><code>MultilayerGraphs.Layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Layer(
    descriptor::LayerDescriptor{T}, 
    vertices::Union{&lt;:Vector{&lt;:MultilayerVertex}, Vector{Node}}, 
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}) where {T &lt;: Integer}</code></pre><p>Constructor for <code>Layer</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>descriptor::LayerDescriptor{T}</code>;</li><li><code>vertices::Union{Vector{&lt;:MultilayerVertex}, Vector{&lt;:Node}}</code>;</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge},Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L51-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.rem_vertex!-Union{Tuple{L}, Tuple{T}, Tuple{L, T}} where {T, L&lt;:(Layer{T, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{T}})}" href="#Graphs.SimpleGraphs.rem_vertex!-Union{Tuple{L}, Tuple{T}, Tuple{L, T}} where {T, L&lt;:(Layer{T, U, G} where {U&lt;:Real, G&lt;:AbstractGraph{T}})}"><code>Graphs.SimpleGraphs.rem_vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem_vertex!(layer::L, v::T) where {T, L &lt;: Layer{T}}</code></pre><p>Remove vertex <code>v</code> from layer <code>layer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/layer.jl#L1930-L1934">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.AbstractInterlayer" href="#MultilayerGraphs.AbstractInterlayer"><code>MultilayerGraphs.AbstractInterlayer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractInterlayer{T,U,G}</code></pre><p>An abstract type representing a generic Interlayer.</p><p><strong>PARAMETRIC TYPES</strong></p><ul><li><code>T</code>: the node type;</li><li><code>U</code>: the adjacency matrix/tensor eltype;</li><li><code>G</code>: the underlying graph type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/interlayer.jl#L4-L14">source</a></section></article><h3 id="msm_dev"><a class="docs-heading-anchor" href="#msm_dev">Multilayer-Specific Methods</a><a id="msm_dev-1"></a><a class="docs-heading-anchor-permalink" href="#msm_dev" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.AbstractMultilayerGraph" href="#MultilayerGraphs.AbstractMultilayerGraph"><code>MultilayerGraphs.AbstractMultilayerGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMultilayerGraph{T &lt;: Integer, U &lt;: Real} &lt;: AbstractGraph{T}</code></pre><p>An abstract type for multilayer graphs. It is a subtype of AbstractGraph and its concrete subtypes may extend Graphs.jl.</p><p>Its concrete subtypes must have the following fields:</p><ul><li><code>idx_N_associations::Bijection{Int64,Node}</code>:;</li><li><code>v_V_associations::Bijection{T,&lt;:MultilayerVertex}</code>:;</li><li><code>v_metadata_dict::Dict{T,&lt;:Union{&lt;:Tuple,&lt;:NamedTuple}}</code>:;</li><li><code>layers</code>: an indexable collection of <code>Layer</code>s.</li><li><code>interlayers</code>:a collection of <code>Interlayer</code>s;</li><li><code>layers_names</code>: a collection of the names of the layers.</li><li><code>subgraphs_names</code>: a collection of the names of all the subgraphs.</li><li><code>fadjlist::Vector{Vector{HalfEdge{&lt;:MultilayerVertex,&lt;:Union{Nothing,U}}}}</code>: the forward adjacency list.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L26-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_vertex-Union{Tuple{M}, Tuple{T}, Tuple{M, T}} where {T, M&lt;:(AbstractMultilayerGraph{T})}" href="#Graphs.has_vertex-Union{Tuple{M}, Tuple{T}, Tuple{M, T}} where {T, M&lt;:(AbstractMultilayerGraph{T})}"><code>Graphs.has_vertex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_vertex(mg::M, v::T) where {T,M &lt;: AbstractMultilayerGraph{T}}</code></pre><p>Return true if <code>v</code> is in mg, else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.vertices-Tuple{AbstractMultilayerGraph}" href="#Graphs.vertices-Tuple{AbstractMultilayerGraph}"><code>Graphs.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertices(mg::M) where {M&lt;:AbstractMultilayerGraph}</code></pre><p>Return the collection of the vertices of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.inneighbors-Union{Tuple{M}, Tuple{T}, Tuple{M, T}} where {T, M&lt;:(AbstractMultilayerUGraph{T, &lt;:Real})}" href="#Graphs.inneighbors-Union{Tuple{M}, Tuple{T}, Tuple{M, T}} where {T, M&lt;:(AbstractMultilayerUGraph{T, &lt;:Real})}"><code>Graphs.inneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inneighbors(mg::M, v::T) where {T,M&lt;:AbstractMultilayerUGraph{T,&lt;:Real}}</code></pre><p>Return the list of inneighbors of <code>v</code> within <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerugraph.jl#L442-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.inneighbors-Union{Tuple{M}, Tuple{T}, Tuple{M, T}} where {T, M&lt;:(AbstractMultilayerGraph{T})}" href="#Graphs.inneighbors-Union{Tuple{M}, Tuple{T}, Tuple{M, T}} where {T, M&lt;:(AbstractMultilayerGraph{T})}"><code>Graphs.inneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inneighbors(mg::M, v::T</code></pre><p>) where {T, M&lt;:AbstractMultilayerGraph{T,&lt;:Real}}</p><p>Return the list of inneighbors of <code>v</code> within <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerdigraph.jl#L482-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.inneighbors-Tuple{AbstractMultilayerGraph, MultilayerVertex}" href="#Graphs.inneighbors-Tuple{AbstractMultilayerGraph, MultilayerVertex}"><code>Graphs.inneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inneighbors( mg::AbstractMultilayerGraph, mv::MultilayerVertex )</code></pre><p>Return the list of inneighbors of <code>mv</code> within <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L693-L697">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.outneighbors-Union{Tuple{M}, Tuple{T}, Tuple{M, T}} where {T, M&lt;:(AbstractMultilayerGraph{T})}" href="#Graphs.outneighbors-Union{Tuple{M}, Tuple{T}, Tuple{M, T}} where {T, M&lt;:(AbstractMultilayerGraph{T})}"><code>Graphs.outneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outneighbors(mg::M, v::T) where {T, M&lt;:AbstractMultilayerGraph{T}}</code></pre><p>Return the list of outneighbors of <code>v</code> within <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L711-L715">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.neighbors-Tuple{AbstractMultilayerGraph, MultilayerVertex}" href="#Graphs.neighbors-Tuple{AbstractMultilayerGraph, MultilayerVertex}"><code>Graphs.neighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighbors(mg::AbstractMultilayerGraph, mv::MultilayerVertex)</code></pre><p>Get the neighbors of vertex <code>mv</code> in <code>mg</code>. Reduces to <code>outneighbors</code> for both directed and undirected multilayer graphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L726-L730">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.edgetype-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}" href="#Graphs.edgetype-Union{Tuple{M}, Tuple{U}, Tuple{T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>Graphs.edgetype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edgetype(::S) where {T,U,S&lt;:AbstractSubGraph{T,U}}</code></pre><p>Return the edge type for <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/subgraphs/abstractsubgraph.jl#L208-L212">source</a></section><section><div><pre><code class="nohighlight hljs">edgetype(::M) where {T,U,M&lt;:AbstractMultilayerGraph{T,U}}</code></pre><p>Return the edge type for <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L209-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_edge-Union{Tuple{M}, Tuple{T}, Tuple{M, T, T}} where {T, M&lt;:(AbstractMultilayerUGraph{T})}" href="#Graphs.has_edge-Union{Tuple{M}, Tuple{T}, Tuple{M, T, T}} where {T, M&lt;:(AbstractMultilayerUGraph{T})}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_edge(mg::M, src::T, dst::T) where { T, M &lt;: AbstractMultilayerUGraph{T}}</code></pre><p>Return true if <code>mg</code> has edge between the <code>src</code> and <code>dst</code> (does not check edge or vertex metadata).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerugraph.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_edge-Union{Tuple{M}, Tuple{T}, Tuple{M, T, T}} where {T, M&lt;:(AbstractMultilayerDiGraph{T})}" href="#Graphs.has_edge-Union{Tuple{M}, Tuple{T}, Tuple{M, T, T}} where {T, M&lt;:(AbstractMultilayerDiGraph{T})}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_edge(mg::M, src::T, dst::T) where { T, M &lt;: AbstractMultilayerDiGraph{T}}</code></pre><p>Return true if <code>mg</code> has edge between the <code>src</code> and <code>dst</code> (does not check edge or vertex metadata).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayerdigraph.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, T, T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{M}, Tuple{U}, Tuple{T}, Tuple{M, T, T}} where {T, U, M&lt;:AbstractMultilayerGraph{T, U}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(mg::M, src::T, dst::T; weight::Union{Nothing, U} = one(U), metadata::Union{Tuple,NamedTuple} = NamedTuple() ) where {T,U, M &lt;: AbstractMultilayerGraph{T,U}}</code></pre><p>Internal method. Add a MultilayerEdge between <code>src</code> and <code>dst</code> with weight <code>weight</code> and metadata <code>metadata</code>. Return true if succeeds, false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/abstractmultilayergraph.jl#L243-L247">source</a></section></article><h3 id="representations_dev"><a class="docs-heading-anchor" href="#representations_dev">Representations</a><a id="representations_dev-1"></a><a class="docs-heading-anchor-permalink" href="#representations_dev" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.AbstractTensorRepresentation" href="#MultilayerGraphs.AbstractTensorRepresentation"><code>MultilayerGraphs.AbstractTensorRepresentation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractTensorRepresentation{U}</code></pre><p>An abstract type encoding a generic tensorial representation of the links and metadata of a multilayer graph. </p><p>Concrete subtypes must have an <code>array</code> field (a 4-dimensional tensor of eltype U, indexes as [source<em>node</em>idx, destination<em>node</em>idx, source<em>layer</em>idx, destination<em>layer</em>idx ]).</p><p><strong>PARAMETRIC TYPES</strong></p><ul><li><code>U</code>: the weight type of the multilayer graph.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/representations/abstracttensorrepresentation.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.AbstractMatrixRepresentation" href="#MultilayerGraphs.AbstractMatrixRepresentation"><code>MultilayerGraphs.AbstractMatrixRepresentation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMatrixRepresentation{T,U}</code></pre><p>An abstract type encoding a generic matrix representation of the links and metadata of a multilayer graph. </p><p>Concrete subtypes must have an <code>array</code> field (a matrix of eltype U) and a <code>v_V_associations</code> (a <code>Bijection{T, Union{MissingVertex, MultilayerVertex}}</code>).</p><p><strong>PARAMETRIC TYPES</strong></p><ul><li><code>T</code>: the type of the internal representation of vertices;</li><li><code>U</code>: the weight type of the multilayer graph.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/representations/abstractmatrixrepresentation.jl#L1-L12">source</a></section></article><h3 id="traits_dev"><a class="docs-heading-anchor" href="#traits_dev">Traits</a><a id="traits_dev-1"></a><a class="docs-heading-anchor-permalink" href="#traits_dev" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.IsWeighted" href="#MultilayerGraphs.IsWeighted"><code>MultilayerGraphs.IsWeighted</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsWeighted{X}</code></pre><p>Trait that discerns between weighted and unweighted graphs. A graph type should take the <code>IsWeighted</code> trait IF AND ONLY IF it implements the signature add_edge!(src,dst,weight). Otherwise it should not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/traits.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.IsMeta" href="#MultilayerGraphs.IsMeta"><code>MultilayerGraphs.IsMeta</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsMeta{X}</code></pre><p>Trait that discerns between graphs that sport edge and vertex metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/e6d6e25366f6b3229123679d0d81df0fa7ce6c1c/src/traits.jl#L25-L29">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 8 January 2023 18:36">Sunday 8 January 2023</span>. Using Julia version 1.8.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
