<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MultilayerGraphs.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://juliagraphs.org/MultilayerGraphs.jl/API_organized/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MultilayerGraphs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MultilayerGraphs.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../API/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/main/docs/src/API_organized.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>This page provides a list of exported methods organized by topic and audience. Methods that act on vertices, edges, and layers are grouped together. Some methods are intended for developers who want to use the <code>Graphs.jl</code> library as part of their code, while others are meant for end-users.</p><h2 id="End-User"><a class="docs-heading-anchor" href="#End-User">End-User</a><a id="End-User-1"></a><a class="docs-heading-anchor-permalink" href="#End-User" title="Permalink"></a></h2><h3 id="nodes_eu"><a class="docs-heading-anchor" href="#nodes_eu">Nodes</a><a id="nodes_eu-1"></a><a class="docs-heading-anchor-permalink" href="#nodes_eu" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Node</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.id" href="#MultilayerGraphs.id"><code>MultilayerGraphs.id</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">id(n::Node)</code></pre><p>Return the id of <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/node.jl#L17-L21">source</a></section></article><h3 id="vertices_eu"><a class="docs-heading-anchor" href="#vertices_eu">Vertices</a><a id="vertices_eu-1"></a><a class="docs-heading-anchor-permalink" href="#vertices_eu" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.eltype" href="#Base.eltype"><code>Base.eltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.eltype(subgraph::AbstractSubGraph)</code></pre><p>Return the vertex type of <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/abstractsubgraph.jl#L17-L21">source</a></section><section><div><pre><code class="language-julia hljs">eltype(::M) where {T,M&lt;:AbstractMultilayerGraph{T}}</code></pre><p>Return the vertex type of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/abstractmultilayergraph.jl#L128-L132">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>MultilayerVertex</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>MV</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.node" href="#MultilayerGraphs.node"><code>MultilayerGraphs.node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">node(mv::MultilayerVertex)</code></pre><p>Returns the Node represented by <code>mv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/vertices/multilayervertex.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer" href="#MultilayerGraphs.layer"><code>MultilayerGraphs.layer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer(mv::MultilayerVertex)</code></pre><p>Return the name of the layer which the <code>MultilayerVertex</code> belongs to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/vertices/multilayervertex.jl#L94-L98">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>metadata(mv::MultilayerVertex)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>MissingVertex</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="edges_eu"><a class="docs-heading-anchor" href="#edges_eu">Edges</a><a id="edges_eu-1"></a><a class="docs-heading-anchor-permalink" href="#edges_eu" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>MultilayerEdge</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ME</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>weight(e::AbstractMultilayerEdge)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>metadata(e::AbstractMultilayerEdge)</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="subgraphs_eu"><a class="docs-heading-anchor" href="#subgraphs_eu">Subgraphs</a><a id="subgraphs_eu-1"></a><a class="docs-heading-anchor-permalink" href="#subgraphs_eu" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Layer{T &lt;: Integer, U &lt;: Real, G &lt;: AbstractGraph{T}}</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Symbol, Union{Vector{MultilayerVertex{nothing}}, Vector{Node}}, Union{Vector{Tuple{MultilayerVertex{nothing}, MultilayerVertex{nothing}}}, Vector{&lt;:MultilayerEdge}}, G, Type{U}}} where {T&lt;:Integer, U&lt;:Real, G&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Symbol, Union{Vector{MultilayerVertex{nothing}}, Vector{Node}}, Union{Vector{Tuple{MultilayerVertex{nothing}, MultilayerVertex{nothing}}}, Vector{&lt;:MultilayerEdge}}, G, Type{U}}} where {T&lt;:Integer, U&lt;:Real, G&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.Layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Layer(
    name::Symbol, 
    vertices::Vector{&lt;: MultilayerVertex}, 
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}, 
    null_graph::G, 
    weighttype::Type{U};  
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_weight::Function = (src, dst) -&gt; one(U), d
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple()) where {T &lt;: Integer, U &lt;: Real,  G &lt;: AbstractGraph{T}}</code></pre><p>Constructor for <code>Layer</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li><li><code>null_graph::G</code>: the Layer&#39;s underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown;</li><li><code>weighttype::Type{U}</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L118-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Symbol, Union{Vector{MultilayerVertex{nothing}}, Vector{Node}}, Int64, G, Type{U}}} where {T&lt;:Integer, U&lt;:Real, G&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.Layer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Symbol, Union{Vector{MultilayerVertex{nothing}}, Vector{Node}}, Int64, G, Type{U}}} where {T&lt;:Integer, U&lt;:Real, G&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.Layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Layer(
    name::Symbol,
    vertices::Union{V, N},
    ne::Int64,
    null_graph::G,
    weighttype::Type{U};
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_weight::Function = (src, dst) -&gt; nothing,
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    allow_self_loops::Bool = false
) where {T&lt;:Integer,U&lt;:Real,G&lt;:AbstractGraph{T}, V &lt;: Vector{MultilayerVertex{nothing}}, N &lt;: Vector{Node}}</code></pre><p>Return a random <code>Layer</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>vertices::Union{V, N}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>name::Symbol</code>: The name of the Layer</li><li><code>ne::Int64</code>: The number of edges of the Layer</li><li><code>null_graph::G</code>: the Layer&#39;s underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.</li><li><code>weighttype::Type{U}</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted);</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>allow_self_loops::Bool</code>: whether to allow self loops to be generated or not. Defaults to <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L161-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer_simplegraph" href="#MultilayerGraphs.layer_simplegraph"><code>MultilayerGraphs.layer_simplegraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer_simplegraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>SimpleGraph</code> from <code>Graphs.jl</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L527-L545">source</a></section><section><div><pre><code class="language-julia hljs">layer_simplegraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    degree_distribution::UnivariateDistribution;
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>SimpleGraph</code> from <code>Graphs.jl</code> with a degree sequence sampled from <code>degree_distribution</code>. Realization is performed via the Havel-Hakimi algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>degree_distribution::UnivariateDistribution</code>: The degree distribution from which the degree sequence is sampled ;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L556-L574">source</a></section><section><div><pre><code class="language-julia hljs">layer_simplegraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    ne::Int64;
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Return a random <code>Layer</code> with <code>ne</code> edges whose underlying graph is a <code>SimpleGraph</code> from <code>Graphs.jl</code> with a degree sequence sampled from <code>degree_distribution</code>. Realization is performed via the Havel-Hakimi algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>ne::Int64</code>: The number of edges of the Layer;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L585-L603">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer_simpledigraph" href="#MultilayerGraphs.layer_simpledigraph"><code>MultilayerGraphs.layer_simpledigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer_simpledigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>SimpleDiGraph</code> from <code>Graphs.jl</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L615-L633">source</a></section><section><div><pre><code class="language-julia hljs">layer_simpledigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    indegree_distribution::UnivariateDistribution,
    outdegree_distribution::UnivariateDistribution;
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>SimplDiGraph{vertextype}</code> from <code>Graphs.jl</code> with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>indegree_distribution::UnivariateDistribution</code>: The degree distribution from which the indegree sequence is sampled ;</li><li><code>outdegree_distribution::UnivariateDistribution</code>: The degree distribution from which the outdegree sequence is sampled ;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L644-L664">source</a></section><section><div><pre><code class="language-julia hljs">layer_simpledigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    ne::Int64;
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Return a random <code>Layer</code> with <code>ne</code> edges whose underlying graph is a <code>SimplDiGraph{vertextype}</code> from <code>Graphs.jl</code> with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>ne::Int64</code>: The number of edges of the Layer;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L683-L701">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer_simpleweightedgraph" href="#MultilayerGraphs.layer_simpleweightedgraph"><code>MultilayerGraphs.layer_simpleweightedgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer_simpleweightedgraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};
    default_edge_weight::Function = (src,dst) -&gt; nothing,
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>SimpleWeightedGraph</code> from <code>SimpleWeightedGraphs.jl</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L713-L733">source</a></section><section><div><pre><code class="language-julia hljs">layer_simpleweightedgraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    degree_distribution::UnivariateDistribution;
    default_edge_weight::Function = (src,dst) -&gt; nothing,
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>SimpleWeightedGraph</code> from <code>SimpleWeightedGraphs.jl</code>. with a degree sequence sampled from <code>degree_distribution</code>. Realization is performed via the Havel-Hakimi algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>degree_distribution::UnivariateDistribution</code>: The degree distribution from which the degree sequence is sampled ;</li><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L752-L772">source</a></section><section><div><pre><code class="language-julia hljs">layer_simpleweightedgraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    ne::Int64;
    default_edge_weight::Function = (src,dst) -&gt; nothing,
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Return a random <code>Layer</code> with <code>ne</code> edges whose underlying graph is a <code>SimpleWeightedGraph</code> from <code>SimpleWeightedGraphs.jl</code>. with a degree sequence sampled from <code>degree_distribution</code>. Realization is performed via the Havel-Hakimi algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>ne::Int64</code>: The number of edges of the Layer;</li><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L791-L811">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer_simpleweighteddigraph" href="#MultilayerGraphs.layer_simpleweighteddigraph"><code>MultilayerGraphs.layer_simpleweighteddigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer_simpleweighteddigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};
    default_edge_weight::Function = (src,dst) -&gt; nothing,
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>SimpleWeightedDiGraph</code> from <code>SimpleWeightedGraphs.jl</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L831-L851">source</a></section><section><div><pre><code class="language-julia hljs">layer_simpleweighteddigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    indegree_distribution::UnivariateDistribution,
    outdegree_distribution::UnivariateDistribution;
    default_edge_weight::Function = (src,dst) -&gt; nothing,
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>SimpleWeightedDiGraph</code> from <code>SimpleWeightedGraphs.jl</code>, with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>indegree_distribution::UnivariateDistribution</code>: The degree distribution from which the indegree sequence is sampled ;</li><li><code>outdegree_distribution::UnivariateDistribution</code>: The degree distribution from which the outdegree sequence is sampled ;</li><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L870-L892">source</a></section><section><div><pre><code class="language-julia hljs">layer_simpleweighteddigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    ne::Int64;
    default_edge_weight::Function = (src,dst) -&gt; nothing,
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Return a random <code>Layer</code> with <code>ne</code> edges whose underlying graph is a <code>SimpleWeightedDiGraph</code> from <code>SimpleWeightedGraphs.jl</code>, with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>ne::Int64</code>: The number of edges of the Layer;</li><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L913-L932">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer_metadigraph" href="#MultilayerGraphs.layer_metadigraph"><code>MultilayerGraphs.layer_metadigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer_metadigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>MetaDiGraph</code> from <code>MetaGraphs.jl</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L1093-L1118">source</a></section><section><div><pre><code class="language-julia hljs">layer_metadigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    indegree_distribution::UnivariateDistribution,
    outdegree_distribution::UnivariateDistribution;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>MetaDiGraph</code> from <code>MetaDiGraphs.jl</code> with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>indegree_distribution::UnivariateDistribution</code>: The degree distribution from which the indegree sequence is sampled ;</li><li><code>outdegree_distribution::UnivariateDistribution</code>: The degree distribution from which the outdegree sequence is sampled ;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L1139-L1167">source</a></section><section><div><pre><code class="language-julia hljs">layer_metadigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    ne::Int64;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Return a random <code>Layer</code> with <code>ne</code> edges whose underlying graph is a <code>MetaDiGraph</code> from <code>MetaDiGraphs.jl</code> with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>ne::Int64</code>: The number of edges of the Layer;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L1190-L1216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer_valgraph" href="#MultilayerGraphs.layer_valgraph"><code>MultilayerGraphs.layer_valgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer_valgraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>ValGraph</code> from <code>SimpleValueGraphs.jl</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L1238-L1263">source</a></section><section><div><pre><code class="language-julia hljs">layer_valgraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    degree_distribution::UnivariateDistribution;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>ValGraph</code> from <code>SimpleValueGraphs.jl</code>. with a degree sequence sampled from <code>degree_distribution</code>. Realization is performed via the Havel-Hakimi algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>degree_distribution::UnivariateDistribution</code>: The degree distribution from which the degree sequence is sampled ;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L1315-L1341">source</a></section><section><div><pre><code class="language-julia hljs">layer_valgraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    ne::Int64;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Return a random <code>Layer</code> with <code>ne</code> edges whose underlying graph is a <code>ValGraph</code> from <code>SimpleValueGraphs.jl</code>. with a degree sequence sampled from <code>degree_distribution</code>. Realization is performed via the Havel-Hakimi algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>ne::Int64</code>: The number of edges of the Layer;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L1373-L1399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer_valoutdigraph" href="#MultilayerGraphs.layer_valoutdigraph"><code>MultilayerGraphs.layer_valoutdigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer_valoutdigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>ValOutDiGraph</code> from <code>SimpleValueGraphs.jl</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L1432-L1457">source</a></section><section><div><pre><code class="language-julia hljs">layer_valoutdigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    indegree_distribution::UnivariateDistribution,
    outdegree_distribution::UnivariateDistribution;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>ValOutDiGraph</code> from <code>SimpleValueGraphs.jl</code> with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>indegree_distribution::UnivariateDistribution</code>: The degree distribution from which the indegree sequence is sampled ;</li><li><code>outdegree_distribution::UnivariateDistribution</code>: The degree distribution from which the outdegree sequence is sampled ;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>. Do not type this function&#39;s arguments;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>,  Do not type this function&#39;s arguments;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L1489-L1516">source</a></section><section><div><pre><code class="language-julia hljs">layer_valoutdigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    ne::Int64;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Return a random <code>Layer</code> with <code>ne</code> edges whose underlying graph is a <code>ValOutDiGraph</code> from <code>SimpleValueGraphs.jl</code> with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>ne::Int64</code>: The number of edges of the Layer;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>. Do not type this function&#39;s arguments;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>,  Do not type this function&#39;s arguments;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L1550-L1575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer_valdigraph" href="#MultilayerGraphs.layer_valdigraph"><code>MultilayerGraphs.layer_valdigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer_valdigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>ValDiGraph</code> from <code>SimpleValueGraphs.jl</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L1608-L1633">source</a></section><section><div><pre><code class="language-julia hljs">layer_valdigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    indegree_distribution::UnivariateDistribution,
    outdegree_distribution::UnivariateDistribution;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>ValDiGraph</code> from <code>SimpleValueGraphs.jl</code> with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>indegree_distribution::UnivariateDistribution</code>: The degree distribution from which the indegree sequence is sampled ;</li><li><code>outdegree_distribution::UnivariateDistribution</code>: The degree distribution from which the outdegree sequence is sampled ;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>. Do not type this function&#39;s arguments;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>,  Do not type this function&#39;s arguments;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L1665-L1692">source</a></section><section><div><pre><code class="language-julia hljs">layer_valdigraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    ne::Int64;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Return a random <code>Layer</code> with <code>ne</code> edges whose underlying graph is a <code>ValDiGraph</code> from <code>SimpleValueGraphs.jl</code> with a indegree and outdegree sequences respectively sampled from <code>indegree_distribution</code> and <code>outdegree_distribution</code>. Realization is performed via the Kleitman-Wang algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>ne::Int64</code>: The number of edges of the Layer;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>. Do not type this function&#39;s arguments;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>,  Do not type this function&#39;s arguments;</li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L1726-L1751">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.layer_metagraph" href="#MultilayerGraphs.layer_metagraph"><code>MultilayerGraphs.layer_metagraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">layer_metagraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}};
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>MetaGraph</code> from <code>MetaGraphs.jl</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L952-L977">source</a></section><section><div><pre><code class="language-julia hljs">layer_metagraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    degree_distribution::UnivariateDistribution;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Constructor for a <code>Layer</code> whose underlying graph is a <code>MetaGraph</code> from <code>MetaGraphs.jl</code> with a degree sequence sampled from <code>degree_distribution</code>. Realization is performed via the Havel-Hakimi algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>degree_distribution::UnivariateDistribution</code>: The degree distribution from which the degree sequence is sampled ;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L998-L1024">source</a></section><section><div><pre><code class="language-julia hljs">layer_metagraph(
    name::Symbol,
    vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}},
    ne::Int64;
    default_vertex_metadata::Function = mv -&gt; NamedTuple(),
    default_edge_metadata::Function = (src, dst) -&gt; NamedTuple(),
    vertextype::Type{T} = Int64,
    weighttype::Type{U} = Float64
) where {T&lt;:Integer,U&lt;:Real}</code></pre><p>Return a random <code>Layer</code> with <code>ne</code> edges whose underlying graph is a <code>MetaGraph</code> from <code>MetaGraphs.jl</code> with a degree sequence sampled from <code>degree_distribution</code>. Realization is performed via the Havel-Hakimi algorithm.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>name::Symbol</code>: The name of the Layer;</li><li><code>vertices::Union{Vector{MultilayerVertex{nothing}},Vector{Node}}</code>: The <code>MultilayerVertex</code>s of the Layer. May be a vector of <code>MultilayerVertex{nothing}</code>s or a vector of <code>Node</code>s. In the latter case, the metadata of the <code>MultilayerVertex</code> to be added are computed via the <code>default_vertex_metadata</code> before the vertex is added (the function will act on each element of <code>MV.(vertices)</code>);</li><li><code>ne::Int64</code>: The number of edges of the Layer;</li></ul><p><strong>KWARGS</strong></p><p>-<code>default_vertex_metadata::Function</code>: Function that takes a <code>MultilayerVertex</code> and returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the vertex metadata. defaults to <code>mv -&gt; NamedTuple()</code>;</p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code></li><li><code>vertextype::Type{T} = Int64</code>: The type of the underlying integer labels associated to vertices.</li><li><code>weighttype::Type{U} = Float64</code>: The type of the <code>MultilayerEdge</code> weights (even when the underlying Layer&#39;s graph is unweighted, we need to specify a weight type since the <code>MultilayerGraph</code>s will always be weighted)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L1045-L1071">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>has_node(layer::Layer, n::Node)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>add_vertex!(layer::Layer, mv::MultilayerVertex)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>add_vertex!(layer::L, n::Node, args...; kwargs...) where {T, L &lt;: Layer{T}}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>rem_vertex!(layer::Layer, mv::MultilayerVertex)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>rem_vertex!(layer::Layer, n::Node)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Interlayer{T&lt;:Integer,U&lt;:Real,G&lt;:AbstractGraph{T}}</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G&lt;:AbstractGraph{T}, Layer{T, U, G} where G&lt;:AbstractGraph{T}, G, Vector{&lt;:MultilayerEdge{&lt;:Union{Nothing, U}}}}} where {T&lt;:Integer, U&lt;:Real, G&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G&lt;:AbstractGraph{T}, Layer{T, U, G} where G&lt;:AbstractGraph{T}, G, Vector{&lt;:MultilayerEdge{&lt;:Union{Nothing, U}}}}} where {T&lt;:Integer, U&lt;:Real, G&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.Interlayer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Interlayer(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    null_graph::G,
    edge_list::Vector{ &lt;: MultilayerEdge{&lt;: Union{U, Nothing}}};
    default_edge_weight::Function = (x,y) -&gt; nothing,
    default_edge_metadata::Function = (x,y) -&gt; NamedTuple(),
    transfer_vertex_metadata::Bool = false,
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Vector{ &lt;: MultilayerEdge{&lt;: Union{U, Nothing}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li><li><code>null_graph::G</code>: the Interlayer&#39;s underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li><li><code>transfer_vertex_metadata::Bool</code>:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don&#39;t support metadata or that pose limitations to it may result in errors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L80-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G&lt;:AbstractGraph{T}, Layer{T, U, G} where G&lt;:AbstractGraph{T}, Int64, G}} where {T&lt;:Integer, U&lt;:(Union{Nothing, var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real), G&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.Interlayer-Union{Tuple{G}, Tuple{U}, Tuple{T}, Tuple{Layer{T, U, G} where G&lt;:AbstractGraph{T}, Layer{T, U, G} where G&lt;:AbstractGraph{T}, Int64, G}} where {T&lt;:Integer, U&lt;:(Union{Nothing, var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real), G&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.Interlayer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Interlayer(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64,
    null_graph::G;
    default_edge_weight::Function = (x,y) -&gt; nothing,
    default_edge_metadata::Function = (x,y) -&gt; NamedTuple(),
    interlayer_name::Symbol,
    transfer_vertex_metadata::Bool = false
) where {T&lt;:Integer, U &lt;: Union{Nothing, &lt;: Real}, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random <code>Interlayer</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li><li><code>null_graph::G</code>: the Interlayer&#39;s underlying graph type, which must be passed as a null graph. If it is not, an error will be thrown.</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li><li><code>transfer_vertex_metadata::Bool</code>:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don&#39;t support metadata or that pose limitations to it may result in errors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L136-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.interlayer_simplegraph" href="#MultilayerGraphs.interlayer_simplegraph"><code>MultilayerGraphs.interlayer_simplegraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interlayer_simplegraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{&lt;:Union{U, Nothing}}}, Vector{ &lt;:Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}};
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer whose underlying graph is a <code>SimpleGraph</code> from <code>Graphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L448-L468">source</a></section><section><div><pre><code class="language-julia hljs">interlayer_simplegraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64;
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random Interlayer with <code>ne</code> edges whose underlying graph is a <code>SimpleGraph</code> from <code>Graphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L483-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.interlayer_simpleweightedgraph" href="#MultilayerGraphs.interlayer_simpleweightedgraph"><code>MultilayerGraphs.interlayer_simpleweightedgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interlayer_simpleweightedgraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}};
    default_edge_weight::Function=(x, y) -&gt; nothing,
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer whose underlying graph is a <code>SimpleWeightedGraph</code> from <code>SimpleWeightedGraphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L582-L604">source</a></section><section><div><pre><code class="language-julia hljs">interlayer_simpleweightedgraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64;
    default_edge_weight::Function=(x, y) -&gt; nothing,
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random Interlayer with <code>ne</code> edges whose underlying graph is a <code>SimpleWeightedGraph</code> from <code>SimpleWeightedGraphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L625-L647">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.interlayer_metagraph" href="#MultilayerGraphs.interlayer_metagraph"><code>MultilayerGraphs.interlayer_metagraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interlayer_metagraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}};
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple(),
    transfer_vertex_metadata::Bool=false,
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer whose underlying graph is a <code>MetaGraph</code> from <code>MetaGraphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>transfer_vertex_metadata::Bool</code>:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don&#39;t support metadata or that pose limitations to it may result in errors;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L748-L772">source</a></section><section><div><pre><code class="language-julia hljs">interlayer_metagraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64;
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple(),
    transfer_vertex_metadata::Bool=false,
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random Interlayer with <code>ne</code> edges whose underlying graph is a <code>MetaGraph</code> from <code>MetaGraphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>transfer_vertex_metadata::Bool</code>:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don&#39;t support metadata or that pose limitations to it may result in errors;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L795-L819">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.interlayer_valgraph" href="#MultilayerGraphs.interlayer_valgraph"><code>MultilayerGraphs.interlayer_valgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interlayer_valgraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}};
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple()
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer whose underlying graph is a <code>ValGraph</code> from <code>SimpleValueGraphs.jl</code>, with vertex type <code>T</code>. By default, <code>transfer_vertex_metadata</code> is set to <code>false</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L930-L952">source</a></section><section><div><pre><code class="language-julia hljs">interlayer_valgraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64;
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple()
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random Interlayer with <code>ne</code> edges whose underlying graph is a <code>ValGraph</code> from <code>SimpleValueGraphs.jl</code>, with vertex type <code>T</code>. By default, <code>transfer_vertex_metadata</code> is set to <code>false</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L979-L1001">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.interlayer_simpledigraph" href="#MultilayerGraphs.interlayer_simpledigraph"><code>MultilayerGraphs.interlayer_simpledigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interlayer_simpledigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}};
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer whose underlying graph is a <code>SimpleDiGraph</code> from <code>Graphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L515-L535">source</a></section><section><div><pre><code class="language-julia hljs">interlayer_simpledigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64;
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random Interlayer with <code>ne</code> edges whose underlying graph is a <code>SimpleDiGraph</code> from <code>Graphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L550-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.interlayer_simpleweighteddigraph" href="#MultilayerGraphs.interlayer_simpleweighteddigraph"><code>MultilayerGraphs.interlayer_simpleweighteddigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interlayer_simpleweighteddigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}};
    default_edge_weight::Function=(x, y) -&gt; nothing,
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer whose underlying graph is a <code>SimpleWeightedDiGraph</code> from <code>SimpleWeightedGraphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L665-L687">source</a></section><section><div><pre><code class="language-julia hljs">interlayer_simpleweighteddigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64;
    default_edge_weight::Function=(x, y) -&gt; nothing,
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random Interlayer with <code>ne</code> edges underlying graph is a <code>SimpleWeightedDiGraph</code> from <code>SimpleWeightedGraphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_weight::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and returns an edge weight of type <code>weighttype</code> or <code>nothing</code> (which is compatible with unweighted underlying graphs and corresponds to <code>one(weighttype)</code> for weighted underlying graphs). Defaults to <code>(src, dst) -&gt; nothing</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L708-L730">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.interlayer_metadigraph" href="#MultilayerGraphs.interlayer_metadigraph"><code>MultilayerGraphs.interlayer_metadigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interlayer_metadigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}};
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple(),
    transfer_vertex_metadata::Bool=false,
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer whose underlying graph is a <code>MetaDiGraph</code> from <code>MetaGraphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>transfer_vertex_metadata::Bool</code>:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don&#39;t support metadata or that pose limitations to it may result in errors;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L839-L863">source</a></section><section><div><pre><code class="language-julia hljs">interlayer_metadigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64;
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple(),
    transfer_vertex_metadata::Bool=false,
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random Interlayer with <code>ne</code> edges whose underlying graph is a <code>MetaDiGraph</code> from <code>MetaGraphs.jl</code>, with vertex type <code>T</code> and weight type <code>U</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>transfer_vertex_metadata::Bool</code>:if true, vertex metadata found in both connected layers are carried over to the vertices of the Interlayer. NB: not all choice of underlying graph may support this feature. Graphs types that don&#39;t support metadata or that pose limitations to it may result in errors;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L886-L910">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.interlayer_valoutdigraph" href="#MultilayerGraphs.interlayer_valoutdigraph"><code>MultilayerGraphs.interlayer_valoutdigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interlayer_valoutdigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}};
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple()
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer whose underlying graph is a <code>ValOutDiGraph</code> from <code>SimpleValueGraphs.jl</code>, with vertex type <code>T</code>. By default, <code>transfer_vertex_metadata</code> is set to <code>false</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L1025-L1047">source</a></section><section><div><pre><code class="language-julia hljs">interlayer_valoutdigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64;
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple()
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random Interlayer with <code>ne</code> edges whose underlying graph is a <code>ValOutDiGraph</code> from <code>SimpleValueGraphs.jl</code>, with vertex type <code>T</code>. By default, <code>transfer_vertex_metadata</code> is set to <code>false</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L1074-L1096">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.interlayer_valdigraph" href="#MultilayerGraphs.interlayer_valdigraph"><code>MultilayerGraphs.interlayer_valdigraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interlayer_valdigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}};
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple()
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Constructor for Interlayer whose underlying graph is a <code>ValDiGraph</code> from <code>SimpleValueGraphs.jl</code>, with vertex type <code>T</code>. By default, <code>transfer_vertex_metadata</code> is set to <code>false</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>edge_list::Union{&lt;:Vector{&lt;:MultilayerEdge{ &lt;: Union{U,Nothing}}}, &lt;:Vector{ &lt;: Tuple{&lt;:MultilayerVertex, &lt;:MultilayerVertex}}}</code>: The list of <code>MultilayerEdge</code>s. It may be a vector of <code>MultilayerEdge</code>s or a Vector of 2-tuples of <code>MultilayerVertex</code>s. In the latter case, the weight and the metadata of the <code>MultilayerEdge</code> to be added are computed respectively via the <code>default_edge_weight</code> and <code>default_edge_metadata</code> functions;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L1120-L1142">source</a></section><section><div><pre><code class="language-julia hljs">interlayer_valdigraph(
    layer_1::Layer{T,U},
    layer_2::Layer{T,U},
    ne::Int64;
    default_edge_metadata::Function=(x, y) -&gt; NamedTuple()
    interlayer_name::Symbol
) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code></pre><p>Return a random Interlayer with <code>ne</code> edges whose underlying graph is a <code>ValDiGraph</code> from <code>SimpleValueGraphs.jl</code>, with vertex type <code>T</code>. By default, <code>transfer_vertex_metadata</code> is set to <code>false</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layer_1::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>layer_2::Layer{T,U}</code>: one of the two layers connected by the Interlayer;</li><li><code>ne::Int64</code>: The number of edges of the Interlayer;</li></ul><p><strong>KWARGS</strong></p><ul><li><code>default_edge_metadata::Function</code>: Function that takes a pair of <code>MultilayerVertex</code>s and  returns a <code>Tuple</code> or a <code>NamedTuple</code> containing the edge metadata, that will be called when <code>add_edge!(mg,src,dst, args...; kwargs...)</code> is called without the <code>metadata</code> keyword argument, and when generating the edges in this constructor. Defaults to  <code>(src, dst) -&gt; NamedTuple()</code>;</li><li><code>interlayer_name::Symbol</code>: The name of the Interlayer. Defaults to Symbol(&quot;interlayer<em>(layer</em>1.name)<em>(layer</em>2.name)&quot;);</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/interlayer.jl#L1169-L1191">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>multiplex_interlayer(     layer_1::Layer{T,U},     layer_2::Layer{T,U},     null_graph::G;     default_edge_weight::Function = (x,y) -&gt; nothing,     default_edge_metadata::Function = (x,y) -&gt; NamedTuple(),     transfer_vertex_metadata::Bool = false,     name::Symbol = Symbol(&quot;interlayer_$(layer_1.name)_$(layer_2.name)&quot;) ) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>empty_interlayer(     layer_1::Layer{T,U},     layer_2::Layer{T,U},     null_graph::G;     default_edge_weight::Function = (x,y) -&gt; nothing,     default_edge_metadata::Function = (x,y) -&gt; NamedTuple(),     name::Symbol = Symbol(&quot;interlayer_$(layer_1.name)_$(layer_2.name)&quot;),     transfer_vertex_metadata::Bool = false ) where {T&lt;:Integer, U &lt;: Real, G&lt;:AbstractGraph{T}}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>nodes(subgraph::AbstractSubGraph)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>has_vertex(layer::Layer, mv::MultilayerVertex)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>has_vertex(interlayer::Interlayer, mv::MultilayerVertex)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>nv(subgraph::AbstractSubGraph)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>mv_vertices(subgraph::AbstractSubGraph)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>mv_inneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>mv_outneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>mv_neighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>has_edge(subgraph::AbstractSubGraph,me::MultilayerEdge)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>has_edge( subgraph::AbstractSubGraph, s::MultilayerVertex, d::MultilayerVertex)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>has_edge( layer::Layer, s::MultilayerVertex{nothing}, d::MultilayerVertex{nothing})</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ne(subgraph::AbstractSubGraph)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>edges(subgraph::S) where {T,U,S&lt;:AbstractSubGraph{T,U}}</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{S}, Tuple{U}, Tuple{T}, Tuple{S, E}} where {T, U&lt;:Real, S&lt;:(AbstractSubGraph{T, U, G} where G&lt;:AbstractGraph{T}), E&lt;:(MultilayerEdge{&lt;:Union{Nothing, U}})}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{E}, Tuple{S}, Tuple{U}, Tuple{T}, Tuple{S, E}} where {T, U&lt;:Real, S&lt;:(AbstractSubGraph{T, U, G} where G&lt;:AbstractGraph{T}), E&lt;:(MultilayerEdge{&lt;:Union{Nothing, U}})}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!( subgraph::S, me::E) where {T,U&lt;:Real,S&lt;:AbstractSubGraph{T,U},E&lt;:MultilayerEdge{ &lt;: Union{U, Nothing}}}</code></pre><p>Add unweighted edge <code>me</code> to <code>subgraph</code>. Its <code>weight</code> and <code>metadata</code> fields are passed to the uniform interface of <a href="../API/#Graphs.SimpleGraphs.add_edge!-Tuple{Layer, MultilayerVertex, MultilayerVertex, Vararg{Any}}"><code>add_edge!(::Layer, ::MultilayerVertex, ::MultilayerVertex, ::Tuple)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/abstractsubgraph.jl#L264-L268">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>add_edge!(layer::Layer, src::MultilayerVertex, dst::MultilayerVertex, args...; kwargs...)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>add_edge!(interlayer::Interlayer, src::MultilayerVertex, dst::MultilayerVertex, args...; kwargs...)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>rem_edge!(subgraph::AbstractSubGraph, src::MultilayerVertex, dst::MultilayerVertex)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>rem_edge!(subgraph::AbstractSubGraph, me::MultilayerEdge)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>get_metadata(subgraph::AbstractSubGraph, bare_mv::MultilayerVertex)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.get_metadata-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}" href="#MultilayerGraphs.get_metadata-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}"><code>MultilayerGraphs.get_metadata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_edge_metadata(subgraph::S, src::MultilayerVertex, dst::MultilayerVertex)</code></pre><p>Return the metadata of the edge between the source vertex <code>src</code> and the destination vertex <code>dst</code> in <code>subgraph</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/abstractsubgraph.jl#L353-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimpleWeightedGraphs.get_weight-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}" href="#SimpleWeightedGraphs.get_weight-Tuple{AbstractSubGraph, MultilayerVertex, MultilayerVertex}"><code>SimpleWeightedGraphs.get_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_weight(subgraph::S, src::MultilayerVertex, dst::MultilayerVertex)</code></pre><p>Return the weight of the edge between the source vertex <code>src</code> and the destination vertex <code>dst</code> in <code>subgraph</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/abstractsubgraph.jl#L364-L368">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>is_directed(subgraph::AbstractSubGraph)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>is_directed(::Type{S}) where {T,U,G,S &lt;: AbstractSubGraph{T,U,G}}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>adjacency_matrix(subgraph::AbstractSubGraph)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>MultilayerGraphs.weights(subgraph::S) where {T,U,S&lt;:AbstractSubGraph{T,U}}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>is_multiplex_interlayer(interlayer::Interlayer)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>get_symmetric_interlayer(     interlayer::In;     symmetric_interlayer_name::String = String(interlayer.name) * &quot;_rev&quot; ) where {T,U,G,In&lt;:Interlayer{T,U,G}}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>name(subgraph::AbstractSubGraph)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>graph(subgraph::AbstractSubGraph)</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="msm_eu"><a class="docs-heading-anchor" href="#msm_eu">Multilayer-Specific Methods</a><a id="msm_eu-1"></a><a class="docs-heading-anchor-permalink" href="#msm_eu" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>MultilayerGraph{T,U}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>MultilayerDiGraph{T,U}</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerGraph-Tuple{Type{&lt;:Number}, Type{&lt;:Number}}" href="#MultilayerGraphs.MultilayerGraph-Tuple{Type{&lt;:Number}, Type{&lt;:Number}}"><code>MultilayerGraphs.MultilayerGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerGraph(T::Type{&lt;:Number}, U::Type{&lt;:Number})</code></pre><p>Return a null MultilayerGraph with with vertex type <code>T</code> weighttype <code>U</code>. Use this constructor and then add Layers and Interlayers via the <code>add_layer!</code> and <code>specify_interlayer!</code> methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/multilayergraph.jl#L164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerDiGraph-Tuple{Type{&lt;:Number}, Type{&lt;:Number}}" href="#MultilayerGraphs.MultilayerDiGraph-Tuple{Type{&lt;:Number}, Type{&lt;:Number}}"><code>MultilayerGraphs.MultilayerDiGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerDiGraph(n_nodes::Int64, T::Type{ &lt;: Number}, U::Type{ &lt;: Number} )</code></pre><p>Return a null MultilayerDiGraph with with vertex type <code>T</code> weighttype <code>U</code>. Use this constructor and then add Layers and Interlayers via the <code>add_layer!</code> and <code>specify_interlayer!</code> methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/multilayerdigraph.jl#L179-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:AbstractGraph{T}}}} where {T, U, H&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.MultilayerGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:AbstractGraph{T}}}} where {T, U, H&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.MultilayerGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerGraph(
    layers::Vector{&lt;:Layer{T,U}},
    specified_interlayers::Vector{&lt;:Interlayer{T,U}};
    default_interlayers_null_graph::H = SimpleGraph{T}(),
    default_interlayers_structure::String=&quot;multiplex&quot;,
) where {T,U, H &lt;: AbstractGraph{T}}</code></pre><p>Construct a MultilayerGraph with layers given by <code>layers</code>. The interlayers will be constructed by default according to <code>default_interlayer</code> where only <code>&quot;multiplex&quot;</code> and <code>&quot;empty&quot;</code> are allowed, except for those specified in <code>specified_interlayers</code>. <code>default_interlayer = &quot;multiplex&quot;</code> will imply that unspecified interlayers will have only diagonal couplings, while  <code>default_interlayer = &quot;multiplex&quot;</code> will produced interlayers that have no couplings.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>layers::Vector{&lt;:Layer{T,U}}</code>: The (ordered) list of layers the multilayer graph will have;</li><li><code>specified_interlayers::Vector{&lt;:Interlayer{T,U}}</code>: The list of interlayers specified by the user. Note that the user does not need to specify all interlayers, as the unspecified ones will be automatically constructed using the indications given by the <code>default_interlayers_null_graph</code> and <code>default_interlayers_structure</code> keywords;</li><li><code>default_interlayers_null_graph::H = SimpleGraph{T}()</code>: Sets the underlying graph for the interlayers that are to be automatically specified. Defaults to <code>SimpleGraph{T}()</code>. See the <code>Interlayer</code> constructors for more information;</li><li><code>default_interlayers_structure::String = &quot;multiplex&quot;</code>: Sets the structure of the interlayers that are to be automatically specified. May be &quot;multiplex&quot; for diagonally coupled interlayers, or &quot;empty&quot; for empty interlayers (no edges).  &quot;multiplex&quot;. See the <code>Interlayer</code> constructors for more information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/multilayergraph.jl#L27-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerDiGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:AbstractGraph{T}}}} where {T, U, H&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.MultilayerDiGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:AbstractGraph{T}}}} where {T, U, H&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.MultilayerDiGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerDiGraph(
    layers::Vector{&lt;:Layer{T,U}},
    specified_interlayers::Vector{&lt;:Interlayer{T,U}};
    default_interlayers_null_graph::H = SimpleGraph{T}(),
    default_interlayers_structure::String=&quot;multiplex&quot;,
) where {T,U, H &lt;: AbstractGraph{T}}</code></pre><p>Construct a MultilayerDiGraph with layers given by <code>layers</code>. The interlayers will be constructed by default according to <code>default_interlayer</code> where only <code>&quot;multiplex&quot;</code> and <code>&quot;empty&quot;</code> are allowed, except for those specified in <code>specified_interlayers</code>. <code>default_interlayer = &quot;multiplex&quot;</code> will imply that unspecified interlayers will have only diagonal couplings, while  <code>default_interlayer = &quot;multiplex&quot;</code> will produced interlayers that have no couplings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/multilayerdigraph.jl#L28-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:AbstractGraph{T}}, UnivariateDistribution}} where {T&lt;:Integer, U&lt;:Real, H&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.MultilayerGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:AbstractGraph{T}}, UnivariateDistribution}} where {T&lt;:Integer, U&lt;:Real, H&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.MultilayerGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerGraph(
    empty_layers::Vector{&lt;:Layer{T,U}},
    empty_interlayers::Vector{&lt;:Interlayer{T,U}},
    degree_distribution::UnivariateDistribution;
    allow_self_loops::Bool = false,
    default_interlayers_null_graph::H = SimpleGraph{T}(),
) where {T &lt;: Integer, U &lt;: Real, H &lt;: AbstractGraph{T}}</code></pre><p>Return a random MultilayerGraph that has <code>empty_layers</code> as layers and <code>empty_interlayers</code> as specified interlayers. <code>empty_layers</code> and <code>empty_interlayers</code> must respectively be <code>Layer</code>s and <code>Interlayer</code>s with whatever number of vertices but no edges (if any edge is found, an error is thrown). The  degree distribution of the returned random <code>MultilayerGraph</code> is given by <code>degree_distribution</code>, which must have a support that only contains positive numbers for obvious reasons. <code>allow_self_loops = true</code> allows for self loops t be present in the final random MultilayerGraph. <code>default_interlayers_null_graph</code> controls the <code>null_graph</code> argument passed to automatically-generated interlayers. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/multilayergraph.jl#L70-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerDiGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:AbstractGraph{T}}, UnivariateDistribution, UnivariateDistribution}} where {T&lt;:Integer, U&lt;:Real, H&lt;:AbstractGraph{T}}" href="#MultilayerGraphs.MultilayerDiGraph-Union{Tuple{H}, Tuple{U}, Tuple{T}, Tuple{Vector{&lt;:Layer{T, U, G} where G&lt;:AbstractGraph{T}}, Vector{&lt;:Interlayer{T, U, G} where G&lt;:AbstractGraph{T}}, UnivariateDistribution, UnivariateDistribution}} where {T&lt;:Integer, U&lt;:Real, H&lt;:AbstractGraph{T}}"><code>MultilayerGraphs.MultilayerDiGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerDiGraph(
    empty_layers::Vector{&lt;:Layer{T,U}},
    empty_interlayers::Vector{&lt;:Interlayer{T,U}},
    indegree_distribution::UnivariateDistribution,
    outdegree_distribution::UnivariateDistribution;
    allow_self_loops::Bool = false,
    default_interlayers_null_graph::H = SimpleGraph{T}(),
) where {T &lt;: Integer, U &lt;: Real, H &lt;: AbstractGraph{T}}</code></pre><p>Return a random MultilayerDiGraph that has <code>empty_layers</code> as layers and <code>empty_interlayers</code> as specified interlayers. <code>empty_layers</code> and <code>empty_interlayers</code> must respectively be <code>Layer</code>s and <code>Interlayer</code>s with whatever number of vertices but no edges (if any edge is found, an error is thrown). The  degree distribution of the returned random <code>MultilayerDiGraph</code> is given by <code>degree_distribution</code>, which must have a support that only contains positive numbers for obvious reasons. <code>allow_self_loops = true</code> allows for self loops t be present in the final random MultilayerDiGraph. <code>default_interlayers_null_graph</code> controls the <code>null_graph</code> argument passed to automatically-generated interlayers. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/multilayerdigraph.jl#L64-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerGraph-Union{Tuple{U}, Tuple{T}, Tuple{MultilayerGraph{T, U}, Vector{&lt;:Integer}}} where {T, U}" href="#MultilayerGraphs.MultilayerGraph-Union{Tuple{U}, Tuple{T}, Tuple{MultilayerGraph{T, U}, Vector{&lt;:Integer}}} where {T, U}"><code>MultilayerGraphs.MultilayerGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerGraph(empty_multilayergraph::MultilayerGraph{T,U},
degree_sequence::Vector{&lt;:Integer}; 
allow_self_loops::Bool = false,
perform_checks::Bool = false) where {T,U}</code></pre><p>Return a random <code>MultilayerGraph</code> with degree sequence <code>degree_sequence</code>. <code>allow_self_loops</code> controls the presence of self-loops, while if <code>perform_checks</code> is true, the <code>degree_sequence</code> os checked to be graphical.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/multilayergraph.jl#L110-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.MultilayerDiGraph-Union{Tuple{U}, Tuple{T}, Tuple{MultilayerDiGraph{T, U}, Vector{&lt;:Integer}, Vector{&lt;:Integer}}} where {T, U}" href="#MultilayerGraphs.MultilayerDiGraph-Union{Tuple{U}, Tuple{T}, Tuple{MultilayerDiGraph{T, U}, Vector{&lt;:Integer}, Vector{&lt;:Integer}}} where {T, U}"><code>MultilayerGraphs.MultilayerDiGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultilayerDiGraph(
    empty_multilayerdigraph::MultilayerDiGraph{T,U}, 
    indegree_sequence::Vector{&lt;:Integer},
    outdegree_sequence::Vector{&lt;:Integer};
    allow_self_loops::Bool = false,
    perform_checks::Bool = false
) where {T,U}</code></pre><p>Return a random <code>MultilayerDiGraph</code> with degree sequence <code>degree_sequence</code>. <code>allow_self_loops</code> controls the presence of self-loops, while if <code>perform_checks</code> is true, the <code>degree_sequence</code> os checked to be graphical.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/multilayerdigraph.jl#L112-L122">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SynchronizedEdgeColoredGraph{T,U}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SynchronizedEdgeColoredGraph(     layers::Vector{&lt;:Layer{T,U}}, ) where {T,U}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SynchronizedEdgeColoredDiGraph{T,U}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>nodes(mg::AbstractMultilayerGraph)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>nn(mg::AbstractMultilayerGraph)</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="representations_eu"><a class="docs-heading-anchor" href="#representations_eu">Representations</a><a id="representations_eu-1"></a><a class="docs-heading-anchor-permalink" href="#representations_eu" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>array(atr::AbstractTensorRepresentation)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>WeightTensor{U}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>weight_tensor(mg::M) where {T,U, M &lt;: AbstractMultilayerGraph{T,U}}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>MetadataTensor{U}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>metadata_tensor(mg::M) where {T,U, M &lt;: AbstractMultilayerGraph{T,U}}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>array(amr::AbstractMatrixRepresentation)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SupraWeightMatrix{T,U}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>supra_weight_matrix(mg::M) where {T,U, M &lt;: AbstractMultilayerGraph{T,U}}</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="traits_eu"><a class="docs-heading-anchor" href="#traits_eu">Traits</a><a id="traits_eu-1"></a><a class="docs-heading-anchor-permalink" href="#traits_eu" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>is_weighted(g::G) where { G &lt;: AbstractGraph}</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.is_weighted-Tuple{G} where G&lt;:(Type{&lt;:AbstractGraph})" href="#MultilayerGraphs.is_weighted-Tuple{G} where G&lt;:(Type{&lt;:AbstractGraph})"><code>MultilayerGraphs.is_weighted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_weighted(g::G) where {G&lt;:Type{&lt;:AbstractGraph}}</code></pre><p>Check whether <code>g</code> is weighted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/traits.jl#L18-L22">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>is_meta(g::G) where {G &lt;: AbstractGraph}</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.is_meta-Tuple{G} where G&lt;:(Type{&lt;:AbstractGraph})" href="#MultilayerGraphs.is_meta-Tuple{G} where G&lt;:(Type{&lt;:AbstractGraph})"><code>MultilayerGraphs.is_meta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_meta(g::G) where {G&lt;:Type{&lt;:AbstractGraph}}</code></pre><p>Check whether <code>g</code> supports edge AND vertex metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/traits.jl#L42-L46">source</a></section></article><h3 id="utilities_eu"><a class="docs-heading-anchor" href="#utilities_eu">Utilities</a><a id="utilities_eu-1"></a><a class="docs-heading-anchor-permalink" href="#utilities_eu" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>multilayer_kronecker_delta(dims::NTuple{4,Int64})</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>δk{T}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>δk(N::Int64)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>δ_1{T&lt;: Number}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>δ_2{T&lt;:Number}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>δ_3{T&lt;:Number}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>δ_Ω{T}</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Developer"><a class="docs-heading-anchor" href="#Developer">Developer</a><a id="Developer-1"></a><a class="docs-heading-anchor-permalink" href="#Developer" title="Permalink"></a></h2><h3 id="nodes_dev"><a class="docs-heading-anchor" href="#nodes_dev">Nodes</a><a id="nodes_dev-1"></a><a class="docs-heading-anchor-permalink" href="#nodes_dev" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractNode</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="vertices_dev"><a class="docs-heading-anchor" href="#vertices_dev">Vertices</a><a id="vertices_dev-1"></a><a class="docs-heading-anchor-permalink" href="#vertices_dev" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractVertex</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractMultilayerVertex</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="edges_dev"><a class="docs-heading-anchor" href="#edges_dev">Edges</a><a id="edges_dev-1"></a><a class="docs-heading-anchor-permalink" href="#edges_dev" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractMultilayerEdge</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>metadata(he::MultilayerGraphs.HalfEdge)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>weight(he::MultilayerGraphs.HalfEdge)</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="subgraphs_dev"><a class="docs-heading-anchor" href="#subgraphs_dev">Subgraphs</a><a id="subgraphs_dev-1"></a><a class="docs-heading-anchor-permalink" href="#subgraphs_dev" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>has_vertex(subgraph::S, v::T ) where {T,S&lt;:AbstractSubGraph{T}}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>vertices(subgraph::AbstractSubGraph)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>inneighbors(subgraph::S, v::T) where {T, S &lt;: AbstractSubGraph{T}}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>inneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>outneighbors(subgraph::S, v::T) where {T,S&lt;:AbstractSubGraph{T}}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>outneighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>neighbors(subgraph::S, v::T) where {T,S&lt;:AbstractSubGraph{T}}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>neighbors(subgraph::AbstractSubGraph, mv::MultilayerVertex)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>edgetype(::S) where {T,U,S&lt;:AbstractSubGraph{T,U}}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>has_edge( subgraph::S, s::T, d::T) where {T,S&lt;:AbstractSubGraph{T}}</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!-Union{Tuple{S}, Tuple{G}, Tuple{W}, Tuple{U}, Tuple{T}, Tuple{S, T, T}} where {T, U&lt;:Real, W&lt;:Union{Nothing, U}, G&lt;:AbstractGraph{T}, S&lt;:AbstractSubGraph{T, U, G}}" href="#Graphs.SimpleGraphs.add_edge!-Union{Tuple{S}, Tuple{G}, Tuple{W}, Tuple{U}, Tuple{T}, Tuple{S, T, T}} where {T, U&lt;:Real, W&lt;:Union{Nothing, U}, G&lt;:AbstractGraph{T}, S&lt;:AbstractSubGraph{T, U, G}}"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge!(subgraph::S, src::T, dst::T; weight::W = nothing, metadata::Union{Tuple, NamedTuple}= NamedTuple()) where {T, U&lt;: Real, W&lt;:Union{ U, Nothing},S&lt;:AbstractSubGraph{T,U}}</code></pre><p>Add edge from <code>src</code> to <code>dst</code> with weight <code>weight</code> and metadata <code>metadata</code> to <code>subgraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/abstractsubgraph.jl#L296-L300">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>rem_edge!(subgraph::S, src::T, dst::T) where {T, S&lt;:AbstractSubGraph{T}}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractLayer</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="MultilayerGraphs.Layer-Union{Tuple{T}, Tuple{MultilayerGraphs.LayerDescriptor{T}, Vector{&lt;:MultilayerVertex}, Vector{&lt;:MultilayerEdge}}} where T&lt;:Integer" href="#MultilayerGraphs.Layer-Union{Tuple{T}, Tuple{MultilayerGraphs.LayerDescriptor{T}, Vector{&lt;:MultilayerVertex}, Vector{&lt;:MultilayerEdge}}} where T&lt;:Integer"><code>MultilayerGraphs.Layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Layer(
    descriptor::LayerDescriptor{T}, 
    vertices::Union{&lt;:Vector{&lt;:MultilayerVertex}, Vector{Node}}, 
    edge_list::Union{Vector{&lt;:MultilayerEdge}, Vector{NTuple{2, MultilayerVertex{nothing}}}}) where {T &lt;: Integer}</code></pre><p>Constructor for <code>Layer</code>.</p><p><strong>ARGUMENTS</strong></p><ul><li><code>descriptor::LayerDescriptor{T}</code>;</li><li><code>vertices::Union{Vector{&lt;:MultilayerVertex}, Vector{&lt;:Node}}</code>;</li><li><code>edge_list::Union{Vector{&lt;:MultilayerEdge},Vector{NTuple{2, MultilayerVertex{nothing}}}}</code>;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/subgraphs/layer.jl#L51-L64">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>rem_vertex!(layer::L, v::T) where {T, L &lt;: Layer{T}}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractInterlayer</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="msm_dev"><a class="docs-heading-anchor" href="#msm_dev">Multilayer-Specific Methods</a><a id="msm_dev-1"></a><a class="docs-heading-anchor-permalink" href="#msm_dev" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractMultilayerGraph{T &lt;: Integer, U &lt;: Real}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>fadjlist</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>has_vertex(mg::M, v::T) where {T, M &lt;: AbstractMultilayerGraph{T}}</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Graphs.vertices-Tuple{AbstractMultilayerGraph}" href="#Graphs.vertices-Tuple{AbstractMultilayerGraph}"><code>Graphs.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertices(mg::M) where {M&lt;:AbstractMultilayerGraph}</code></pre><p>Return the collection of the vertices of <code>mg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/MultilayerGraphs.jl/blob/ea082d9abde99e6c18feb6d81e3c7ae20f92c7ec/src/abstractmultilayergraph.jl#L167-L171">source</a></section></article><h3 id="representations_dev"><a class="docs-heading-anchor" href="#representations_dev">Representations</a><a id="representations_dev-1"></a><a class="docs-heading-anchor-permalink" href="#representations_dev" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractTensorRepresentation{U}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractMatrixRepresentation{T,U}</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="traits_dev"><a class="docs-heading-anchor" href="#traits_dev">Traits</a><a id="traits_dev-1"></a><a class="docs-heading-anchor-permalink" href="#traits_dev" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>IsWeighted{X}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>IsMeta{X}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>IsMultiplex{X}</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 24 January 2023 11:03">Tuesday 24 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
